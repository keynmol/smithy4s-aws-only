package com.amazonaws.comprehend

import smithy4s.Endpoint
import smithy4s.Hints
import smithy4s.Schema
import smithy4s.Service
import smithy4s.ShapeId
import smithy4s.Transformation
import smithy4s.kinds.PolyFunction5
import smithy4s.kinds.toPolyFunction5.const5
import smithy4s.schema.ErrorSchema
import smithy4s.schema.OperationSchema
import smithy4s.schema.Schema.bijection
import smithy4s.schema.Schema.union

/** <p>Amazon Comprehend is an Amazon Web Services service for gaining insight into the content of documents.
  *       Use these actions to determine the topics contained in your documents, the topics they
  *       discuss, the predominant sentiment expressed in them, the predominant language used, and
  *       more.</p>
  */
trait ComprehendGen[F[_, _, _, _, _]] {
  self =>

  /** <p>Determines the dominant language of the input text for a batch of documents. For a list
    *       of languages that Amazon Comprehend can detect, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-languages.html">Amazon Comprehend Supported Languages</a>.
    *     </p>
    * @param TextList
    *   <p>A list containing the UTF-8 encoded text of the input documents. The list can contain a maximum of 25
    *         documents. Each document should contain at least 20 characters. The maximum size of each document is 5 KB.</p>
    */
  def batchDetectDominantLanguage(textList: List[CustomerInputString]): F[BatchDetectDominantLanguageRequest, ComprehendOperation.BatchDetectDominantLanguageError, BatchDetectDominantLanguageResponse, Nothing, Nothing]
  /** <p>Inspects the text of a batch of documents for named entities and returns information
    *       about them. For more information about named entities, see
    *       <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-entities.html">Entities</a> in the Comprehend Developer Guide.
    *     </p>
    * @param TextList
    *   <p>A list containing the UTF-8 encoded text of the input documents. The list can contain a maximum of 25
    *         documents. The maximum size of each document is 5 KB.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the primary languages
    *         supported by Amazon Comprehend. All documents must be in the same language.</p>
    */
  def batchDetectEntities(textList: List[CustomerInputString], languageCode: LanguageCode): F[BatchDetectEntitiesRequest, ComprehendOperation.BatchDetectEntitiesError, BatchDetectEntitiesResponse, Nothing, Nothing]
  /** <p>Detects the key noun phrases found in a batch of documents.</p>
    * @param TextList
    *   <p>A list containing the UTF-8 encoded text of the input documents. The list can contain a maximum of 25
    *         documents. The maximum size of each document is 5 KB.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the primary languages
    *         supported by Amazon Comprehend. All documents must be in the same language.</p>
    */
  def batchDetectKeyPhrases(textList: List[CustomerInputString], languageCode: LanguageCode): F[BatchDetectKeyPhrasesRequest, ComprehendOperation.BatchDetectKeyPhrasesError, BatchDetectKeyPhrasesResponse, Nothing, Nothing]
  /** <p>Inspects a batch of documents and returns an inference of the prevailing sentiment,
    *         <code>POSITIVE</code>, <code>NEUTRAL</code>, <code>MIXED</code>, or <code>NEGATIVE</code>,
    *       in each one.</p>
    * @param TextList
    *   <p>A list containing the UTF-8 encoded text of the input documents. The list can contain a maximum of 25
    *         documents. The maximum size of each document is 5 KB. </p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the primary languages
    *         supported by Amazon Comprehend. All documents must be in the same language.</p>
    */
  def batchDetectSentiment(textList: List[CustomerInputString], languageCode: LanguageCode): F[BatchDetectSentimentRequest, ComprehendOperation.BatchDetectSentimentError, BatchDetectSentimentResponse, Nothing, Nothing]
  /** <p>Inspects the text of a batch of documents for the syntax and part of speech of the words
    *       in the document and returns information about them. For more information, see
    *       <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide.
    *     </p>
    * @param TextList
    *   <p>A list containing the UTF-8 encoded text of the input documents. The list can contain a maximum of 25
    *         documents. The maximum size for each document is 5 KB.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the following languages
    *         supported by Amazon Comprehend: German ("de"), English ("en"), Spanish ("es"), French ("fr"),
    *         Italian ("it"), or Portuguese ("pt"). All documents must be in the same language.</p>
    */
  def batchDetectSyntax(textList: List[CustomerInputString], languageCode: SyntaxLanguageCode): F[BatchDetectSyntaxRequest, ComprehendOperation.BatchDetectSyntaxError, BatchDetectSyntaxResponse, Nothing, Nothing]
  /** <p>Inspects a batch of documents and returns a sentiment analysis
    *       for each entity identified in the documents.</p>
    *          <p>For more information about targeted sentiment, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html">Targeted sentiment</a>.</p>
    * @param TextList
    *   <p>A list containing the UTF-8 encoded text of the input documents.
    *         The list can contain a maximum of 25 documents. The maximum size of each document is 5 KB.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. Currently, English is the only supported language.</p>
    */
  def batchDetectTargetedSentiment(textList: List[CustomerInputString], languageCode: LanguageCode): F[BatchDetectTargetedSentimentRequest, ComprehendOperation.BatchDetectTargetedSentimentError, BatchDetectTargetedSentimentResponse, Nothing, Nothing]
  /** <p>Creates a new document classification request to analyze a single document in real-time,
    *       using a previously created and trained custom model and an endpoint.</p>
    *          <p>You can input plain text or you can upload a single-page input document (text, PDF, Word, or image). </p>
    *          <p>If the system detects errors while processing a page in the input document,
    *       the API response includes an entry in <code>Errors</code> that describes the errors.</p>
    *          <p>If the system detects a document-level error in your input document, the API returns an
    *       <code>InvalidRequestException</code> error response.
    *       For details about this exception, see
    *       <a href="https://docs.aws.amazon.com/comprehend/latest/dg/idp-inputs-sync-err.html">
    *         Errors in semi-structured documents</a> in the Comprehend Developer Guide.
    *     </p>
    * @param Text
    *   <p>The document text to be analyzed. If you enter text using this parameter,
    *         do not use the <code>Bytes</code> parameter.</p>
    * @param EndpointArn
    *   <p>The Amazon Resource Number (ARN) of the endpoint. For information about endpoints, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html">Managing endpoints</a>.</p>
    * @param Bytes
    *   <p>Use the <code>Bytes</code> parameter to input a text, PDF, Word or image file.
    *         You can also use the <code>Bytes</code> parameter to input an Amazon Textract <code>DetectDocumentText</code>
    *         or <code>AnalyzeDocument</code> output file.</p>
    *            <p>Provide the input document as a sequence of base64-encoded bytes.
    *         If your code uses an Amazon Web Services SDK to classify documents, the SDK may encode
    *         the document file bytes for you. </p>
    *            <p>The maximum length of this field depends on the input document type. For details, see
    *         <a href="https://docs.aws.amazon.com/comprehend/latest/dg/idp-inputs-sync.html">
    *           Inputs for real-time custom analysis</a> in the Comprehend Developer Guide. </p>
    *            <p>If you use the <code>Bytes</code> parameter, do not use the <code>Text</code> parameter.</p>
    * @param DocumentReaderConfig
    *   <p>Provides configuration parameters to override the default actions for extracting text
    *         from PDF documents and image files.</p>
    */
  def classifyDocument(endpointArn: DocumentClassifierEndpointArn, text: Option[CustomerInputString] = None, bytes: Option[SemiStructuredDocumentBlob] = None, documentReaderConfig: Option[DocumentReaderConfig] = None): F[ClassifyDocumentRequest, ComprehendOperation.ClassifyDocumentError, ClassifyDocumentResponse, Nothing, Nothing]
  /** <p>Analyzes input text for the presence of personally identifiable information (PII) and
    *       returns the labels of identified PII entity types such as name, address, bank account number,
    *       or phone number.</p>
    * @param Text
    *   <p>A UTF-8 text string. The maximum string size is 100 KB.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. Currently, English is the only valid language.</p>
    */
  def containsPiiEntities(text: String, languageCode: LanguageCode): F[ContainsPiiEntitiesRequest, ComprehendOperation.ContainsPiiEntitiesError, ContainsPiiEntitiesResponse, Nothing, Nothing]
  /** <p>Creates a dataset to upload training or test data for a model associated with a flywheel.
    *       For more information about datasets, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html">
    *       Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>
    * @param Description
    *   <p>Description of the dataset.</p>
    * @param DatasetType
    *   <p>The dataset type. You can specify that the data in a dataset is for training
    *         the model or for testing the model.</p>
    * @param DatasetName
    *   <p>Name of the dataset.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param Tags
    *   <p>Tags for the dataset.</p>
    * @param InputDataConfig
    *   <p>Information about the input data configuration. The type of input data varies based
    *         on the format of the input and whether the data is for a classifier model or an entity recognition model.</p>
    * @param FlywheelArn
    *   <p>The Amazon Resource Number (ARN) of the flywheel of the flywheel to receive the data.</p>
    */
  def createDataset(flywheelArn: ComprehendFlywheelArn, datasetName: ComprehendArnName, inputDataConfig: DatasetInputDataConfig, datasetType: Option[DatasetType] = None, description: Option[Description] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): F[CreateDatasetRequest, ComprehendOperation.CreateDatasetError, CreateDatasetResponse, Nothing, Nothing]
  /** <p>Creates a new document classifier that you can use to categorize documents. To create a
    *       classifier, you provide a set of training documents that are labeled with the categories that you
    *       want to use. For more information, see
    *       <a href="https://docs.aws.amazon.com/comprehend/latest/dg/training-classifier-model.html">Training classifier models</a>
    *       in the Comprehend Developer Guide.
    *     </p>
    * @param VolumeKmsKeyId
    *   <p>ID for the Amazon Web Services Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    *         data on the storage volume attached to the ML compute instance(s) that process the analysis
    *         job. The VolumeKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param VersionName
    *   <p>The version name given to the newly created classifier. Version names can have a maximum
    *         of 256 characters. Alphanumeric characters, hyphens (-) and underscores (_) are allowed. The
    *         version name must be unique among all models with the same classifier name in the Amazon Web Services account/Amazon Web Services Region.</p>
    * @param ModelPolicy
    *   <p>The resource-based policy to attach to your custom document classifier model. You can use
    *         this policy to allow another Amazon Web Services account to import your custom model.</p>
    *            <p>Provide your policy as a JSON body that you enter as a UTF-8 encoded string without line
    *         breaks. To provide valid JSON, enclose the attribute names and values in double quotes. If the
    *         JSON body is also enclosed in double quotes, then you must escape the double quotes that are
    *         inside the policy:</p>
    *            <p>
    *               <code>"{\"attribute\": \"value\", \"attribute\": [\"value\"]}"</code>
    *            </p>
    *            <p>To avoid escaping quotes, you can use single quotes to enclose the policy and double
    *         quotes to enclose the JSON names and values:</p>
    *            <p>
    *               <code>'{"attribute": "value", "attribute": ["value"]}'</code>
    *            </p>
    * @param Mode
    *   <p>Indicates the mode in which the classifier will be trained. The classifier can be trained
    *         in multi-class mode, which identifies one and only one class for each document, or multi-label
    *         mode, which identifies one or more labels for each document. In multi-label mode, multiple
    *         labels for an individual document are separated by a delimiter. The default delimiter between
    *         labels is a pipe (|).</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param ModelKmsKeyId
    *   <p>ID for the KMS key that Amazon Comprehend uses to encrypt
    *         trained custom models. The ModelKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param VpcConfig
    *   <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    *         the resources you are using for your custom classifier. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    *           VPC</a>. </p>
    * @param Tags
    *   <p>Tags to associate with the document classifier. A tag is a key-value
    *         pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with
    *         "Sales" as the key might be added to a resource to indicate its use by the sales department.
    *       </p>
    * @param DocumentClassifierName
    *   <p>The name of the document classifier.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the languages
    *         supported by Amazon Comprehend. All documents must be in the same language.</p>
    * @param InputDataConfig
    *   <p>Specifies the format and location of the input data for the job.</p>
    * @param OutputDataConfig
    *   <p>Specifies the location for the output files from a custom classifier job.
    *       This parameter is required for a request that creates a native classifier model.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data.</p>
    */
  def createDocumentClassifier(documentClassifierName: ComprehendArnName, dataAccessRoleArn: IamRoleArn, inputDataConfig: DocumentClassifierInputDataConfig, languageCode: LanguageCode, versionName: Option[VersionName] = None, tags: Option[List[Tag]] = None, outputDataConfig: Option[DocumentClassifierOutputDataConfig] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, mode: Option[DocumentClassifierMode] = None, modelKmsKeyId: Option[KmsKeyId] = None, modelPolicy: Option[Policy] = None): F[CreateDocumentClassifierRequest, ComprehendOperation.CreateDocumentClassifierError, CreateDocumentClassifierResponse, Nothing, Nothing]
  /** <p>Creates a model-specific endpoint for synchronous inference for a previously trained
    *       custom model
    *       For information about endpoints, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html">Managing endpoints</a>.</p>
    * @param DesiredInferenceUnits
    *   <p> The desired number of inference units to be used by the model using this endpoint.
    *   
    *         Each inference unit represents of a throughput of 100 characters per second.</p>
    * @param ClientRequestToken
    *   <p>An idempotency token provided by the customer. If this token matches a previous endpoint
    *         creation request, Amazon Comprehend will not return a <code>ResourceInUseException</code>.
    *       </p>
    * @param ModelArn
    *   <p>The Amazon Resource Number (ARN) of the model to which the endpoint will be
    *         attached.</p>
    * @param Tags
    *   <p>Tags to associate with the endpoint. A tag is a key-value pair that adds
    *         metadata to the endpoint. For example, a tag with "Sales" as the key might be added to an
    *         endpoint to indicate its use by the sales department. </p>
    * @param EndpointName
    *   <p>This is the descriptive suffix that becomes part of the <code>EndpointArn</code> used for
    *         all subsequent requests to this resource. </p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to trained custom models encrypted with a customer
    *         managed key (ModelKmsKeyId).</p>
    * @param FlywheelArn
    *   <p>The Amazon Resource Number (ARN) of the flywheel to which the endpoint will be
    *         attached.</p>
    */
  def createEndpoint(endpointName: ComprehendEndpointName, desiredInferenceUnits: InferenceUnitsInteger, modelArn: Option[ComprehendModelArn] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None, dataAccessRoleArn: Option[IamRoleArn] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): F[CreateEndpointRequest, ComprehendOperation.CreateEndpointError, CreateEndpointResponse, Nothing, Nothing]
  /** <p>Creates an entity recognizer using submitted files. After your
    *         <code>CreateEntityRecognizer</code> request is submitted, you can check job status using the
    *         <code>DescribeEntityRecognizer</code> API. </p>
    * @param VolumeKmsKeyId
    *   <p>ID for the Amazon Web Services Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    *         data on the storage volume attached to the ML compute instance(s) that process the analysis
    *         job. The VolumeKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param RecognizerName
    *   <p>The name given to the newly created recognizer. Recognizer names can be a maximum of 256
    *         characters. Alphanumeric characters, hyphens (-) and underscores (_) are allowed. The name
    *         must be unique in the account/Region.</p>
    * @param VersionName
    *   <p>The version name given to the newly created recognizer. Version names can be a maximum of
    *         256 characters. Alphanumeric characters, hyphens (-) and underscores (_) are allowed. The
    *         version name must be unique among all models with the same recognizer name in the account/Region.</p>
    * @param ModelPolicy
    *   <p>The JSON resource-based policy to attach to your custom entity recognizer model. You can
    *         use this policy to allow another Amazon Web Services account to import your custom model.</p>
    *            <p>Provide your JSON as a UTF-8 encoded string without line breaks. To provide valid JSON for
    *         your policy, enclose the attribute names and values in double quotes. If the JSON body is also
    *         enclosed in double quotes, then you must escape the double quotes that are inside the
    *         policy:</p>
    *            <p>
    *               <code>"{\"attribute\": \"value\", \"attribute\": [\"value\"]}"</code>
    *            </p>
    *            <p>To avoid escaping quotes, you can use single quotes to enclose the policy and double
    *         quotes to enclose the JSON names and values:</p>
    *            <p>
    *               <code>'{"attribute": "value", "attribute": ["value"]}'</code>
    *            </p>
    * @param ClientRequestToken
    *   <p> A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param ModelKmsKeyId
    *   <p>ID for the KMS key that Amazon Comprehend uses to encrypt
    *         trained custom models. The ModelKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param VpcConfig
    *   <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    *         the resources you are using for your custom entity recognizer. For more information, see
    *         <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    *           VPC</a>. </p>
    * @param Tags
    *   <p>Tags to associate with the entity recognizer. A tag is a key-value pair
    *         that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with
    *         "Sales" as the key might be added to a resource to indicate its use by the sales department.
    *       </p>
    * @param LanguageCode
    *   <p> You can specify any of the following languages: English
    *         ("en"), Spanish ("es"), French ("fr"), Italian ("it"), German ("de"), or Portuguese ("pt").
    *         If you plan to use this entity recognizer with PDF, Word, or image input files, you must
    *         specify English as the language.
    *         All training documents must be in the same language.</p>
    * @param InputDataConfig
    *   <p>Specifies the format and location of the input data. The S3 bucket containing the input
    *         data must be located in the same Region as the entity recognizer being created. </p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data.</p>
    */
  def createEntityRecognizer(recognizerName: ComprehendArnName, dataAccessRoleArn: IamRoleArn, inputDataConfig: EntityRecognizerInputDataConfig, languageCode: LanguageCode, versionName: Option[VersionName] = None, tags: Option[List[Tag]] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, modelKmsKeyId: Option[KmsKeyId] = None, modelPolicy: Option[Policy] = None): F[CreateEntityRecognizerRequest, ComprehendOperation.CreateEntityRecognizerError, CreateEntityRecognizerResponse, Nothing, Nothing]
  /** <p>A flywheel is an Amazon Web Services resource that orchestrates the ongoing training of a model for custom classification
    *       or custom entity recognition. You can create a flywheel to start with an existing trained model, or
    *       Comprehend can create and train a new model.</p>
    *          <p>When you create the flywheel, Comprehend creates a data lake in your account. The data lake holds the training
    *       data and test data for all versions of the model.</p>
    *          <p>To use a flywheel with an existing trained model, you specify the active model version. Comprehend copies the model's
    *       training data and test data into the flywheel's data lake.</p>
    *          <p>To use the flywheel with a new model, you need to provide a dataset for training data (and optional test data)
    *       when you create the flywheel.</p>
    *          <p>For more information about flywheels, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html">
    *       Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>
    * @param FlywheelName
    *   <p>Name for the flywheel.</p>
    * @param TaskConfig
    *   <p>Configuration about the custom classifier associated with the flywheel.</p>
    * @param DataLakeS3Uri
    *   <p>Enter the S3 location for the data lake. You can specify a new S3 bucket or a new folder of an
    *       existing S3 bucket. The flywheel creates the data lake at this location.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param Tags
    *   <p>The tags to associate with this flywheel.</p>
    * @param ModelType
    *   <p>The model type.</p>
    * @param DataSecurityConfig
    *   <p>Data security configurations.</p>
    * @param ActiveModelArn
    *   <p>To associate an existing model with the flywheel, specify the Amazon Resource Number (ARN) of the model version.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend the permissions required to access the flywheel data in the data lake.</p>
    */
  def createFlywheel(flywheelName: ComprehendArnName, dataAccessRoleArn: IamRoleArn, dataLakeS3Uri: FlywheelS3Uri, activeModelArn: Option[ComprehendModelArn] = None, taskConfig: Option[TaskConfig] = None, modelType: Option[ModelType] = None, dataSecurityConfig: Option[DataSecurityConfig] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): F[CreateFlywheelRequest, ComprehendOperation.CreateFlywheelError, CreateFlywheelResponse, Nothing, Nothing]
  /** <p>Deletes a previously created document classifier</p>
    *          <p>Only those classifiers that are in terminated states (IN_ERROR, TRAINED) will be deleted.
    *       If an active inference job is using the model, a <code>ResourceInUseException</code> will be
    *       returned.</p>
    *          <p>This is an asynchronous action that puts the classifier into a DELETING state, and it is
    *       then removed by a background job. Once removed, the classifier disappears from your account
    *       and is no longer available for use. </p>
    * @param DocumentClassifierArn
    *   <p>The Amazon Resource Name (ARN) that identifies the document classifier. </p>
    */
  def deleteDocumentClassifier(documentClassifierArn: DocumentClassifierArn): F[DeleteDocumentClassifierRequest, ComprehendOperation.DeleteDocumentClassifierError, DeleteDocumentClassifierResponse, Nothing, Nothing]
  /** <p>Deletes a model-specific endpoint for a previously-trained custom model. All endpoints
    *       must be deleted in order for the model to be deleted.
    *       For information about endpoints, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html">Managing endpoints</a>.</p>
    * @param EndpointArn
    *   <p>The Amazon Resource Number (ARN) of the endpoint being deleted.</p>
    */
  def deleteEndpoint(endpointArn: ComprehendEndpointArn): F[DeleteEndpointRequest, ComprehendOperation.DeleteEndpointError, DeleteEndpointResponse, Nothing, Nothing]
  /** <p>Deletes an entity recognizer.</p>
    *          <p>Only those recognizers that are in terminated states (IN_ERROR, TRAINED) will be deleted.
    *       If an active inference job is using the model, a <code>ResourceInUseException</code> will be
    *       returned.</p>
    *          <p>This is an asynchronous action that puts the recognizer into a DELETING state, and it is
    *       then removed by a background job. Once removed, the recognizer disappears from your account
    *       and is no longer available for use. </p>
    * @param EntityRecognizerArn
    *   <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    */
  def deleteEntityRecognizer(entityRecognizerArn: EntityRecognizerArn): F[DeleteEntityRecognizerRequest, ComprehendOperation.DeleteEntityRecognizerError, DeleteEntityRecognizerResponse, Nothing, Nothing]
  /** <p>Deletes a flywheel. When you delete the flywheel, Amazon Comprehend
    *       does not delete the data lake or the model associated with the flywheel.</p>
    *          <p>For more information about flywheels, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html">
    *       Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>
    * @param FlywheelArn
    *   <p>The Amazon Resource Number (ARN) of the flywheel to delete.</p>
    */
  def deleteFlywheel(flywheelArn: ComprehendFlywheelArn): F[DeleteFlywheelRequest, ComprehendOperation.DeleteFlywheelError, DeleteFlywheelResponse, Nothing, Nothing]
  /** <p>Deletes a resource-based policy that is attached to a custom model.</p>
    * @param ResourceArn
    *   <p>The Amazon Resource Name (ARN) of the custom model version that has the policy to delete.</p>
    * @param PolicyRevisionId
    *   <p>The revision ID of the policy to delete.</p>
    */
  def deleteResourcePolicy(resourceArn: ComprehendModelArn, policyRevisionId: Option[PolicyRevisionId] = None): F[DeleteResourcePolicyRequest, ComprehendOperation.DeleteResourcePolicyError, DeleteResourcePolicyResponse, Nothing, Nothing]
  /** <p>Returns information about the dataset that you specify.
    *       For more information about datasets, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html">
    *       Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>
    * @param DatasetArn
    *   <p>The ARN of the dataset.</p>
    */
  def describeDataset(datasetArn: ComprehendDatasetArn): F[DescribeDatasetRequest, ComprehendOperation.DescribeDatasetError, DescribeDatasetResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with a document classification job. Use this operation to
    *       get the status of a classification job.</p>
    * @param JobId
    *   <p>The identifier that Amazon Comprehend generated for the job. The
    *         <code>StartDocumentClassificationJob</code> operation returns this identifier in its response.</p>
    */
  def describeDocumentClassificationJob(jobId: JobId): F[DescribeDocumentClassificationJobRequest, ComprehendOperation.DescribeDocumentClassificationJobError, DescribeDocumentClassificationJobResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with a document classifier.</p>
    * @param DocumentClassifierArn
    *   <p>The Amazon Resource Name (ARN) that identifies the document classifier. The
    *         <code>CreateDocumentClassifier</code> operation returns this identifier in its response.</p>
    */
  def describeDocumentClassifier(documentClassifierArn: DocumentClassifierArn): F[DescribeDocumentClassifierRequest, ComprehendOperation.DescribeDocumentClassifierError, DescribeDocumentClassifierResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with a dominant language detection job. Use this operation
    *       to get the status of a detection job.</p>
    * @param JobId
    *   <p>The identifier that Amazon Comprehend generated for the job. The
    *         <code>StartDominantLanguageDetectionJob</code> operation returns this identifier in its response.</p>
    */
  def describeDominantLanguageDetectionJob(jobId: JobId): F[DescribeDominantLanguageDetectionJobRequest, ComprehendOperation.DescribeDominantLanguageDetectionJobError, DescribeDominantLanguageDetectionJobResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with a specific endpoint. Use this operation to get the
    *       status of an endpoint.
    *       For information about endpoints, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html">Managing endpoints</a>.</p>
    * @param EndpointArn
    *   <p>The Amazon Resource Number (ARN) of the endpoint being described.</p>
    */
  def describeEndpoint(endpointArn: ComprehendEndpointArn): F[DescribeEndpointRequest, ComprehendOperation.DescribeEndpointError, DescribeEndpointResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with an entities detection job. Use this operation to get
    *       the status of a detection job.</p>
    * @param JobId
    *   <p>The identifier that Amazon Comprehend generated for the job. The
    *           <code>StartEntitiesDetectionJob</code> operation returns this identifier in its response.</p>
    */
  def describeEntitiesDetectionJob(jobId: JobId): F[DescribeEntitiesDetectionJobRequest, ComprehendOperation.DescribeEntitiesDetectionJobError, DescribeEntitiesDetectionJobResponse, Nothing, Nothing]
  /** <p>Provides details about an entity recognizer including status, S3 buckets containing
    *       training data, recognizer metadata, metrics, and so on.</p>
    * @param EntityRecognizerArn
    *   <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    */
  def describeEntityRecognizer(entityRecognizerArn: EntityRecognizerArn): F[DescribeEntityRecognizerRequest, ComprehendOperation.DescribeEntityRecognizerError, DescribeEntityRecognizerResponse, Nothing, Nothing]
  /** <p>Gets the status and details of an events detection job.</p>
    * @param JobId
    *   <p>The identifier of the events detection job.</p>
    */
  def describeEventsDetectionJob(jobId: JobId): F[DescribeEventsDetectionJobRequest, ComprehendOperation.DescribeEventsDetectionJobError, DescribeEventsDetectionJobResponse, Nothing, Nothing]
  /** <p>Provides configuration information about the flywheel. For more information about flywheels, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html">
    *       Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>
    * @param FlywheelArn
    *   <p>The Amazon Resource Number (ARN) of the flywheel.</p>
    */
  def describeFlywheel(flywheelArn: ComprehendFlywheelArn): F[DescribeFlywheelRequest, ComprehendOperation.DescribeFlywheelError, DescribeFlywheelResponse, Nothing, Nothing]
  /** <p>Retrieve the configuration properties of a flywheel iteration.
    *       For more information about flywheels, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html">
    *       Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>
    * @param FlywheelArn
    *   <p></p>
    * @param FlywheelIterationId
    *   <p></p>
    */
  def describeFlywheelIteration(flywheelArn: ComprehendFlywheelArn, flywheelIterationId: FlywheelIterationId): F[DescribeFlywheelIterationRequest, ComprehendOperation.DescribeFlywheelIterationError, DescribeFlywheelIterationResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with a key phrases detection job. Use this operation to get
    *       the status of a detection job.</p>
    * @param JobId
    *   <p>The identifier that Amazon Comprehend generated for the job. The
    *           <code>StartKeyPhrasesDetectionJob</code> operation returns this identifier in its
    *         response.</p>
    */
  def describeKeyPhrasesDetectionJob(jobId: JobId): F[DescribeKeyPhrasesDetectionJobRequest, ComprehendOperation.DescribeKeyPhrasesDetectionJobError, DescribeKeyPhrasesDetectionJobResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with a PII entities detection job. For example, you can use
    *       this operation to get the job status.</p>
    * @param JobId
    *   <p>The identifier that Amazon Comprehend generated for the job. The  operation returns this identifier in its
    *         response.</p>
    */
  def describePiiEntitiesDetectionJob(jobId: JobId): F[DescribePiiEntitiesDetectionJobRequest, ComprehendOperation.DescribePiiEntitiesDetectionJobError, DescribePiiEntitiesDetectionJobResponse, Nothing, Nothing]
  /** <p>Gets the details of a resource-based policy that is attached to a custom model, including
    *       the JSON body of the policy.</p>
    * @param ResourceArn
    *   <p>The Amazon Resource Name (ARN) of the custom model version that has the resource policy.</p>
    */
  def describeResourcePolicy(resourceArn: ComprehendModelArn): F[DescribeResourcePolicyRequest, ComprehendOperation.DescribeResourcePolicyError, DescribeResourcePolicyResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with a sentiment detection job. Use this operation to get
    *       the status of a detection job.</p>
    * @param JobId
    *   <p>The identifier that Amazon Comprehend generated for the job. The  operation returns this identifier in its
    *         response.</p>
    */
  def describeSentimentDetectionJob(jobId: JobId): F[DescribeSentimentDetectionJobRequest, ComprehendOperation.DescribeSentimentDetectionJobError, DescribeSentimentDetectionJobResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with a targeted sentiment detection job. Use this operation
    *       to get the status of the job.</p>
    * @param JobId
    *   <p>The identifier that Amazon Comprehend generated for the job. The
    *         <code>StartTargetedSentimentDetectionJob</code> operation returns this identifier in its
    *         response.</p>
    */
  def describeTargetedSentimentDetectionJob(jobId: JobId): F[DescribeTargetedSentimentDetectionJobRequest, ComprehendOperation.DescribeTargetedSentimentDetectionJobError, DescribeTargetedSentimentDetectionJobResponse, Nothing, Nothing]
  /** <p>Gets the properties associated with a topic detection job. Use this operation to get
    *       the status of a detection job.</p>
    * @param JobId
    *   <p>The identifier assigned by the user to the detection job.</p>
    */
  def describeTopicsDetectionJob(jobId: JobId): F[DescribeTopicsDetectionJobRequest, ComprehendOperation.DescribeTopicsDetectionJobError, DescribeTopicsDetectionJobResponse, Nothing, Nothing]
  /** <p>Determines the dominant language of the input text. For a list of languages that Amazon
    *       Comprehend can detect, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-languages.html">Amazon Comprehend Supported Languages</a>. </p>
    * @param Text
    *   <p>A UTF-8 text string. The string must contain at least 20 characters. The maximum string size is 100 KB.</p>
    */
  def detectDominantLanguage(text: CustomerInputString): F[DetectDominantLanguageRequest, ComprehendOperation.DetectDominantLanguageError, DetectDominantLanguageResponse, Nothing, Nothing]
  /** <p>Detects named entities in input text when you use the pre-trained model.
    *       Detects custom entities if you have a custom entity recognition model. </p>
    *          <p>
    *       When detecting named entities using the pre-trained model, use plain text as the input.
    *       For more information about named entities, see
    *       <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-entities.html">Entities</a> in the Comprehend Developer Guide.</p>
    *          <p>When you use a custom entity recognition model,
    *       you can input plain text or you can upload a single-page input document (text, PDF, Word, or image). </p>
    *          <p>If the system detects errors while processing a page in the input document, the API response
    *        includes an entry in <code>Errors</code> for each error. </p>
    *          <p>If the system detects a document-level error in your input document, the API returns an
    *        <code>InvalidRequestException</code> error response.
    *       For details about this exception, see
    *       <a href="https://docs.aws.amazon.com/comprehend/latest/dg/idp-inputs-sync-err.html">
    *         Errors in semi-structured documents</a> in the Comprehend Developer Guide.
    *     </p>
    * @param Bytes
    *   <p>This field applies only when you use a custom entity recognition model that
    *         was trained with PDF annotations. For other cases,
    *         enter your text input in the <code>Text</code> field.</p>
    *            <p>
    *         Use the <code>Bytes</code> parameter to input a text, PDF, Word or image file.
    *         Using a plain-text file in the <code>Bytes</code> parameter is equivelent to using the
    *         <code>Text</code> parameter (the <code>Entities</code> field in the response is identical).</p>
    *            <p>You can also use the <code>Bytes</code> parameter to input an Amazon Textract <code>DetectDocumentText</code>
    *         or <code>AnalyzeDocument</code> output file.</p>
    *            <p>Provide the input document as a sequence of base64-encoded bytes.
    *         If your code uses an Amazon Web Services SDK to detect entities, the SDK may encode
    *         the document file bytes for you. </p>
    *            <p>The maximum length of this field depends on the input document type. For details, see
    *         <a href="https://docs.aws.amazon.com/comprehend/latest/dg/idp-inputs-sync.html">
    *           Inputs for real-time custom analysis</a> in the Comprehend Developer Guide. </p>
    *            <p>If you use the <code>Bytes</code> parameter, do not use the <code>Text</code> parameter.</p>
    * @param EndpointArn
    *   <p>The Amazon Resource Name of an endpoint that is associated with a custom entity
    *         recognition model. Provide an endpoint if you want to detect entities by using your own custom
    *         model instead of the default model that is used by Amazon Comprehend.</p>
    *            <p>If you specify an endpoint, Amazon Comprehend uses the language of your custom model, and
    *         it ignores any language code that you provide in your request.</p>
    *            <p>For information about endpoints, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html">Managing endpoints</a>.</p>
    * @param Text
    *   <p>A UTF-8 text string. The maximum string size is 100 KB. If you enter text using this parameter,
    *       do not use the <code>Bytes</code> parameter.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the primary languages
    *         supported by Amazon Comprehend. If your request includes the endpoint for a custom entity recognition model, Amazon
    *         Comprehend uses the language of your custom model, and it ignores any language code that you
    *         specify here.</p>
    *            <p>All input documents must be in the same language.</p>
    * @param DocumentReaderConfig
    *   <p>Provides configuration parameters to override the default actions for extracting text
    *         from PDF documents and image files.</p>
    */
  def detectEntities(text: Option[CustomerInputString] = None, languageCode: Option[LanguageCode] = None, endpointArn: Option[EntityRecognizerEndpointArn] = None, bytes: Option[SemiStructuredDocumentBlob] = None, documentReaderConfig: Option[DocumentReaderConfig] = None): F[DetectEntitiesRequest, ComprehendOperation.DetectEntitiesError, DetectEntitiesResponse, Nothing, Nothing]
  /** <p>Detects the key noun phrases found in the text. </p>
    * @param Text
    *   <p>A UTF-8 text string. The string must contain less than 100 KB of UTF-8 encoded
    *         characters.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the primary languages
    *         supported by Amazon Comprehend. All documents must be in the same language.</p>
    */
  def detectKeyPhrases(text: CustomerInputString, languageCode: LanguageCode): F[DetectKeyPhrasesRequest, ComprehendOperation.DetectKeyPhrasesError, DetectKeyPhrasesResponse, Nothing, Nothing]
  /** <p>Inspects the input text for entities that contain personally identifiable information
    *       (PII) and returns information about them.</p>
    * @param Text
    *   <p>A UTF-8 text string. The maximum string size is 100 KB.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. Currently, English is the only valid language.</p>
    */
  def detectPiiEntities(text: String, languageCode: LanguageCode): F[DetectPiiEntitiesRequest, ComprehendOperation.DetectPiiEntitiesError, DetectPiiEntitiesResponse, Nothing, Nothing]
  /** <p>Inspects text and returns an inference of the prevailing sentiment
    *         (<code>POSITIVE</code>, <code>NEUTRAL</code>, <code>MIXED</code>, or <code>NEGATIVE</code>). </p>
    * @param Text
    *   <p>A UTF-8 text string. The maximum string size is 5 KB.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the primary languages
    *         supported by Amazon Comprehend. All documents must be in the same language.</p>
    */
  def detectSentiment(text: CustomerInputString, languageCode: LanguageCode): F[DetectSentimentRequest, ComprehendOperation.DetectSentimentError, DetectSentimentResponse, Nothing, Nothing]
  /** <p>Inspects text for syntax and the part of speech of words in the document. For more
    *       information, see
    *       <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide.
    *     </p>
    * @param Text
    *   <p>A UTF-8 string. The maximum string size is 5 KB.</p>
    * @param LanguageCode
    *   <p>The language code of the input documents. You can specify any of the following languages
    *         supported by Amazon Comprehend: German ("de"), English ("en"), Spanish ("es"), French ("fr"),
    *         Italian ("it"), or Portuguese ("pt").</p>
    */
  def detectSyntax(text: CustomerInputString, languageCode: SyntaxLanguageCode): F[DetectSyntaxRequest, ComprehendOperation.DetectSyntaxError, DetectSyntaxResponse, Nothing, Nothing]
  /** <p>Inspects the input text and returns a sentiment analysis for each entity identified in the text.</p>
    *          <p>For more information about targeted sentiment, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html">Targeted sentiment</a>.</p>
    * @param Text
    *   <p>A UTF-8 text string. The maximum string length is 5 KB.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. Currently, English is the only supported language.</p>
    */
  def detectTargetedSentiment(text: CustomerInputString, languageCode: LanguageCode): F[DetectTargetedSentimentRequest, ComprehendOperation.DetectTargetedSentimentError, DetectTargetedSentimentResponse, Nothing, Nothing]
  /** <p>Creates a new custom model that replicates a source custom model that you import. The
    *       source model can be in your Amazon Web Services account or another one.</p>
    *          <p>If the source model is in another Amazon Web Services account, then it must have a resource-based policy
    *       that authorizes you to import it.</p>
    *          <p>The source model must be in the same Amazon Web Services Region that you're using when you import. You
    *       can't import a model that's in a different Region.</p>
    * @param ModelName
    *   <p>The name to assign to the custom model that is created in Amazon Comprehend by this
    *         import.</p>
    * @param VersionName
    *   <p>The version name given to the custom model that is created by this import. Version names
    *         can have a maximum of 256 characters. Alphanumeric characters, hyphens (-) and underscores (_)
    *         are allowed. The version name must be unique among all models with the same classifier name in
    *         the account/Region.</p>
    * @param SourceModelArn
    *   <p>The Amazon Resource Name (ARN) of the custom model to import.</p>
    * @param ModelKmsKeyId
    *   <p>ID for the KMS key that Amazon Comprehend uses to encrypt
    *         trained custom models. The ModelKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param Tags
    *   <p>Tags to associate with the custom model that is created by this import. A tag is a
    *         key-value pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a
    *         tag with "Sales" as the key might be added to a resource to indicate its use by the sales
    *         department.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend permission to use Amazon Key Management Service (KMS) to encrypt or decrypt the custom
    *         model.</p>
    */
  def importModel(sourceModelArn: ComprehendModelArn, modelName: Option[ComprehendArnName] = None, versionName: Option[VersionName] = None, modelKmsKeyId: Option[KmsKeyId] = None, dataAccessRoleArn: Option[IamRoleArn] = None, tags: Option[List[Tag]] = None): F[ImportModelRequest, ComprehendOperation.ImportModelError, ImportModelResponse, Nothing, Nothing]
  /** <p>List the datasets that you have configured in this Region. For more information about datasets, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html">
    *       Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>
    * @param FlywheelArn
    *   <p>The Amazon Resource Number (ARN) of the flywheel.</p>
    * @param Filter
    *   <p>Filters the datasets to be returned in the response.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>Maximum number of results to return in a response. The default is 100.</p>
    */
  def listDatasets(flywheelArn: Option[ComprehendFlywheelArn] = None, filter: Option[DatasetFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListDatasetsRequest, ComprehendOperation.ListDatasetsError, ListDatasetsResponse, Nothing, Nothing]
  /** <p>Gets a list of the documentation classification jobs that you have submitted.</p>
    * @param Filter
    *   <p>Filters the jobs that are returned. You can filter jobs on their names, status, or the
    *         date and time that they were submitted. You can only set one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page. The default is 100.</p>
    */
  def listDocumentClassificationJobs(filter: Option[DocumentClassificationJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListDocumentClassificationJobsRequest, ComprehendOperation.ListDocumentClassificationJobsError, ListDocumentClassificationJobsResponse, Nothing, Nothing]
  /** <p>Gets a list of the document classifiers that you have created.</p>
    * @param Filter
    *   <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    *         and time that they were submitted. You can only set one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page. The default is 100.</p>
    */
  def listDocumentClassifiers(filter: Option[DocumentClassifierFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListDocumentClassifiersRequest, ComprehendOperation.ListDocumentClassifiersError, ListDocumentClassifiersResponse, Nothing, Nothing]
  /** <p>Gets a list of summaries of the document classifiers that you have created</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return on each page. The default is 100.</p>
    */
  def listDocumentClassifierSummaries(nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListDocumentClassifierSummariesRequest, ComprehendOperation.ListDocumentClassifierSummariesError, ListDocumentClassifierSummariesResponse, Nothing, Nothing]
  /** <p>Gets a list of the dominant language detection jobs that you have submitted.</p>
    * @param Filter
    *   <p>Filters that jobs that are returned. You can filter jobs on their name, status, or the
    *         date and time that they were submitted. You can only set one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page. The default is 100.</p>
    */
  def listDominantLanguageDetectionJobs(filter: Option[DominantLanguageDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListDominantLanguageDetectionJobsRequest, ComprehendOperation.ListDominantLanguageDetectionJobsError, ListDominantLanguageDetectionJobsResponse, Nothing, Nothing]
  /** <p>Gets a list of all existing endpoints that you've created.
    *       For information about endpoints, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html">Managing endpoints</a>.</p>
    * @param Filter
    *   <p>Filters the endpoints that are returned. You can filter endpoints on their name, model,
    *         status, or the date and time that they were created. You can only set one filter at a time.
    *       </p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page. The default is 100.</p>
    */
  def listEndpoints(filter: Option[EndpointFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListEndpointsRequest, ComprehendOperation.ListEndpointsError, ListEndpointsResponse, Nothing, Nothing]
  /** <p>Gets a list of the entity detection jobs that you have submitted.</p>
    * @param Filter
    *   <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    *         and time that they were submitted. You can only set one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page. The default is 100.</p>
    */
  def listEntitiesDetectionJobs(filter: Option[EntitiesDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListEntitiesDetectionJobsRequest, ComprehendOperation.ListEntitiesDetectionJobsError, ListEntitiesDetectionJobsResponse, Nothing, Nothing]
  /** <p>Gets a list of the properties of all entity recognizers that you created, including
    *       recognizers currently in training. Allows you to filter the list of recognizers based on
    *       criteria such as status and submission time. This call returns up to 500 entity recognizers in
    *       the list, with a default number of 100 recognizers in the list.</p>
    *          <p>The results of this list are not in any particular order. Please get the list and sort
    *       locally if needed.</p>
    * @param Filter
    *   <p>Filters the list of entities returned. You can filter on <code>Status</code>,
    *           <code>SubmitTimeBefore</code>, or <code>SubmitTimeAfter</code>. You can only set one filter
    *         at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p> The maximum number of results to return on each page. The default is 100.</p>
    */
  def listEntityRecognizers(filter: Option[EntityRecognizerFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListEntityRecognizersRequest, ComprehendOperation.ListEntityRecognizersError, ListEntityRecognizersResponse, Nothing, Nothing]
  /** <p>Gets a list of summaries for the entity recognizers that you have created.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return on each page. The default is 100.</p>
    */
  def listEntityRecognizerSummaries(nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListEntityRecognizerSummariesRequest, ComprehendOperation.ListEntityRecognizerSummariesError, ListEntityRecognizerSummariesResponse, Nothing, Nothing]
  /** <p>Gets a list of the events detection jobs that you have submitted.</p>
    * @param Filter
    *   <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    *         and time that they were submitted. You can only set one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page.</p>
    */
  def listEventsDetectionJobs(filter: Option[EventsDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListEventsDetectionJobsRequest, ComprehendOperation.ListEventsDetectionJobsError, ListEventsDetectionJobsResponse, Nothing, Nothing]
  /** <p>Information about the history of a flywheel iteration.
    *       For more information about flywheels, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html">
    *       Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>
    * @param FlywheelArn
    *   <p>The ARN of the flywheel.</p>
    * @param Filter
    *   <p>Filter the flywheel iteration history based on creation time.</p>
    * @param NextToken
    *   <p>Next token</p>
    * @param MaxResults
    *   <p>Maximum number of iteration history results to return</p>
    */
  def listFlywheelIterationHistory(flywheelArn: ComprehendFlywheelArn, filter: Option[FlywheelIterationFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListFlywheelIterationHistoryRequest, ComprehendOperation.ListFlywheelIterationHistoryError, ListFlywheelIterationHistoryResponse, Nothing, Nothing]
  /** <p>Gets a list of the flywheels that you have created.</p>
    * @param Filter
    *   <p>Filters the flywheels that are returned. You can filter flywheels on their status,
    *         or the date and time that they were submitted. You can only set one filter at a time.
    *       </p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>Maximum number of results to return in a response. The default is 100.</p>
    */
  def listFlywheels(filter: Option[FlywheelFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListFlywheelsRequest, ComprehendOperation.ListFlywheelsError, ListFlywheelsResponse, Nothing, Nothing]
  /** <p>Get a list of key phrase detection jobs that you have submitted.</p>
    * @param Filter
    *   <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    *         and time that they were submitted. You can only set one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page. The default is 100.</p>
    */
  def listKeyPhrasesDetectionJobs(filter: Option[KeyPhrasesDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListKeyPhrasesDetectionJobsRequest, ComprehendOperation.ListKeyPhrasesDetectionJobsError, ListKeyPhrasesDetectionJobsResponse, Nothing, Nothing]
  /** <p>Gets a list of the PII entity detection jobs that you have submitted.</p>
    * @param Filter
    *   <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    *         and time that they were submitted. You can only set one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page.</p>
    */
  def listPiiEntitiesDetectionJobs(filter: Option[PiiEntitiesDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListPiiEntitiesDetectionJobsRequest, ComprehendOperation.ListPiiEntitiesDetectionJobsError, ListPiiEntitiesDetectionJobsResponse, Nothing, Nothing]
  /** <p>Gets a list of sentiment detection jobs that you have submitted.</p>
    * @param Filter
    *   <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    *         and time that they were submitted. You can only set one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page. The default is 100.</p>
    */
  def listSentimentDetectionJobs(filter: Option[SentimentDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListSentimentDetectionJobsRequest, ComprehendOperation.ListSentimentDetectionJobsError, ListSentimentDetectionJobsResponse, Nothing, Nothing]
  /** <p>Lists all tags associated with a given Amazon Comprehend resource. </p>
    * @param ResourceArn
    *   <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource you are querying.
    *       </p>
    */
  def listTagsForResource(resourceArn: ComprehendArn): F[ListTagsForResourceRequest, ComprehendOperation.ListTagsForResourceError, ListTagsForResourceResponse, Nothing, Nothing]
  /** <p>Gets a list of targeted sentiment detection jobs that you have submitted.</p>
    * @param Filter
    *   <p>Filters the jobs that are returned. You can filter jobs on their name, status, or the date
    *         and time that they were submitted. You can only set one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page. The default is 100.</p>
    */
  def listTargetedSentimentDetectionJobs(filter: Option[TargetedSentimentDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListTargetedSentimentDetectionJobsRequest, ComprehendOperation.ListTargetedSentimentDetectionJobsError, ListTargetedSentimentDetectionJobsResponse, Nothing, Nothing]
  /** <p>Gets a list of the topic detection jobs that you have submitted.</p>
    * @param Filter
    *   <p>Filters the jobs that are returned. Jobs can be filtered on their name, status, or the
    *         date and time that they were submitted. You can set only one filter at a time.</p>
    * @param NextToken
    *   <p>Identifies the next page of results to return.</p>
    * @param MaxResults
    *   <p>The maximum number of results to return in each page. The default is 100.</p>
    */
  def listTopicsDetectionJobs(filter: Option[TopicsDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): F[ListTopicsDetectionJobsRequest, ComprehendOperation.ListTopicsDetectionJobsError, ListTopicsDetectionJobsResponse, Nothing, Nothing]
  /** <p>Attaches a resource-based policy to a custom model. You can use this policy to authorize
    *       an entity in another Amazon Web Services account to import the custom model, which replicates it in Amazon
    *       Comprehend in their account.</p>
    * @param ResourceArn
    *   <p>The Amazon Resource Name (ARN) of the custom model to attach the policy to.</p>
    * @param ResourcePolicy
    *   <p>The JSON resource-based policy to attach to your custom model. Provide your JSON as a
    *         UTF-8 encoded string without line breaks. To provide valid JSON for your policy, enclose the
    *         attribute names and values in double quotes. If the JSON body is also enclosed in double
    *         quotes, then you must escape the double quotes that are inside the policy:</p>
    *            <p>
    *               <code>"{\"attribute\": \"value\", \"attribute\": [\"value\"]}"</code>
    *            </p>
    *            <p>To avoid escaping quotes, you can use single quotes to enclose the policy and double
    *         quotes to enclose the JSON names and values:</p>
    *            <p>
    *               <code>'{"attribute": "value", "attribute": ["value"]}'</code>
    *            </p>
    * @param PolicyRevisionId
    *   <p>The revision ID that Amazon Comprehend assigned to the policy that you are updating. If
    *         you are creating a new policy that has no prior version, don't use this parameter. Amazon
    *         Comprehend creates the revision ID for you.</p>
    */
  def putResourcePolicy(resourceArn: ComprehendModelArn, resourcePolicy: Policy, policyRevisionId: Option[PolicyRevisionId] = None): F[PutResourcePolicyRequest, ComprehendOperation.PutResourcePolicyError, PutResourcePolicyResponse, Nothing, Nothing]
  /** <p>Starts an asynchronous document classification job. Use the
    *       <code>DescribeDocumentClassificationJob</code>
    *           operation to track the progress of the job.</p>
    * @param VolumeKmsKeyId
    *   <p>ID for the Amazon Web Services Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    *         data on the storage volume attached to the ML compute instance(s) that process the analysis
    *         job. The VolumeKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param JobName
    *   <p>The identifier of the job.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you do not set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param VpcConfig
    *   <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    *         the resources you are using for your document classification job. For more information, see
    *         <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    *           VPC</a>. </p>
    * @param Tags
    *   <p>Tags to associate with the document classification job. A tag is a key-value pair that
    *         adds metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the
    *         key might be added to a resource to indicate its use by the sales department.</p>
    * @param InputDataConfig
    *   <p>Specifies the format and location of the input data for the job.</p>
    * @param DocumentClassifierArn
    *   <p>The Amazon Resource Name (ARN) of the document classifier to use to process the
    *         job.</p>
    * @param OutputDataConfig
    *   <p>Specifies where to send the output files.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data.</p>
    * @param FlywheelArn
    *   <p>The Amazon Resource Number (ARN) of the flywheel associated with the model to use.</p>
    */
  def startDocumentClassificationJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, jobName: Option[JobName] = None, documentClassifierArn: Option[DocumentClassifierArn] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): F[StartDocumentClassificationJobRequest, ComprehendOperation.StartDocumentClassificationJobError, StartDocumentClassificationJobResponse, Nothing, Nothing]
  /** <p>Starts an asynchronous dominant language detection job for a collection of documents. Use
    *       the  operation to track the status
    *       of a job.</p>
    * @param VolumeKmsKeyId
    *   <p>ID for the Amazon Web Services Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    *         data on the storage volume attached to the ML compute instance(s) that process the analysis
    *         job. The VolumeKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param JobName
    *   <p>An identifier for the job.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you do not set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param VpcConfig
    *   <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    *         the resources you are using for your dominant language detection job. For more information,
    *         see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    * @param Tags
    *   <p>Tags to associate with the dominant language detection job. A tag is a key-value pair
    *         that adds metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as
    *         the key might be added to a resource to indicate its use by the sales department.</p>
    * @param InputDataConfig
    *   <p>Specifies the format and location of the input data for the job.</p>
    * @param OutputDataConfig
    *   <p>Specifies where to send the output files.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/security_iam_id-based-policy-examples.html#auth-role-permissions">Role-based permissions</a>.</p>
    */
  def startDominantLanguageDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): F[StartDominantLanguageDetectionJobRequest, ComprehendOperation.StartDominantLanguageDetectionJobError, StartDominantLanguageDetectionJobResponse, Nothing, Nothing]
  /** <p>Starts an asynchronous entity detection job for a collection of documents. Use the  operation to track the status of a job.</p>
    *          <p>This API can be used for either standard entity detection or custom entity recognition. In
    *       order to be used for custom entity recognition, the optional <code>EntityRecognizerArn</code>
    *       must be used in order to provide access to the recognizer being used to detect the custom
    *       entity.</p>
    * @param VolumeKmsKeyId
    *   <p>ID for the Amazon Web Services Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    *         data on the storage volume attached to the ML compute instance(s) that process the analysis
    *         job. The VolumeKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param JobName
    *   <p>The identifier of the job.</p>
    * @param EntityRecognizerArn
    *   <p>The Amazon Resource Name (ARN) that identifies the specific entity recognizer to be used
    *         by the <code>StartEntitiesDetectionJob</code>. This ARN is optional and is only used for a
    *         custom entity recognition job.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param VpcConfig
    *   <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    *         the resources you are using for your entity detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    *           VPC</a>. </p>
    * @param Tags
    *   <p>Tags to associate with the entities detection job. A tag is a key-value pair that adds
    *         metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the key
    *         might be added to a resource to indicate its use by the sales department.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. All documents must be in the same language. You can
    *         specify any of the languages supported by Amazon Comprehend. If custom entities recognition is
    *         used, this parameter is ignored and the language used for training the model is used
    *         instead.</p>
    * @param InputDataConfig
    *   <p>Specifies the format and location of the input data for the job.</p>
    * @param OutputDataConfig
    *   <p>Specifies where to send the output files.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/security_iam_id-based-policy-examples.html#auth-role-permissions">Role-based permissions</a>.</p>
    * @param FlywheelArn
    *   <p>The Amazon Resource Number (ARN) of the flywheel associated with the model to use.</p>
    */
  def startEntitiesDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, entityRecognizerArn: Option[EntityRecognizerArn] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): F[StartEntitiesDetectionJobRequest, ComprehendOperation.StartEntitiesDetectionJobError, StartEntitiesDetectionJobResponse, Nothing, Nothing]
  /** <p>Starts an asynchronous event detection job for a collection of documents.</p>
    * @param JobName
    *   <p>The identifier of the events detection job.</p>
    * @param TargetEventTypes
    *   <p>The types of events to detect in the input documents.</p>
    * @param ClientRequestToken
    *   <p>An unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param Tags
    *   <p>Tags to associate with the events detection job. A tag is a key-value pair that adds
    *         metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the key
    *         might be added to a resource to indicate its use by the sales department.</p>
    * @param LanguageCode
    *   <p>The language code of the input documents.</p>
    * @param InputDataConfig
    *   <p>Specifies the format and location of the input data for the job.</p>
    * @param OutputDataConfig
    *   <p>Specifies where to send the output files.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data.</p>
    */
  def startEventsDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, targetEventTypes: List[EventTypeString], jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): F[StartEventsDetectionJobRequest, ComprehendOperation.StartEventsDetectionJobError, StartEventsDetectionJobResponse, Nothing, Nothing]
  /** <p>Start the flywheel iteration.This operation uses any new datasets to train a new model version.
    *       For more information about flywheels, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html">
    *       Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>
    * @param FlywheelArn
    *   <p>The ARN of the flywheel.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    */
  def startFlywheelIteration(flywheelArn: ComprehendFlywheelArn, clientRequestToken: Option[ClientRequestTokenString] = None): F[StartFlywheelIterationRequest, ComprehendOperation.StartFlywheelIterationError, StartFlywheelIterationResponse, Nothing, Nothing]
  /** <p>Starts an asynchronous key phrase detection job for a collection of documents. Use the
    *          operation to track the status of a
    *       job.</p>
    * @param VolumeKmsKeyId
    *   <p>ID for the Amazon Web Services Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    *         data on the storage volume attached to the ML compute instance(s) that process the analysis
    *         job. The VolumeKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param JobName
    *   <p>The identifier of the job.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param VpcConfig
    *   <p> Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    *         the resources you are using for your key phrases detection job. For more information, see
    *         <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    *           VPC</a>. </p>
    * @param Tags
    *   <p>Tags to associate with the key phrases detection job. A tag is a key-value pair that
    *         adds metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the
    *         key might be added to a resource to indicate its use by the sales department.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the primary languages
    *         supported by Amazon Comprehend. All documents must be in the same language.</p>
    * @param InputDataConfig
    *   <p>Specifies the format and location of the input data for the job.</p>
    * @param OutputDataConfig
    *   <p>Specifies where to send the output files.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/security_iam_id-based-policy-examples.html#auth-role-permissions">Role-based permissions</a>.</p>
    */
  def startKeyPhrasesDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): F[StartKeyPhrasesDetectionJobRequest, ComprehendOperation.StartKeyPhrasesDetectionJobError, StartKeyPhrasesDetectionJobResponse, Nothing, Nothing]
  /** <p>Starts an asynchronous PII entity detection job for a collection of documents.</p>
    * @param JobName
    *   <p>The identifier of the job.</p>
    * @param RedactionConfig
    *   <p>Provides configuration parameters for PII entity redaction.</p>
    *            <p>This parameter is required if you set the <code>Mode</code> parameter to
    *           <code>ONLY_REDACTION</code>. In that case, you must provide a <code>RedactionConfig</code>
    *         definition that includes the <code>PiiEntityTypes</code> parameter.</p>
    * @param Mode
    *   <p>Specifies whether the output provides the locations (offsets) of PII entities or a file in
    *         which PII entities are redacted.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param Tags
    *   <p>Tags to associate with the PII entities detection job. A tag is a key-value pair that
    *         adds metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the
    *         key might be added to a resource to indicate its use by the sales department.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. Currently, English is the only valid language.</p>
    * @param InputDataConfig
    *   <p>The input properties for a PII entities detection job.</p>
    * @param OutputDataConfig
    *   <p>Provides conﬁguration parameters for the output of PII entity detection jobs.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data.</p>
    */
  def startPiiEntitiesDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, mode: PiiEntitiesDetectionMode, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, redactionConfig: Option[RedactionConfig] = None, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): F[StartPiiEntitiesDetectionJobRequest, ComprehendOperation.StartPiiEntitiesDetectionJobError, StartPiiEntitiesDetectionJobResponse, Nothing, Nothing]
  /** <p>Starts an asynchronous sentiment detection job for a collection of documents. Use the
    *          operation to track the status of a
    *       job.</p>
    * @param VolumeKmsKeyId
    *   <p>ID for the Amazon Web Services Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    *         data on the storage volume attached to the ML compute instance(s) that process the analysis
    *         job. The VolumeKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param JobName
    *   <p>The identifier of the job.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param VpcConfig
    *   <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    *         the resources you are using for your sentiment detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    *           VPC</a>. </p>
    * @param Tags
    *   <p>Tags to associate with the sentiment detection job. A tag is a key-value pair that
    *         adds metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the
    *         key might be added to a resource to indicate its use by the sales department.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. You can specify any of the primary languages
    *         supported by Amazon Comprehend. All documents must be in the same language.</p>
    * @param InputDataConfig
    *   <p>Specifies the format and location of the input data for the job.</p>
    * @param OutputDataConfig
    *   <p>Specifies where to send the output files. </p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/security_iam_id-based-policy-examples.html#auth-role-permissions">Role-based permissions</a>.</p>
    */
  def startSentimentDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): F[StartSentimentDetectionJobRequest, ComprehendOperation.StartSentimentDetectionJobError, StartSentimentDetectionJobResponse, Nothing, Nothing]
  /** <p>Starts an asynchronous targeted sentiment detection job for a collection of documents. Use the
    *       <code>DescribeTargetedSentimentDetectionJob</code> operation to track the status of a
    *       job.</p>
    * @param VolumeKmsKeyId
    *   <p>ID for the KMS key that Amazon Comprehend uses to encrypt
    *         data on the storage volume attached to the ML compute instance(s) that process the analysis
    *         job. The VolumeKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *             <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param JobName
    *   <p>The identifier of the job.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you don't set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param VpcConfig
    *   <p> Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    *         the resources you are using for the job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    *           VPC</a>. </p>
    * @param Tags
    *   <p>Tags to associate with the targeted sentiment detection job. A tag is a key-value pair that
    *         adds metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the
    *         key might be added to a resource to indicate its use by the sales department.</p>
    * @param LanguageCode
    *   <p>The language of the input documents. Currently, English is the only supported language.</p>
    * @param InputDataConfig
    *   <p>The input properties for an inference job. The document reader config field applies
    *         only to non-text inputs for custom analysis.</p>
    * @param OutputDataConfig
    *   <p>Specifies where to send the output files. </p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions.html#auth-role-permissions">Role-based permissions</a>.</p>
    */
  def startTargetedSentimentDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): F[StartTargetedSentimentDetectionJobRequest, ComprehendOperation.StartTargetedSentimentDetectionJobError, StartTargetedSentimentDetectionJobResponse, Nothing, Nothing]
  /** <p>Starts an asynchronous topic detection job. Use the
    *         <code>DescribeTopicDetectionJob</code> operation to track the status of a job.</p>
    * @param VolumeKmsKeyId
    *   <p>ID for the Amazon Web Services Key Management Service (KMS) key that Amazon Comprehend uses to encrypt
    *         data on the storage volume attached to the ML compute instance(s) that process the analysis
    *         job. The VolumeKmsKeyId can be either of the following formats:</p>
    *            <ul>
    *               <li>
    *                  <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *               <li>
    *                  <p>Amazon Resource Name (ARN) of a KMS Key:
    *               <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code>
    *                  </p>
    *               </li>
    *            </ul>
    * @param NumberOfTopics
    *   <p>The number of topics to detect.</p>
    * @param JobName
    *   <p>The identifier of the job.</p>
    * @param ClientRequestToken
    *   <p>A unique identifier for the request. If you do not set the client request token, Amazon
    *         Comprehend generates one.</p>
    * @param VpcConfig
    *   <p>Configuration parameters for an optional private Virtual Private Cloud (VPC) containing
    *         the resources you are using for your topic detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon
    *           VPC</a>. </p>
    * @param Tags
    *   <p>Tags to associate with the topics detection job. A tag is a key-value pair that adds
    *         metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the key
    *         might be added to a resource to indicate its use by the sales department.</p>
    * @param InputDataConfig
    *   <p>Specifies the format and location of the input data for the job.</p>
    * @param OutputDataConfig
    *   <p>Specifies where to send the output files. The output is a compressed archive with two
    *         files, <code>topic-terms.csv</code> that lists the terms associated with each topic, and
    *           <code>doc-topics.csv</code> that lists the documents associated with each topic</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend read access to your input data. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/security_iam_id-based-policy-examples.html#auth-role-permissions">Role-based permissions</a>.</p>
    */
  def startTopicsDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, jobName: Option[JobName] = None, numberOfTopics: Option[NumberOfTopicsInteger] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): F[StartTopicsDetectionJobRequest, ComprehendOperation.StartTopicsDetectionJobError, StartTopicsDetectionJobResponse, Nothing, Nothing]
  /** <p>Stops a dominant language detection job in progress.</p>
    *          <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put
    *       into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it
    *       is put into the <code>COMPLETED</code> state; otherwise the job is stopped and put into the
    *         <code>STOPPED</code> state.</p>
    *          <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the
    *         <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400
    *       Internal Request Exception. </p>
    *          <p>When a job is stopped, any documents already processed are written to the output
    *       location.</p>
    * @param JobId
    *   <p>The identifier of the dominant language detection job to stop.</p>
    */
  def stopDominantLanguageDetectionJob(jobId: JobId): F[StopDominantLanguageDetectionJobRequest, ComprehendOperation.StopDominantLanguageDetectionJobError, StopDominantLanguageDetectionJobResponse, Nothing, Nothing]
  /** <p>Stops an entities detection job in progress.</p>
    *          <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put
    *       into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it
    *       is put into the <code>COMPLETED</code> state; otherwise the job is stopped and put into the
    *         <code>STOPPED</code> state.</p>
    *          <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the
    *         <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400
    *       Internal Request Exception. </p>
    *          <p>When a job is stopped, any documents already processed are written to the output
    *       location.</p>
    * @param JobId
    *   <p>The identifier of the entities detection job to stop.</p>
    */
  def stopEntitiesDetectionJob(jobId: JobId): F[StopEntitiesDetectionJobRequest, ComprehendOperation.StopEntitiesDetectionJobError, StopEntitiesDetectionJobResponse, Nothing, Nothing]
  /** <p>Stops an events detection job in progress.</p>
    * @param JobId
    *   <p>The identifier of the events detection job to stop.</p>
    */
  def stopEventsDetectionJob(jobId: JobId): F[StopEventsDetectionJobRequest, ComprehendOperation.StopEventsDetectionJobError, StopEventsDetectionJobResponse, Nothing, Nothing]
  /** <p>Stops a key phrases detection job in progress.</p>
    *          <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put
    *       into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it
    *       is put into the <code>COMPLETED</code> state; otherwise the job is stopped and put into the
    *         <code>STOPPED</code> state.</p>
    *          <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the
    *         <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400
    *       Internal Request Exception. </p>
    *          <p>When a job is stopped, any documents already processed are written to the output
    *       location.</p>
    * @param JobId
    *   <p>The identifier of the key phrases detection job to stop.</p>
    */
  def stopKeyPhrasesDetectionJob(jobId: JobId): F[StopKeyPhrasesDetectionJobRequest, ComprehendOperation.StopKeyPhrasesDetectionJobError, StopKeyPhrasesDetectionJobResponse, Nothing, Nothing]
  /** <p>Stops a PII entities detection job in progress.</p>
    * @param JobId
    *   <p>The identifier of the PII entities detection job to stop.</p>
    */
  def stopPiiEntitiesDetectionJob(jobId: JobId): F[StopPiiEntitiesDetectionJobRequest, ComprehendOperation.StopPiiEntitiesDetectionJobError, StopPiiEntitiesDetectionJobResponse, Nothing, Nothing]
  /** <p>Stops a sentiment detection job in progress.</p>
    *          <p>If the job state is <code>IN_PROGRESS</code>, the job is marked for termination and put
    *       into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it
    *       is put into the <code>COMPLETED</code> state; otherwise the job is be stopped and put into the
    *         <code>STOPPED</code> state.</p>
    *          <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the
    *         <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400
    *       Internal Request Exception. </p>
    *          <p>When a job is stopped, any documents already processed are written to the output
    *       location.</p>
    * @param JobId
    *   <p>The identifier of the sentiment detection job to stop.</p>
    */
  def stopSentimentDetectionJob(jobId: JobId): F[StopSentimentDetectionJobRequest, ComprehendOperation.StopSentimentDetectionJobError, StopSentimentDetectionJobResponse, Nothing, Nothing]
  /** <p>Stops a targeted sentiment detection job in progress.</p>
    *          <p>If the job state is <code>IN_PROGRESS</code>, the job is marked for termination and put
    *       into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it
    *       is put into the <code>COMPLETED</code> state; otherwise the job is be stopped and put into the
    *       <code>STOPPED</code> state.</p>
    *          <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the
    *       <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400
    *       Internal Request Exception. </p>
    *          <p>When a job is stopped, any documents already processed are written to the output
    *       location.</p>
    * @param JobId
    *   <p>The identifier of the targeted sentiment detection job to stop.</p>
    */
  def stopTargetedSentimentDetectionJob(jobId: JobId): F[StopTargetedSentimentDetectionJobRequest, ComprehendOperation.StopTargetedSentimentDetectionJobError, StopTargetedSentimentDetectionJobResponse, Nothing, Nothing]
  /** <p>Stops a document classifier training job while in progress.</p>
    *          <p>If the training job state is <code>TRAINING</code>, the job is marked for termination and
    *       put into the <code>STOP_REQUESTED</code> state. If the training job completes before it can be
    *       stopped, it is put into the <code>TRAINED</code>; otherwise the training job is stopped and
    *       put into the <code>STOPPED</code> state and the service sends back an HTTP 200 response with
    *       an empty HTTP body. </p>
    * @param DocumentClassifierArn
    *   <p>The Amazon Resource Name (ARN) that identifies the document classifier currently being
    *         trained.</p>
    */
  def stopTrainingDocumentClassifier(documentClassifierArn: DocumentClassifierArn): F[StopTrainingDocumentClassifierRequest, ComprehendOperation.StopTrainingDocumentClassifierError, StopTrainingDocumentClassifierResponse, Nothing, Nothing]
  /** <p>Stops an entity recognizer training job while in progress.</p>
    *          <p>If the training job state is <code>TRAINING</code>, the job is marked for termination and
    *       put into the <code>STOP_REQUESTED</code> state. If the training job completes before it can be
    *       stopped, it is put into the <code>TRAINED</code>; otherwise the training job is stopped and
    *       putted into the <code>STOPPED</code> state and the service sends back an HTTP 200 response
    *       with an empty HTTP body.</p>
    * @param EntityRecognizerArn
    *   <p>The Amazon Resource Name (ARN) that identifies the entity recognizer currently being
    *         trained.</p>
    */
  def stopTrainingEntityRecognizer(entityRecognizerArn: EntityRecognizerArn): F[StopTrainingEntityRecognizerRequest, ComprehendOperation.StopTrainingEntityRecognizerError, StopTrainingEntityRecognizerResponse, Nothing, Nothing]
  /** <p>Associates a specific tag with an Amazon Comprehend resource. A tag is a key-value pair
    *       that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with
    *       "Sales" as the key might be added to a resource to indicate its use by the sales department.
    *     </p>
    * @param ResourceArn
    *   <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource to which you want
    *         to associate the tags. </p>
    * @param Tags
    *   <p>Tags being associated with a specific Amazon Comprehend resource. There can be a maximum
    *         of 50 tags (both existing and pending) associated with a specific resource. </p>
    */
  def tagResource(resourceArn: ComprehendArn, tags: List[Tag]): F[TagResourceRequest, ComprehendOperation.TagResourceError, TagResourceResponse, Nothing, Nothing]
  /** <p>Removes a specific tag associated with an Amazon Comprehend resource. </p>
    * @param ResourceArn
    *   <p> The Amazon Resource Name (ARN) of the given Amazon Comprehend resource from which you
    *         want to remove the tags. </p>
    * @param TagKeys
    *   <p>The initial part of a key-value pair that forms a tag being removed from a given resource.
    *         For example, a tag with "Sales" as the key might be added to a resource to indicate its use by
    *         the sales department. Keys must be unique and cannot be duplicated for a particular resource.
    *       </p>
    */
  def untagResource(resourceArn: ComprehendArn, tagKeys: List[TagKey]): F[UntagResourceRequest, ComprehendOperation.UntagResourceError, UntagResourceResponse, Nothing, Nothing]
  /** <p>Updates information about the specified endpoint.
    *       For information about endpoints, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html">Managing endpoints</a>.</p>
    * @param DesiredInferenceUnits
    *   <p> The desired number of inference units to be used by the model using this endpoint.
    *   
    *         Each inference unit represents of a throughput of 100 characters per second.</p>
    * @param EndpointArn
    *   <p>The Amazon Resource Number (ARN) of the endpoint being updated.</p>
    * @param DesiredModelArn
    *   <p>The ARN of the new model to use when updating an existing endpoint.</p>
    * @param DesiredDataAccessRoleArn
    *   <p>Data access role ARN to use in case the new model is encrypted with a customer CMK.</p>
    * @param FlywheelArn
    *   <p>The Amazon Resource Number (ARN) of the flywheel</p>
    */
  def updateEndpoint(endpointArn: ComprehendEndpointArn, desiredModelArn: Option[ComprehendModelArn] = None, desiredInferenceUnits: Option[InferenceUnitsInteger] = None, desiredDataAccessRoleArn: Option[IamRoleArn] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): F[UpdateEndpointRequest, ComprehendOperation.UpdateEndpointError, UpdateEndpointResponse, Nothing, Nothing]
  /** <p>Update the configuration information for an existing flywheel.</p>
    * @param FlywheelArn
    *   <p>The Amazon Resource Number (ARN) of the flywheel to update.</p>
    * @param ActiveModelArn
    *   <p>The Amazon Resource Number (ARN) of the active model version.</p>
    * @param DataAccessRoleArn
    *   <p>The Amazon Resource Name (ARN) of the IAM role that
    *         grants Amazon Comprehend permission to access the flywheel data.</p>
    * @param DataSecurityConfig
    *   <p>Flywheel data security configuration.</p>
    */
  def updateFlywheel(flywheelArn: ComprehendFlywheelArn, activeModelArn: Option[ComprehendModelArn] = None, dataAccessRoleArn: Option[IamRoleArn] = None, dataSecurityConfig: Option[UpdateDataSecurityConfig] = None): F[UpdateFlywheelRequest, ComprehendOperation.UpdateFlywheelError, UpdateFlywheelResponse, Nothing, Nothing]

  def transform: Transformation.PartiallyApplied[ComprehendGen[F]] = Transformation.of[ComprehendGen[F]](this)
}

object ComprehendGen extends Service.Mixin[ComprehendGen, ComprehendOperation] {

  val id: ShapeId = ShapeId("com.amazonaws.comprehend", "Comprehend_20171127")
  val version: String = "2017-11-27"

  val hints: Hints = Hints(
    aws.auth.Sigv4(name = "comprehend"),
    smithy.api.Title("Amazon Comprehend"),
    aws.protocols.AwsJson1_1(http = None, eventStreamHttp = None),
    smithy.api.Documentation("<p>Amazon Comprehend is an Amazon Web Services service for gaining insight into the content of documents.\n      Use these actions to determine the topics contained in your documents, the topics they\n      discuss, the predominant sentiment expressed in them, the predominant language used, and\n      more.</p>"),
    aws.api.Service(sdkId = "Comprehend", arnNamespace = Some(aws.api.ArnNamespace("comprehend")), cloudFormationName = Some(aws.api.CloudFormationName("Comprehend")), cloudTrailEventSource = Some("comprehend.amazonaws.com"), docId = None, endpointPrefix = Some("comprehend")),
  ).lazily

  def apply[F[_]](implicit F: Impl[F]): F.type = F

  object ErrorAware {
    def apply[F[_, _]](implicit F: ErrorAware[F]): F.type = F
    type Default[F[+_, +_]] = Constant[smithy4s.kinds.stubs.Kind2[F]#toKind5]
  }

  val endpoints: Vector[smithy4s.Endpoint[ComprehendOperation, ?, ?, ?, ?, ?]] = Vector(
    ComprehendOperation.BatchDetectDominantLanguage,
    ComprehendOperation.BatchDetectEntities,
    ComprehendOperation.BatchDetectKeyPhrases,
    ComprehendOperation.BatchDetectSentiment,
    ComprehendOperation.BatchDetectSyntax,
    ComprehendOperation.BatchDetectTargetedSentiment,
    ComprehendOperation.ClassifyDocument,
    ComprehendOperation.ContainsPiiEntities,
    ComprehendOperation.CreateDataset,
    ComprehendOperation.CreateDocumentClassifier,
    ComprehendOperation.CreateEndpoint,
    ComprehendOperation.CreateEntityRecognizer,
    ComprehendOperation.CreateFlywheel,
    ComprehendOperation.DeleteDocumentClassifier,
    ComprehendOperation.DeleteEndpoint,
    ComprehendOperation.DeleteEntityRecognizer,
    ComprehendOperation.DeleteFlywheel,
    ComprehendOperation.DeleteResourcePolicy,
    ComprehendOperation.DescribeDataset,
    ComprehendOperation.DescribeDocumentClassificationJob,
    ComprehendOperation.DescribeDocumentClassifier,
    ComprehendOperation.DescribeDominantLanguageDetectionJob,
    ComprehendOperation.DescribeEndpoint,
    ComprehendOperation.DescribeEntitiesDetectionJob,
    ComprehendOperation.DescribeEntityRecognizer,
    ComprehendOperation.DescribeEventsDetectionJob,
    ComprehendOperation.DescribeFlywheel,
    ComprehendOperation.DescribeFlywheelIteration,
    ComprehendOperation.DescribeKeyPhrasesDetectionJob,
    ComprehendOperation.DescribePiiEntitiesDetectionJob,
    ComprehendOperation.DescribeResourcePolicy,
    ComprehendOperation.DescribeSentimentDetectionJob,
    ComprehendOperation.DescribeTargetedSentimentDetectionJob,
    ComprehendOperation.DescribeTopicsDetectionJob,
    ComprehendOperation.DetectDominantLanguage,
    ComprehendOperation.DetectEntities,
    ComprehendOperation.DetectKeyPhrases,
    ComprehendOperation.DetectPiiEntities,
    ComprehendOperation.DetectSentiment,
    ComprehendOperation.DetectSyntax,
    ComprehendOperation.DetectTargetedSentiment,
    ComprehendOperation.ImportModel,
    ComprehendOperation.ListDatasets,
    ComprehendOperation.ListDocumentClassificationJobs,
    ComprehendOperation.ListDocumentClassifiers,
    ComprehendOperation.ListDocumentClassifierSummaries,
    ComprehendOperation.ListDominantLanguageDetectionJobs,
    ComprehendOperation.ListEndpoints,
    ComprehendOperation.ListEntitiesDetectionJobs,
    ComprehendOperation.ListEntityRecognizers,
    ComprehendOperation.ListEntityRecognizerSummaries,
    ComprehendOperation.ListEventsDetectionJobs,
    ComprehendOperation.ListFlywheelIterationHistory,
    ComprehendOperation.ListFlywheels,
    ComprehendOperation.ListKeyPhrasesDetectionJobs,
    ComprehendOperation.ListPiiEntitiesDetectionJobs,
    ComprehendOperation.ListSentimentDetectionJobs,
    ComprehendOperation.ListTagsForResource,
    ComprehendOperation.ListTargetedSentimentDetectionJobs,
    ComprehendOperation.ListTopicsDetectionJobs,
    ComprehendOperation.PutResourcePolicy,
    ComprehendOperation.StartDocumentClassificationJob,
    ComprehendOperation.StartDominantLanguageDetectionJob,
    ComprehendOperation.StartEntitiesDetectionJob,
    ComprehendOperation.StartEventsDetectionJob,
    ComprehendOperation.StartFlywheelIteration,
    ComprehendOperation.StartKeyPhrasesDetectionJob,
    ComprehendOperation.StartPiiEntitiesDetectionJob,
    ComprehendOperation.StartSentimentDetectionJob,
    ComprehendOperation.StartTargetedSentimentDetectionJob,
    ComprehendOperation.StartTopicsDetectionJob,
    ComprehendOperation.StopDominantLanguageDetectionJob,
    ComprehendOperation.StopEntitiesDetectionJob,
    ComprehendOperation.StopEventsDetectionJob,
    ComprehendOperation.StopKeyPhrasesDetectionJob,
    ComprehendOperation.StopPiiEntitiesDetectionJob,
    ComprehendOperation.StopSentimentDetectionJob,
    ComprehendOperation.StopTargetedSentimentDetectionJob,
    ComprehendOperation.StopTrainingDocumentClassifier,
    ComprehendOperation.StopTrainingEntityRecognizer,
    ComprehendOperation.TagResource,
    ComprehendOperation.UntagResource,
    ComprehendOperation.UpdateEndpoint,
    ComprehendOperation.UpdateFlywheel,
  )

  def input[I, E, O, SI, SO](op: ComprehendOperation[I, E, O, SI, SO]): I = op.input
  def ordinal[I, E, O, SI, SO](op: ComprehendOperation[I, E, O, SI, SO]): Int = op.ordinal
  override def endpoint[I, E, O, SI, SO](op: ComprehendOperation[I, E, O, SI, SO]) = op.endpoint
  class Constant[P[-_, +_, +_, +_, +_]](value: P[Any, Nothing, Nothing, Nothing, Nothing]) extends ComprehendOperation.Transformed[ComprehendOperation, P](reified, const5(value))
  type Default[F[+_]] = Constant[smithy4s.kinds.stubs.Kind1[F]#toKind5]
  def reified: ComprehendGen[ComprehendOperation] = ComprehendOperation.reified
  def mapK5[P[_, _, _, _, _], P1[_, _, _, _, _]](alg: ComprehendGen[P], f: PolyFunction5[P, P1]): ComprehendGen[P1] = new ComprehendOperation.Transformed(alg, f)
  def fromPolyFunction[P[_, _, _, _, _]](f: PolyFunction5[ComprehendOperation, P]): ComprehendGen[P] = new ComprehendOperation.Transformed(reified, f)
  def toPolyFunction[P[_, _, _, _, _]](impl: ComprehendGen[P]): PolyFunction5[ComprehendOperation, P] = ComprehendOperation.toPolyFunction(impl)

  type BatchDetectDominantLanguageError = ComprehendOperation.BatchDetectDominantLanguageError
  val BatchDetectDominantLanguageError = ComprehendOperation.BatchDetectDominantLanguageError
  type BatchDetectEntitiesError = ComprehendOperation.BatchDetectEntitiesError
  val BatchDetectEntitiesError = ComprehendOperation.BatchDetectEntitiesError
  type BatchDetectKeyPhrasesError = ComprehendOperation.BatchDetectKeyPhrasesError
  val BatchDetectKeyPhrasesError = ComprehendOperation.BatchDetectKeyPhrasesError
  type BatchDetectSentimentError = ComprehendOperation.BatchDetectSentimentError
  val BatchDetectSentimentError = ComprehendOperation.BatchDetectSentimentError
  type BatchDetectSyntaxError = ComprehendOperation.BatchDetectSyntaxError
  val BatchDetectSyntaxError = ComprehendOperation.BatchDetectSyntaxError
  type BatchDetectTargetedSentimentError = ComprehendOperation.BatchDetectTargetedSentimentError
  val BatchDetectTargetedSentimentError = ComprehendOperation.BatchDetectTargetedSentimentError
  type ClassifyDocumentError = ComprehendOperation.ClassifyDocumentError
  val ClassifyDocumentError = ComprehendOperation.ClassifyDocumentError
  type ContainsPiiEntitiesError = ComprehendOperation.ContainsPiiEntitiesError
  val ContainsPiiEntitiesError = ComprehendOperation.ContainsPiiEntitiesError
  type CreateDatasetError = ComprehendOperation.CreateDatasetError
  val CreateDatasetError = ComprehendOperation.CreateDatasetError
  type CreateDocumentClassifierError = ComprehendOperation.CreateDocumentClassifierError
  val CreateDocumentClassifierError = ComprehendOperation.CreateDocumentClassifierError
  type CreateEndpointError = ComprehendOperation.CreateEndpointError
  val CreateEndpointError = ComprehendOperation.CreateEndpointError
  type CreateEntityRecognizerError = ComprehendOperation.CreateEntityRecognizerError
  val CreateEntityRecognizerError = ComprehendOperation.CreateEntityRecognizerError
  type CreateFlywheelError = ComprehendOperation.CreateFlywheelError
  val CreateFlywheelError = ComprehendOperation.CreateFlywheelError
  type DeleteDocumentClassifierError = ComprehendOperation.DeleteDocumentClassifierError
  val DeleteDocumentClassifierError = ComprehendOperation.DeleteDocumentClassifierError
  type DeleteEndpointError = ComprehendOperation.DeleteEndpointError
  val DeleteEndpointError = ComprehendOperation.DeleteEndpointError
  type DeleteEntityRecognizerError = ComprehendOperation.DeleteEntityRecognizerError
  val DeleteEntityRecognizerError = ComprehendOperation.DeleteEntityRecognizerError
  type DeleteFlywheelError = ComprehendOperation.DeleteFlywheelError
  val DeleteFlywheelError = ComprehendOperation.DeleteFlywheelError
  type DeleteResourcePolicyError = ComprehendOperation.DeleteResourcePolicyError
  val DeleteResourcePolicyError = ComprehendOperation.DeleteResourcePolicyError
  type DescribeDatasetError = ComprehendOperation.DescribeDatasetError
  val DescribeDatasetError = ComprehendOperation.DescribeDatasetError
  type DescribeDocumentClassificationJobError = ComprehendOperation.DescribeDocumentClassificationJobError
  val DescribeDocumentClassificationJobError = ComprehendOperation.DescribeDocumentClassificationJobError
  type DescribeDocumentClassifierError = ComprehendOperation.DescribeDocumentClassifierError
  val DescribeDocumentClassifierError = ComprehendOperation.DescribeDocumentClassifierError
  type DescribeDominantLanguageDetectionJobError = ComprehendOperation.DescribeDominantLanguageDetectionJobError
  val DescribeDominantLanguageDetectionJobError = ComprehendOperation.DescribeDominantLanguageDetectionJobError
  type DescribeEndpointError = ComprehendOperation.DescribeEndpointError
  val DescribeEndpointError = ComprehendOperation.DescribeEndpointError
  type DescribeEntitiesDetectionJobError = ComprehendOperation.DescribeEntitiesDetectionJobError
  val DescribeEntitiesDetectionJobError = ComprehendOperation.DescribeEntitiesDetectionJobError
  type DescribeEntityRecognizerError = ComprehendOperation.DescribeEntityRecognizerError
  val DescribeEntityRecognizerError = ComprehendOperation.DescribeEntityRecognizerError
  type DescribeEventsDetectionJobError = ComprehendOperation.DescribeEventsDetectionJobError
  val DescribeEventsDetectionJobError = ComprehendOperation.DescribeEventsDetectionJobError
  type DescribeFlywheelError = ComprehendOperation.DescribeFlywheelError
  val DescribeFlywheelError = ComprehendOperation.DescribeFlywheelError
  type DescribeFlywheelIterationError = ComprehendOperation.DescribeFlywheelIterationError
  val DescribeFlywheelIterationError = ComprehendOperation.DescribeFlywheelIterationError
  type DescribeKeyPhrasesDetectionJobError = ComprehendOperation.DescribeKeyPhrasesDetectionJobError
  val DescribeKeyPhrasesDetectionJobError = ComprehendOperation.DescribeKeyPhrasesDetectionJobError
  type DescribePiiEntitiesDetectionJobError = ComprehendOperation.DescribePiiEntitiesDetectionJobError
  val DescribePiiEntitiesDetectionJobError = ComprehendOperation.DescribePiiEntitiesDetectionJobError
  type DescribeResourcePolicyError = ComprehendOperation.DescribeResourcePolicyError
  val DescribeResourcePolicyError = ComprehendOperation.DescribeResourcePolicyError
  type DescribeSentimentDetectionJobError = ComprehendOperation.DescribeSentimentDetectionJobError
  val DescribeSentimentDetectionJobError = ComprehendOperation.DescribeSentimentDetectionJobError
  type DescribeTargetedSentimentDetectionJobError = ComprehendOperation.DescribeTargetedSentimentDetectionJobError
  val DescribeTargetedSentimentDetectionJobError = ComprehendOperation.DescribeTargetedSentimentDetectionJobError
  type DescribeTopicsDetectionJobError = ComprehendOperation.DescribeTopicsDetectionJobError
  val DescribeTopicsDetectionJobError = ComprehendOperation.DescribeTopicsDetectionJobError
  type DetectDominantLanguageError = ComprehendOperation.DetectDominantLanguageError
  val DetectDominantLanguageError = ComprehendOperation.DetectDominantLanguageError
  type DetectEntitiesError = ComprehendOperation.DetectEntitiesError
  val DetectEntitiesError = ComprehendOperation.DetectEntitiesError
  type DetectKeyPhrasesError = ComprehendOperation.DetectKeyPhrasesError
  val DetectKeyPhrasesError = ComprehendOperation.DetectKeyPhrasesError
  type DetectPiiEntitiesError = ComprehendOperation.DetectPiiEntitiesError
  val DetectPiiEntitiesError = ComprehendOperation.DetectPiiEntitiesError
  type DetectSentimentError = ComprehendOperation.DetectSentimentError
  val DetectSentimentError = ComprehendOperation.DetectSentimentError
  type DetectSyntaxError = ComprehendOperation.DetectSyntaxError
  val DetectSyntaxError = ComprehendOperation.DetectSyntaxError
  type DetectTargetedSentimentError = ComprehendOperation.DetectTargetedSentimentError
  val DetectTargetedSentimentError = ComprehendOperation.DetectTargetedSentimentError
  type ImportModelError = ComprehendOperation.ImportModelError
  val ImportModelError = ComprehendOperation.ImportModelError
  type ListDatasetsError = ComprehendOperation.ListDatasetsError
  val ListDatasetsError = ComprehendOperation.ListDatasetsError
  type ListDocumentClassificationJobsError = ComprehendOperation.ListDocumentClassificationJobsError
  val ListDocumentClassificationJobsError = ComprehendOperation.ListDocumentClassificationJobsError
  type ListDocumentClassifiersError = ComprehendOperation.ListDocumentClassifiersError
  val ListDocumentClassifiersError = ComprehendOperation.ListDocumentClassifiersError
  type ListDocumentClassifierSummariesError = ComprehendOperation.ListDocumentClassifierSummariesError
  val ListDocumentClassifierSummariesError = ComprehendOperation.ListDocumentClassifierSummariesError
  type ListDominantLanguageDetectionJobsError = ComprehendOperation.ListDominantLanguageDetectionJobsError
  val ListDominantLanguageDetectionJobsError = ComprehendOperation.ListDominantLanguageDetectionJobsError
  type ListEndpointsError = ComprehendOperation.ListEndpointsError
  val ListEndpointsError = ComprehendOperation.ListEndpointsError
  type ListEntitiesDetectionJobsError = ComprehendOperation.ListEntitiesDetectionJobsError
  val ListEntitiesDetectionJobsError = ComprehendOperation.ListEntitiesDetectionJobsError
  type ListEntityRecognizersError = ComprehendOperation.ListEntityRecognizersError
  val ListEntityRecognizersError = ComprehendOperation.ListEntityRecognizersError
  type ListEntityRecognizerSummariesError = ComprehendOperation.ListEntityRecognizerSummariesError
  val ListEntityRecognizerSummariesError = ComprehendOperation.ListEntityRecognizerSummariesError
  type ListEventsDetectionJobsError = ComprehendOperation.ListEventsDetectionJobsError
  val ListEventsDetectionJobsError = ComprehendOperation.ListEventsDetectionJobsError
  type ListFlywheelIterationHistoryError = ComprehendOperation.ListFlywheelIterationHistoryError
  val ListFlywheelIterationHistoryError = ComprehendOperation.ListFlywheelIterationHistoryError
  type ListFlywheelsError = ComprehendOperation.ListFlywheelsError
  val ListFlywheelsError = ComprehendOperation.ListFlywheelsError
  type ListKeyPhrasesDetectionJobsError = ComprehendOperation.ListKeyPhrasesDetectionJobsError
  val ListKeyPhrasesDetectionJobsError = ComprehendOperation.ListKeyPhrasesDetectionJobsError
  type ListPiiEntitiesDetectionJobsError = ComprehendOperation.ListPiiEntitiesDetectionJobsError
  val ListPiiEntitiesDetectionJobsError = ComprehendOperation.ListPiiEntitiesDetectionJobsError
  type ListSentimentDetectionJobsError = ComprehendOperation.ListSentimentDetectionJobsError
  val ListSentimentDetectionJobsError = ComprehendOperation.ListSentimentDetectionJobsError
  type ListTagsForResourceError = ComprehendOperation.ListTagsForResourceError
  val ListTagsForResourceError = ComprehendOperation.ListTagsForResourceError
  type ListTargetedSentimentDetectionJobsError = ComprehendOperation.ListTargetedSentimentDetectionJobsError
  val ListTargetedSentimentDetectionJobsError = ComprehendOperation.ListTargetedSentimentDetectionJobsError
  type ListTopicsDetectionJobsError = ComprehendOperation.ListTopicsDetectionJobsError
  val ListTopicsDetectionJobsError = ComprehendOperation.ListTopicsDetectionJobsError
  type PutResourcePolicyError = ComprehendOperation.PutResourcePolicyError
  val PutResourcePolicyError = ComprehendOperation.PutResourcePolicyError
  type StartDocumentClassificationJobError = ComprehendOperation.StartDocumentClassificationJobError
  val StartDocumentClassificationJobError = ComprehendOperation.StartDocumentClassificationJobError
  type StartDominantLanguageDetectionJobError = ComprehendOperation.StartDominantLanguageDetectionJobError
  val StartDominantLanguageDetectionJobError = ComprehendOperation.StartDominantLanguageDetectionJobError
  type StartEntitiesDetectionJobError = ComprehendOperation.StartEntitiesDetectionJobError
  val StartEntitiesDetectionJobError = ComprehendOperation.StartEntitiesDetectionJobError
  type StartEventsDetectionJobError = ComprehendOperation.StartEventsDetectionJobError
  val StartEventsDetectionJobError = ComprehendOperation.StartEventsDetectionJobError
  type StartFlywheelIterationError = ComprehendOperation.StartFlywheelIterationError
  val StartFlywheelIterationError = ComprehendOperation.StartFlywheelIterationError
  type StartKeyPhrasesDetectionJobError = ComprehendOperation.StartKeyPhrasesDetectionJobError
  val StartKeyPhrasesDetectionJobError = ComprehendOperation.StartKeyPhrasesDetectionJobError
  type StartPiiEntitiesDetectionJobError = ComprehendOperation.StartPiiEntitiesDetectionJobError
  val StartPiiEntitiesDetectionJobError = ComprehendOperation.StartPiiEntitiesDetectionJobError
  type StartSentimentDetectionJobError = ComprehendOperation.StartSentimentDetectionJobError
  val StartSentimentDetectionJobError = ComprehendOperation.StartSentimentDetectionJobError
  type StartTargetedSentimentDetectionJobError = ComprehendOperation.StartTargetedSentimentDetectionJobError
  val StartTargetedSentimentDetectionJobError = ComprehendOperation.StartTargetedSentimentDetectionJobError
  type StartTopicsDetectionJobError = ComprehendOperation.StartTopicsDetectionJobError
  val StartTopicsDetectionJobError = ComprehendOperation.StartTopicsDetectionJobError
  type StopDominantLanguageDetectionJobError = ComprehendOperation.StopDominantLanguageDetectionJobError
  val StopDominantLanguageDetectionJobError = ComprehendOperation.StopDominantLanguageDetectionJobError
  type StopEntitiesDetectionJobError = ComprehendOperation.StopEntitiesDetectionJobError
  val StopEntitiesDetectionJobError = ComprehendOperation.StopEntitiesDetectionJobError
  type StopEventsDetectionJobError = ComprehendOperation.StopEventsDetectionJobError
  val StopEventsDetectionJobError = ComprehendOperation.StopEventsDetectionJobError
  type StopKeyPhrasesDetectionJobError = ComprehendOperation.StopKeyPhrasesDetectionJobError
  val StopKeyPhrasesDetectionJobError = ComprehendOperation.StopKeyPhrasesDetectionJobError
  type StopPiiEntitiesDetectionJobError = ComprehendOperation.StopPiiEntitiesDetectionJobError
  val StopPiiEntitiesDetectionJobError = ComprehendOperation.StopPiiEntitiesDetectionJobError
  type StopSentimentDetectionJobError = ComprehendOperation.StopSentimentDetectionJobError
  val StopSentimentDetectionJobError = ComprehendOperation.StopSentimentDetectionJobError
  type StopTargetedSentimentDetectionJobError = ComprehendOperation.StopTargetedSentimentDetectionJobError
  val StopTargetedSentimentDetectionJobError = ComprehendOperation.StopTargetedSentimentDetectionJobError
  type StopTrainingDocumentClassifierError = ComprehendOperation.StopTrainingDocumentClassifierError
  val StopTrainingDocumentClassifierError = ComprehendOperation.StopTrainingDocumentClassifierError
  type StopTrainingEntityRecognizerError = ComprehendOperation.StopTrainingEntityRecognizerError
  val StopTrainingEntityRecognizerError = ComprehendOperation.StopTrainingEntityRecognizerError
  type TagResourceError = ComprehendOperation.TagResourceError
  val TagResourceError = ComprehendOperation.TagResourceError
  type UntagResourceError = ComprehendOperation.UntagResourceError
  val UntagResourceError = ComprehendOperation.UntagResourceError
  type UpdateEndpointError = ComprehendOperation.UpdateEndpointError
  val UpdateEndpointError = ComprehendOperation.UpdateEndpointError
  type UpdateFlywheelError = ComprehendOperation.UpdateFlywheelError
  val UpdateFlywheelError = ComprehendOperation.UpdateFlywheelError
}

sealed trait ComprehendOperation[Input, Err, Output, StreamedInput, StreamedOutput] {
  def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[Input, Err, Output, StreamedInput, StreamedOutput]
  def ordinal: Int
  def input: Input
  def endpoint: Endpoint[ComprehendOperation, Input, Err, Output, StreamedInput, StreamedOutput]
}

object ComprehendOperation {

  object reified extends ComprehendGen[ComprehendOperation] {
    def batchDetectDominantLanguage(textList: List[CustomerInputString]): BatchDetectDominantLanguage = BatchDetectDominantLanguage(BatchDetectDominantLanguageRequest(textList))
    def batchDetectEntities(textList: List[CustomerInputString], languageCode: LanguageCode): BatchDetectEntities = BatchDetectEntities(BatchDetectEntitiesRequest(textList, languageCode))
    def batchDetectKeyPhrases(textList: List[CustomerInputString], languageCode: LanguageCode): BatchDetectKeyPhrases = BatchDetectKeyPhrases(BatchDetectKeyPhrasesRequest(textList, languageCode))
    def batchDetectSentiment(textList: List[CustomerInputString], languageCode: LanguageCode): BatchDetectSentiment = BatchDetectSentiment(BatchDetectSentimentRequest(textList, languageCode))
    def batchDetectSyntax(textList: List[CustomerInputString], languageCode: SyntaxLanguageCode): BatchDetectSyntax = BatchDetectSyntax(BatchDetectSyntaxRequest(textList, languageCode))
    def batchDetectTargetedSentiment(textList: List[CustomerInputString], languageCode: LanguageCode): BatchDetectTargetedSentiment = BatchDetectTargetedSentiment(BatchDetectTargetedSentimentRequest(textList, languageCode))
    def classifyDocument(endpointArn: DocumentClassifierEndpointArn, text: Option[CustomerInputString] = None, bytes: Option[SemiStructuredDocumentBlob] = None, documentReaderConfig: Option[DocumentReaderConfig] = None): ClassifyDocument = ClassifyDocument(ClassifyDocumentRequest(endpointArn, text, bytes, documentReaderConfig))
    def containsPiiEntities(text: String, languageCode: LanguageCode): ContainsPiiEntities = ContainsPiiEntities(ContainsPiiEntitiesRequest(text, languageCode))
    def createDataset(flywheelArn: ComprehendFlywheelArn, datasetName: ComprehendArnName, inputDataConfig: DatasetInputDataConfig, datasetType: Option[DatasetType] = None, description: Option[Description] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): CreateDataset = CreateDataset(CreateDatasetRequest(flywheelArn, datasetName, inputDataConfig, datasetType, description, clientRequestToken, tags))
    def createDocumentClassifier(documentClassifierName: ComprehendArnName, dataAccessRoleArn: IamRoleArn, inputDataConfig: DocumentClassifierInputDataConfig, languageCode: LanguageCode, versionName: Option[VersionName] = None, tags: Option[List[Tag]] = None, outputDataConfig: Option[DocumentClassifierOutputDataConfig] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, mode: Option[DocumentClassifierMode] = None, modelKmsKeyId: Option[KmsKeyId] = None, modelPolicy: Option[Policy] = None): CreateDocumentClassifier = CreateDocumentClassifier(CreateDocumentClassifierRequest(documentClassifierName, dataAccessRoleArn, inputDataConfig, languageCode, versionName, tags, outputDataConfig, clientRequestToken, volumeKmsKeyId, vpcConfig, mode, modelKmsKeyId, modelPolicy))
    def createEndpoint(endpointName: ComprehendEndpointName, desiredInferenceUnits: InferenceUnitsInteger, modelArn: Option[ComprehendModelArn] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None, dataAccessRoleArn: Option[IamRoleArn] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): CreateEndpoint = CreateEndpoint(CreateEndpointRequest(endpointName, desiredInferenceUnits, modelArn, clientRequestToken, tags, dataAccessRoleArn, flywheelArn))
    def createEntityRecognizer(recognizerName: ComprehendArnName, dataAccessRoleArn: IamRoleArn, inputDataConfig: EntityRecognizerInputDataConfig, languageCode: LanguageCode, versionName: Option[VersionName] = None, tags: Option[List[Tag]] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, modelKmsKeyId: Option[KmsKeyId] = None, modelPolicy: Option[Policy] = None): CreateEntityRecognizer = CreateEntityRecognizer(CreateEntityRecognizerRequest(recognizerName, dataAccessRoleArn, inputDataConfig, languageCode, versionName, tags, clientRequestToken, volumeKmsKeyId, vpcConfig, modelKmsKeyId, modelPolicy))
    def createFlywheel(flywheelName: ComprehendArnName, dataAccessRoleArn: IamRoleArn, dataLakeS3Uri: FlywheelS3Uri, activeModelArn: Option[ComprehendModelArn] = None, taskConfig: Option[TaskConfig] = None, modelType: Option[ModelType] = None, dataSecurityConfig: Option[DataSecurityConfig] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): CreateFlywheel = CreateFlywheel(CreateFlywheelRequest(flywheelName, dataAccessRoleArn, dataLakeS3Uri, activeModelArn, taskConfig, modelType, dataSecurityConfig, clientRequestToken, tags))
    def deleteDocumentClassifier(documentClassifierArn: DocumentClassifierArn): DeleteDocumentClassifier = DeleteDocumentClassifier(DeleteDocumentClassifierRequest(documentClassifierArn))
    def deleteEndpoint(endpointArn: ComprehendEndpointArn): DeleteEndpoint = DeleteEndpoint(DeleteEndpointRequest(endpointArn))
    def deleteEntityRecognizer(entityRecognizerArn: EntityRecognizerArn): DeleteEntityRecognizer = DeleteEntityRecognizer(DeleteEntityRecognizerRequest(entityRecognizerArn))
    def deleteFlywheel(flywheelArn: ComprehendFlywheelArn): DeleteFlywheel = DeleteFlywheel(DeleteFlywheelRequest(flywheelArn))
    def deleteResourcePolicy(resourceArn: ComprehendModelArn, policyRevisionId: Option[PolicyRevisionId] = None): DeleteResourcePolicy = DeleteResourcePolicy(DeleteResourcePolicyRequest(resourceArn, policyRevisionId))
    def describeDataset(datasetArn: ComprehendDatasetArn): DescribeDataset = DescribeDataset(DescribeDatasetRequest(datasetArn))
    def describeDocumentClassificationJob(jobId: JobId): DescribeDocumentClassificationJob = DescribeDocumentClassificationJob(DescribeDocumentClassificationJobRequest(jobId))
    def describeDocumentClassifier(documentClassifierArn: DocumentClassifierArn): DescribeDocumentClassifier = DescribeDocumentClassifier(DescribeDocumentClassifierRequest(documentClassifierArn))
    def describeDominantLanguageDetectionJob(jobId: JobId): DescribeDominantLanguageDetectionJob = DescribeDominantLanguageDetectionJob(DescribeDominantLanguageDetectionJobRequest(jobId))
    def describeEndpoint(endpointArn: ComprehendEndpointArn): DescribeEndpoint = DescribeEndpoint(DescribeEndpointRequest(endpointArn))
    def describeEntitiesDetectionJob(jobId: JobId): DescribeEntitiesDetectionJob = DescribeEntitiesDetectionJob(DescribeEntitiesDetectionJobRequest(jobId))
    def describeEntityRecognizer(entityRecognizerArn: EntityRecognizerArn): DescribeEntityRecognizer = DescribeEntityRecognizer(DescribeEntityRecognizerRequest(entityRecognizerArn))
    def describeEventsDetectionJob(jobId: JobId): DescribeEventsDetectionJob = DescribeEventsDetectionJob(DescribeEventsDetectionJobRequest(jobId))
    def describeFlywheel(flywheelArn: ComprehendFlywheelArn): DescribeFlywheel = DescribeFlywheel(DescribeFlywheelRequest(flywheelArn))
    def describeFlywheelIteration(flywheelArn: ComprehendFlywheelArn, flywheelIterationId: FlywheelIterationId): DescribeFlywheelIteration = DescribeFlywheelIteration(DescribeFlywheelIterationRequest(flywheelArn, flywheelIterationId))
    def describeKeyPhrasesDetectionJob(jobId: JobId): DescribeKeyPhrasesDetectionJob = DescribeKeyPhrasesDetectionJob(DescribeKeyPhrasesDetectionJobRequest(jobId))
    def describePiiEntitiesDetectionJob(jobId: JobId): DescribePiiEntitiesDetectionJob = DescribePiiEntitiesDetectionJob(DescribePiiEntitiesDetectionJobRequest(jobId))
    def describeResourcePolicy(resourceArn: ComprehendModelArn): DescribeResourcePolicy = DescribeResourcePolicy(DescribeResourcePolicyRequest(resourceArn))
    def describeSentimentDetectionJob(jobId: JobId): DescribeSentimentDetectionJob = DescribeSentimentDetectionJob(DescribeSentimentDetectionJobRequest(jobId))
    def describeTargetedSentimentDetectionJob(jobId: JobId): DescribeTargetedSentimentDetectionJob = DescribeTargetedSentimentDetectionJob(DescribeTargetedSentimentDetectionJobRequest(jobId))
    def describeTopicsDetectionJob(jobId: JobId): DescribeTopicsDetectionJob = DescribeTopicsDetectionJob(DescribeTopicsDetectionJobRequest(jobId))
    def detectDominantLanguage(text: CustomerInputString): DetectDominantLanguage = DetectDominantLanguage(DetectDominantLanguageRequest(text))
    def detectEntities(text: Option[CustomerInputString] = None, languageCode: Option[LanguageCode] = None, endpointArn: Option[EntityRecognizerEndpointArn] = None, bytes: Option[SemiStructuredDocumentBlob] = None, documentReaderConfig: Option[DocumentReaderConfig] = None): DetectEntities = DetectEntities(DetectEntitiesRequest(text, languageCode, endpointArn, bytes, documentReaderConfig))
    def detectKeyPhrases(text: CustomerInputString, languageCode: LanguageCode): DetectKeyPhrases = DetectKeyPhrases(DetectKeyPhrasesRequest(text, languageCode))
    def detectPiiEntities(text: String, languageCode: LanguageCode): DetectPiiEntities = DetectPiiEntities(DetectPiiEntitiesRequest(text, languageCode))
    def detectSentiment(text: CustomerInputString, languageCode: LanguageCode): DetectSentiment = DetectSentiment(DetectSentimentRequest(text, languageCode))
    def detectSyntax(text: CustomerInputString, languageCode: SyntaxLanguageCode): DetectSyntax = DetectSyntax(DetectSyntaxRequest(text, languageCode))
    def detectTargetedSentiment(text: CustomerInputString, languageCode: LanguageCode): DetectTargetedSentiment = DetectTargetedSentiment(DetectTargetedSentimentRequest(text, languageCode))
    def importModel(sourceModelArn: ComprehendModelArn, modelName: Option[ComprehendArnName] = None, versionName: Option[VersionName] = None, modelKmsKeyId: Option[KmsKeyId] = None, dataAccessRoleArn: Option[IamRoleArn] = None, tags: Option[List[Tag]] = None): ImportModel = ImportModel(ImportModelRequest(sourceModelArn, modelName, versionName, modelKmsKeyId, dataAccessRoleArn, tags))
    def listDatasets(flywheelArn: Option[ComprehendFlywheelArn] = None, filter: Option[DatasetFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListDatasets = ListDatasets(ListDatasetsRequest(flywheelArn, filter, nextToken, maxResults))
    def listDocumentClassificationJobs(filter: Option[DocumentClassificationJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListDocumentClassificationJobs = ListDocumentClassificationJobs(ListDocumentClassificationJobsRequest(filter, nextToken, maxResults))
    def listDocumentClassifiers(filter: Option[DocumentClassifierFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListDocumentClassifiers = ListDocumentClassifiers(ListDocumentClassifiersRequest(filter, nextToken, maxResults))
    def listDocumentClassifierSummaries(nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListDocumentClassifierSummaries = ListDocumentClassifierSummaries(ListDocumentClassifierSummariesRequest(nextToken, maxResults))
    def listDominantLanguageDetectionJobs(filter: Option[DominantLanguageDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListDominantLanguageDetectionJobs = ListDominantLanguageDetectionJobs(ListDominantLanguageDetectionJobsRequest(filter, nextToken, maxResults))
    def listEndpoints(filter: Option[EndpointFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListEndpoints = ListEndpoints(ListEndpointsRequest(filter, nextToken, maxResults))
    def listEntitiesDetectionJobs(filter: Option[EntitiesDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListEntitiesDetectionJobs = ListEntitiesDetectionJobs(ListEntitiesDetectionJobsRequest(filter, nextToken, maxResults))
    def listEntityRecognizers(filter: Option[EntityRecognizerFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListEntityRecognizers = ListEntityRecognizers(ListEntityRecognizersRequest(filter, nextToken, maxResults))
    def listEntityRecognizerSummaries(nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListEntityRecognizerSummaries = ListEntityRecognizerSummaries(ListEntityRecognizerSummariesRequest(nextToken, maxResults))
    def listEventsDetectionJobs(filter: Option[EventsDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListEventsDetectionJobs = ListEventsDetectionJobs(ListEventsDetectionJobsRequest(filter, nextToken, maxResults))
    def listFlywheelIterationHistory(flywheelArn: ComprehendFlywheelArn, filter: Option[FlywheelIterationFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListFlywheelIterationHistory = ListFlywheelIterationHistory(ListFlywheelIterationHistoryRequest(flywheelArn, filter, nextToken, maxResults))
    def listFlywheels(filter: Option[FlywheelFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListFlywheels = ListFlywheels(ListFlywheelsRequest(filter, nextToken, maxResults))
    def listKeyPhrasesDetectionJobs(filter: Option[KeyPhrasesDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListKeyPhrasesDetectionJobs = ListKeyPhrasesDetectionJobs(ListKeyPhrasesDetectionJobsRequest(filter, nextToken, maxResults))
    def listPiiEntitiesDetectionJobs(filter: Option[PiiEntitiesDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListPiiEntitiesDetectionJobs = ListPiiEntitiesDetectionJobs(ListPiiEntitiesDetectionJobsRequest(filter, nextToken, maxResults))
    def listSentimentDetectionJobs(filter: Option[SentimentDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListSentimentDetectionJobs = ListSentimentDetectionJobs(ListSentimentDetectionJobsRequest(filter, nextToken, maxResults))
    def listTagsForResource(resourceArn: ComprehendArn): ListTagsForResource = ListTagsForResource(ListTagsForResourceRequest(resourceArn))
    def listTargetedSentimentDetectionJobs(filter: Option[TargetedSentimentDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListTargetedSentimentDetectionJobs = ListTargetedSentimentDetectionJobs(ListTargetedSentimentDetectionJobsRequest(filter, nextToken, maxResults))
    def listTopicsDetectionJobs(filter: Option[TopicsDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): ListTopicsDetectionJobs = ListTopicsDetectionJobs(ListTopicsDetectionJobsRequest(filter, nextToken, maxResults))
    def putResourcePolicy(resourceArn: ComprehendModelArn, resourcePolicy: Policy, policyRevisionId: Option[PolicyRevisionId] = None): PutResourcePolicy = PutResourcePolicy(PutResourcePolicyRequest(resourceArn, resourcePolicy, policyRevisionId))
    def startDocumentClassificationJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, jobName: Option[JobName] = None, documentClassifierArn: Option[DocumentClassifierArn] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): StartDocumentClassificationJob = StartDocumentClassificationJob(StartDocumentClassificationJobRequest(inputDataConfig, outputDataConfig, dataAccessRoleArn, jobName, documentClassifierArn, clientRequestToken, volumeKmsKeyId, vpcConfig, tags, flywheelArn))
    def startDominantLanguageDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): StartDominantLanguageDetectionJob = StartDominantLanguageDetectionJob(StartDominantLanguageDetectionJobRequest(inputDataConfig, outputDataConfig, dataAccessRoleArn, jobName, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def startEntitiesDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, entityRecognizerArn: Option[EntityRecognizerArn] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): StartEntitiesDetectionJob = StartEntitiesDetectionJob(StartEntitiesDetectionJobRequest(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, jobName, entityRecognizerArn, clientRequestToken, volumeKmsKeyId, vpcConfig, tags, flywheelArn))
    def startEventsDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, targetEventTypes: List[EventTypeString], jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): StartEventsDetectionJob = StartEventsDetectionJob(StartEventsDetectionJobRequest(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, targetEventTypes, jobName, clientRequestToken, tags))
    def startFlywheelIteration(flywheelArn: ComprehendFlywheelArn, clientRequestToken: Option[ClientRequestTokenString] = None): StartFlywheelIteration = StartFlywheelIteration(StartFlywheelIterationRequest(flywheelArn, clientRequestToken))
    def startKeyPhrasesDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): StartKeyPhrasesDetectionJob = StartKeyPhrasesDetectionJob(StartKeyPhrasesDetectionJobRequest(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, jobName, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def startPiiEntitiesDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, mode: PiiEntitiesDetectionMode, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, redactionConfig: Option[RedactionConfig] = None, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): StartPiiEntitiesDetectionJob = StartPiiEntitiesDetectionJob(StartPiiEntitiesDetectionJobRequest(inputDataConfig, outputDataConfig, mode, dataAccessRoleArn, languageCode, redactionConfig, jobName, clientRequestToken, tags))
    def startSentimentDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): StartSentimentDetectionJob = StartSentimentDetectionJob(StartSentimentDetectionJobRequest(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, jobName, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def startTargetedSentimentDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): StartTargetedSentimentDetectionJob = StartTargetedSentimentDetectionJob(StartTargetedSentimentDetectionJobRequest(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, jobName, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def startTopicsDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, jobName: Option[JobName] = None, numberOfTopics: Option[NumberOfTopicsInteger] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): StartTopicsDetectionJob = StartTopicsDetectionJob(StartTopicsDetectionJobRequest(inputDataConfig, outputDataConfig, dataAccessRoleArn, jobName, numberOfTopics, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def stopDominantLanguageDetectionJob(jobId: JobId): StopDominantLanguageDetectionJob = StopDominantLanguageDetectionJob(StopDominantLanguageDetectionJobRequest(jobId))
    def stopEntitiesDetectionJob(jobId: JobId): StopEntitiesDetectionJob = StopEntitiesDetectionJob(StopEntitiesDetectionJobRequest(jobId))
    def stopEventsDetectionJob(jobId: JobId): StopEventsDetectionJob = StopEventsDetectionJob(StopEventsDetectionJobRequest(jobId))
    def stopKeyPhrasesDetectionJob(jobId: JobId): StopKeyPhrasesDetectionJob = StopKeyPhrasesDetectionJob(StopKeyPhrasesDetectionJobRequest(jobId))
    def stopPiiEntitiesDetectionJob(jobId: JobId): StopPiiEntitiesDetectionJob = StopPiiEntitiesDetectionJob(StopPiiEntitiesDetectionJobRequest(jobId))
    def stopSentimentDetectionJob(jobId: JobId): StopSentimentDetectionJob = StopSentimentDetectionJob(StopSentimentDetectionJobRequest(jobId))
    def stopTargetedSentimentDetectionJob(jobId: JobId): StopTargetedSentimentDetectionJob = StopTargetedSentimentDetectionJob(StopTargetedSentimentDetectionJobRequest(jobId))
    def stopTrainingDocumentClassifier(documentClassifierArn: DocumentClassifierArn): StopTrainingDocumentClassifier = StopTrainingDocumentClassifier(StopTrainingDocumentClassifierRequest(documentClassifierArn))
    def stopTrainingEntityRecognizer(entityRecognizerArn: EntityRecognizerArn): StopTrainingEntityRecognizer = StopTrainingEntityRecognizer(StopTrainingEntityRecognizerRequest(entityRecognizerArn))
    def tagResource(resourceArn: ComprehendArn, tags: List[Tag]): TagResource = TagResource(TagResourceRequest(resourceArn, tags))
    def untagResource(resourceArn: ComprehendArn, tagKeys: List[TagKey]): UntagResource = UntagResource(UntagResourceRequest(resourceArn, tagKeys))
    def updateEndpoint(endpointArn: ComprehendEndpointArn, desiredModelArn: Option[ComprehendModelArn] = None, desiredInferenceUnits: Option[InferenceUnitsInteger] = None, desiredDataAccessRoleArn: Option[IamRoleArn] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): UpdateEndpoint = UpdateEndpoint(UpdateEndpointRequest(endpointArn, desiredModelArn, desiredInferenceUnits, desiredDataAccessRoleArn, flywheelArn))
    def updateFlywheel(flywheelArn: ComprehendFlywheelArn, activeModelArn: Option[ComprehendModelArn] = None, dataAccessRoleArn: Option[IamRoleArn] = None, dataSecurityConfig: Option[UpdateDataSecurityConfig] = None): UpdateFlywheel = UpdateFlywheel(UpdateFlywheelRequest(flywheelArn, activeModelArn, dataAccessRoleArn, dataSecurityConfig))
  }
  class Transformed[P[_, _, _, _, _], P1[_ ,_ ,_ ,_ ,_]](alg: ComprehendGen[P], f: PolyFunction5[P, P1]) extends ComprehendGen[P1] {
    def batchDetectDominantLanguage(textList: List[CustomerInputString]): P1[BatchDetectDominantLanguageRequest, ComprehendOperation.BatchDetectDominantLanguageError, BatchDetectDominantLanguageResponse, Nothing, Nothing] = f[BatchDetectDominantLanguageRequest, ComprehendOperation.BatchDetectDominantLanguageError, BatchDetectDominantLanguageResponse, Nothing, Nothing](alg.batchDetectDominantLanguage(textList))
    def batchDetectEntities(textList: List[CustomerInputString], languageCode: LanguageCode): P1[BatchDetectEntitiesRequest, ComprehendOperation.BatchDetectEntitiesError, BatchDetectEntitiesResponse, Nothing, Nothing] = f[BatchDetectEntitiesRequest, ComprehendOperation.BatchDetectEntitiesError, BatchDetectEntitiesResponse, Nothing, Nothing](alg.batchDetectEntities(textList, languageCode))
    def batchDetectKeyPhrases(textList: List[CustomerInputString], languageCode: LanguageCode): P1[BatchDetectKeyPhrasesRequest, ComprehendOperation.BatchDetectKeyPhrasesError, BatchDetectKeyPhrasesResponse, Nothing, Nothing] = f[BatchDetectKeyPhrasesRequest, ComprehendOperation.BatchDetectKeyPhrasesError, BatchDetectKeyPhrasesResponse, Nothing, Nothing](alg.batchDetectKeyPhrases(textList, languageCode))
    def batchDetectSentiment(textList: List[CustomerInputString], languageCode: LanguageCode): P1[BatchDetectSentimentRequest, ComprehendOperation.BatchDetectSentimentError, BatchDetectSentimentResponse, Nothing, Nothing] = f[BatchDetectSentimentRequest, ComprehendOperation.BatchDetectSentimentError, BatchDetectSentimentResponse, Nothing, Nothing](alg.batchDetectSentiment(textList, languageCode))
    def batchDetectSyntax(textList: List[CustomerInputString], languageCode: SyntaxLanguageCode): P1[BatchDetectSyntaxRequest, ComprehendOperation.BatchDetectSyntaxError, BatchDetectSyntaxResponse, Nothing, Nothing] = f[BatchDetectSyntaxRequest, ComprehendOperation.BatchDetectSyntaxError, BatchDetectSyntaxResponse, Nothing, Nothing](alg.batchDetectSyntax(textList, languageCode))
    def batchDetectTargetedSentiment(textList: List[CustomerInputString], languageCode: LanguageCode): P1[BatchDetectTargetedSentimentRequest, ComprehendOperation.BatchDetectTargetedSentimentError, BatchDetectTargetedSentimentResponse, Nothing, Nothing] = f[BatchDetectTargetedSentimentRequest, ComprehendOperation.BatchDetectTargetedSentimentError, BatchDetectTargetedSentimentResponse, Nothing, Nothing](alg.batchDetectTargetedSentiment(textList, languageCode))
    def classifyDocument(endpointArn: DocumentClassifierEndpointArn, text: Option[CustomerInputString] = None, bytes: Option[SemiStructuredDocumentBlob] = None, documentReaderConfig: Option[DocumentReaderConfig] = None): P1[ClassifyDocumentRequest, ComprehendOperation.ClassifyDocumentError, ClassifyDocumentResponse, Nothing, Nothing] = f[ClassifyDocumentRequest, ComprehendOperation.ClassifyDocumentError, ClassifyDocumentResponse, Nothing, Nothing](alg.classifyDocument(endpointArn, text, bytes, documentReaderConfig))
    def containsPiiEntities(text: String, languageCode: LanguageCode): P1[ContainsPiiEntitiesRequest, ComprehendOperation.ContainsPiiEntitiesError, ContainsPiiEntitiesResponse, Nothing, Nothing] = f[ContainsPiiEntitiesRequest, ComprehendOperation.ContainsPiiEntitiesError, ContainsPiiEntitiesResponse, Nothing, Nothing](alg.containsPiiEntities(text, languageCode))
    def createDataset(flywheelArn: ComprehendFlywheelArn, datasetName: ComprehendArnName, inputDataConfig: DatasetInputDataConfig, datasetType: Option[DatasetType] = None, description: Option[Description] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): P1[CreateDatasetRequest, ComprehendOperation.CreateDatasetError, CreateDatasetResponse, Nothing, Nothing] = f[CreateDatasetRequest, ComprehendOperation.CreateDatasetError, CreateDatasetResponse, Nothing, Nothing](alg.createDataset(flywheelArn, datasetName, inputDataConfig, datasetType, description, clientRequestToken, tags))
    def createDocumentClassifier(documentClassifierName: ComprehendArnName, dataAccessRoleArn: IamRoleArn, inputDataConfig: DocumentClassifierInputDataConfig, languageCode: LanguageCode, versionName: Option[VersionName] = None, tags: Option[List[Tag]] = None, outputDataConfig: Option[DocumentClassifierOutputDataConfig] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, mode: Option[DocumentClassifierMode] = None, modelKmsKeyId: Option[KmsKeyId] = None, modelPolicy: Option[Policy] = None): P1[CreateDocumentClassifierRequest, ComprehendOperation.CreateDocumentClassifierError, CreateDocumentClassifierResponse, Nothing, Nothing] = f[CreateDocumentClassifierRequest, ComprehendOperation.CreateDocumentClassifierError, CreateDocumentClassifierResponse, Nothing, Nothing](alg.createDocumentClassifier(documentClassifierName, dataAccessRoleArn, inputDataConfig, languageCode, versionName, tags, outputDataConfig, clientRequestToken, volumeKmsKeyId, vpcConfig, mode, modelKmsKeyId, modelPolicy))
    def createEndpoint(endpointName: ComprehendEndpointName, desiredInferenceUnits: InferenceUnitsInteger, modelArn: Option[ComprehendModelArn] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None, dataAccessRoleArn: Option[IamRoleArn] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): P1[CreateEndpointRequest, ComprehendOperation.CreateEndpointError, CreateEndpointResponse, Nothing, Nothing] = f[CreateEndpointRequest, ComprehendOperation.CreateEndpointError, CreateEndpointResponse, Nothing, Nothing](alg.createEndpoint(endpointName, desiredInferenceUnits, modelArn, clientRequestToken, tags, dataAccessRoleArn, flywheelArn))
    def createEntityRecognizer(recognizerName: ComprehendArnName, dataAccessRoleArn: IamRoleArn, inputDataConfig: EntityRecognizerInputDataConfig, languageCode: LanguageCode, versionName: Option[VersionName] = None, tags: Option[List[Tag]] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, modelKmsKeyId: Option[KmsKeyId] = None, modelPolicy: Option[Policy] = None): P1[CreateEntityRecognizerRequest, ComprehendOperation.CreateEntityRecognizerError, CreateEntityRecognizerResponse, Nothing, Nothing] = f[CreateEntityRecognizerRequest, ComprehendOperation.CreateEntityRecognizerError, CreateEntityRecognizerResponse, Nothing, Nothing](alg.createEntityRecognizer(recognizerName, dataAccessRoleArn, inputDataConfig, languageCode, versionName, tags, clientRequestToken, volumeKmsKeyId, vpcConfig, modelKmsKeyId, modelPolicy))
    def createFlywheel(flywheelName: ComprehendArnName, dataAccessRoleArn: IamRoleArn, dataLakeS3Uri: FlywheelS3Uri, activeModelArn: Option[ComprehendModelArn] = None, taskConfig: Option[TaskConfig] = None, modelType: Option[ModelType] = None, dataSecurityConfig: Option[DataSecurityConfig] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): P1[CreateFlywheelRequest, ComprehendOperation.CreateFlywheelError, CreateFlywheelResponse, Nothing, Nothing] = f[CreateFlywheelRequest, ComprehendOperation.CreateFlywheelError, CreateFlywheelResponse, Nothing, Nothing](alg.createFlywheel(flywheelName, dataAccessRoleArn, dataLakeS3Uri, activeModelArn, taskConfig, modelType, dataSecurityConfig, clientRequestToken, tags))
    def deleteDocumentClassifier(documentClassifierArn: DocumentClassifierArn): P1[DeleteDocumentClassifierRequest, ComprehendOperation.DeleteDocumentClassifierError, DeleteDocumentClassifierResponse, Nothing, Nothing] = f[DeleteDocumentClassifierRequest, ComprehendOperation.DeleteDocumentClassifierError, DeleteDocumentClassifierResponse, Nothing, Nothing](alg.deleteDocumentClassifier(documentClassifierArn))
    def deleteEndpoint(endpointArn: ComprehendEndpointArn): P1[DeleteEndpointRequest, ComprehendOperation.DeleteEndpointError, DeleteEndpointResponse, Nothing, Nothing] = f[DeleteEndpointRequest, ComprehendOperation.DeleteEndpointError, DeleteEndpointResponse, Nothing, Nothing](alg.deleteEndpoint(endpointArn))
    def deleteEntityRecognizer(entityRecognizerArn: EntityRecognizerArn): P1[DeleteEntityRecognizerRequest, ComprehendOperation.DeleteEntityRecognizerError, DeleteEntityRecognizerResponse, Nothing, Nothing] = f[DeleteEntityRecognizerRequest, ComprehendOperation.DeleteEntityRecognizerError, DeleteEntityRecognizerResponse, Nothing, Nothing](alg.deleteEntityRecognizer(entityRecognizerArn))
    def deleteFlywheel(flywheelArn: ComprehendFlywheelArn): P1[DeleteFlywheelRequest, ComprehendOperation.DeleteFlywheelError, DeleteFlywheelResponse, Nothing, Nothing] = f[DeleteFlywheelRequest, ComprehendOperation.DeleteFlywheelError, DeleteFlywheelResponse, Nothing, Nothing](alg.deleteFlywheel(flywheelArn))
    def deleteResourcePolicy(resourceArn: ComprehendModelArn, policyRevisionId: Option[PolicyRevisionId] = None): P1[DeleteResourcePolicyRequest, ComprehendOperation.DeleteResourcePolicyError, DeleteResourcePolicyResponse, Nothing, Nothing] = f[DeleteResourcePolicyRequest, ComprehendOperation.DeleteResourcePolicyError, DeleteResourcePolicyResponse, Nothing, Nothing](alg.deleteResourcePolicy(resourceArn, policyRevisionId))
    def describeDataset(datasetArn: ComprehendDatasetArn): P1[DescribeDatasetRequest, ComprehendOperation.DescribeDatasetError, DescribeDatasetResponse, Nothing, Nothing] = f[DescribeDatasetRequest, ComprehendOperation.DescribeDatasetError, DescribeDatasetResponse, Nothing, Nothing](alg.describeDataset(datasetArn))
    def describeDocumentClassificationJob(jobId: JobId): P1[DescribeDocumentClassificationJobRequest, ComprehendOperation.DescribeDocumentClassificationJobError, DescribeDocumentClassificationJobResponse, Nothing, Nothing] = f[DescribeDocumentClassificationJobRequest, ComprehendOperation.DescribeDocumentClassificationJobError, DescribeDocumentClassificationJobResponse, Nothing, Nothing](alg.describeDocumentClassificationJob(jobId))
    def describeDocumentClassifier(documentClassifierArn: DocumentClassifierArn): P1[DescribeDocumentClassifierRequest, ComprehendOperation.DescribeDocumentClassifierError, DescribeDocumentClassifierResponse, Nothing, Nothing] = f[DescribeDocumentClassifierRequest, ComprehendOperation.DescribeDocumentClassifierError, DescribeDocumentClassifierResponse, Nothing, Nothing](alg.describeDocumentClassifier(documentClassifierArn))
    def describeDominantLanguageDetectionJob(jobId: JobId): P1[DescribeDominantLanguageDetectionJobRequest, ComprehendOperation.DescribeDominantLanguageDetectionJobError, DescribeDominantLanguageDetectionJobResponse, Nothing, Nothing] = f[DescribeDominantLanguageDetectionJobRequest, ComprehendOperation.DescribeDominantLanguageDetectionJobError, DescribeDominantLanguageDetectionJobResponse, Nothing, Nothing](alg.describeDominantLanguageDetectionJob(jobId))
    def describeEndpoint(endpointArn: ComprehendEndpointArn): P1[DescribeEndpointRequest, ComprehendOperation.DescribeEndpointError, DescribeEndpointResponse, Nothing, Nothing] = f[DescribeEndpointRequest, ComprehendOperation.DescribeEndpointError, DescribeEndpointResponse, Nothing, Nothing](alg.describeEndpoint(endpointArn))
    def describeEntitiesDetectionJob(jobId: JobId): P1[DescribeEntitiesDetectionJobRequest, ComprehendOperation.DescribeEntitiesDetectionJobError, DescribeEntitiesDetectionJobResponse, Nothing, Nothing] = f[DescribeEntitiesDetectionJobRequest, ComprehendOperation.DescribeEntitiesDetectionJobError, DescribeEntitiesDetectionJobResponse, Nothing, Nothing](alg.describeEntitiesDetectionJob(jobId))
    def describeEntityRecognizer(entityRecognizerArn: EntityRecognizerArn): P1[DescribeEntityRecognizerRequest, ComprehendOperation.DescribeEntityRecognizerError, DescribeEntityRecognizerResponse, Nothing, Nothing] = f[DescribeEntityRecognizerRequest, ComprehendOperation.DescribeEntityRecognizerError, DescribeEntityRecognizerResponse, Nothing, Nothing](alg.describeEntityRecognizer(entityRecognizerArn))
    def describeEventsDetectionJob(jobId: JobId): P1[DescribeEventsDetectionJobRequest, ComprehendOperation.DescribeEventsDetectionJobError, DescribeEventsDetectionJobResponse, Nothing, Nothing] = f[DescribeEventsDetectionJobRequest, ComprehendOperation.DescribeEventsDetectionJobError, DescribeEventsDetectionJobResponse, Nothing, Nothing](alg.describeEventsDetectionJob(jobId))
    def describeFlywheel(flywheelArn: ComprehendFlywheelArn): P1[DescribeFlywheelRequest, ComprehendOperation.DescribeFlywheelError, DescribeFlywheelResponse, Nothing, Nothing] = f[DescribeFlywheelRequest, ComprehendOperation.DescribeFlywheelError, DescribeFlywheelResponse, Nothing, Nothing](alg.describeFlywheel(flywheelArn))
    def describeFlywheelIteration(flywheelArn: ComprehendFlywheelArn, flywheelIterationId: FlywheelIterationId): P1[DescribeFlywheelIterationRequest, ComprehendOperation.DescribeFlywheelIterationError, DescribeFlywheelIterationResponse, Nothing, Nothing] = f[DescribeFlywheelIterationRequest, ComprehendOperation.DescribeFlywheelIterationError, DescribeFlywheelIterationResponse, Nothing, Nothing](alg.describeFlywheelIteration(flywheelArn, flywheelIterationId))
    def describeKeyPhrasesDetectionJob(jobId: JobId): P1[DescribeKeyPhrasesDetectionJobRequest, ComprehendOperation.DescribeKeyPhrasesDetectionJobError, DescribeKeyPhrasesDetectionJobResponse, Nothing, Nothing] = f[DescribeKeyPhrasesDetectionJobRequest, ComprehendOperation.DescribeKeyPhrasesDetectionJobError, DescribeKeyPhrasesDetectionJobResponse, Nothing, Nothing](alg.describeKeyPhrasesDetectionJob(jobId))
    def describePiiEntitiesDetectionJob(jobId: JobId): P1[DescribePiiEntitiesDetectionJobRequest, ComprehendOperation.DescribePiiEntitiesDetectionJobError, DescribePiiEntitiesDetectionJobResponse, Nothing, Nothing] = f[DescribePiiEntitiesDetectionJobRequest, ComprehendOperation.DescribePiiEntitiesDetectionJobError, DescribePiiEntitiesDetectionJobResponse, Nothing, Nothing](alg.describePiiEntitiesDetectionJob(jobId))
    def describeResourcePolicy(resourceArn: ComprehendModelArn): P1[DescribeResourcePolicyRequest, ComprehendOperation.DescribeResourcePolicyError, DescribeResourcePolicyResponse, Nothing, Nothing] = f[DescribeResourcePolicyRequest, ComprehendOperation.DescribeResourcePolicyError, DescribeResourcePolicyResponse, Nothing, Nothing](alg.describeResourcePolicy(resourceArn))
    def describeSentimentDetectionJob(jobId: JobId): P1[DescribeSentimentDetectionJobRequest, ComprehendOperation.DescribeSentimentDetectionJobError, DescribeSentimentDetectionJobResponse, Nothing, Nothing] = f[DescribeSentimentDetectionJobRequest, ComprehendOperation.DescribeSentimentDetectionJobError, DescribeSentimentDetectionJobResponse, Nothing, Nothing](alg.describeSentimentDetectionJob(jobId))
    def describeTargetedSentimentDetectionJob(jobId: JobId): P1[DescribeTargetedSentimentDetectionJobRequest, ComprehendOperation.DescribeTargetedSentimentDetectionJobError, DescribeTargetedSentimentDetectionJobResponse, Nothing, Nothing] = f[DescribeTargetedSentimentDetectionJobRequest, ComprehendOperation.DescribeTargetedSentimentDetectionJobError, DescribeTargetedSentimentDetectionJobResponse, Nothing, Nothing](alg.describeTargetedSentimentDetectionJob(jobId))
    def describeTopicsDetectionJob(jobId: JobId): P1[DescribeTopicsDetectionJobRequest, ComprehendOperation.DescribeTopicsDetectionJobError, DescribeTopicsDetectionJobResponse, Nothing, Nothing] = f[DescribeTopicsDetectionJobRequest, ComprehendOperation.DescribeTopicsDetectionJobError, DescribeTopicsDetectionJobResponse, Nothing, Nothing](alg.describeTopicsDetectionJob(jobId))
    def detectDominantLanguage(text: CustomerInputString): P1[DetectDominantLanguageRequest, ComprehendOperation.DetectDominantLanguageError, DetectDominantLanguageResponse, Nothing, Nothing] = f[DetectDominantLanguageRequest, ComprehendOperation.DetectDominantLanguageError, DetectDominantLanguageResponse, Nothing, Nothing](alg.detectDominantLanguage(text))
    def detectEntities(text: Option[CustomerInputString] = None, languageCode: Option[LanguageCode] = None, endpointArn: Option[EntityRecognizerEndpointArn] = None, bytes: Option[SemiStructuredDocumentBlob] = None, documentReaderConfig: Option[DocumentReaderConfig] = None): P1[DetectEntitiesRequest, ComprehendOperation.DetectEntitiesError, DetectEntitiesResponse, Nothing, Nothing] = f[DetectEntitiesRequest, ComprehendOperation.DetectEntitiesError, DetectEntitiesResponse, Nothing, Nothing](alg.detectEntities(text, languageCode, endpointArn, bytes, documentReaderConfig))
    def detectKeyPhrases(text: CustomerInputString, languageCode: LanguageCode): P1[DetectKeyPhrasesRequest, ComprehendOperation.DetectKeyPhrasesError, DetectKeyPhrasesResponse, Nothing, Nothing] = f[DetectKeyPhrasesRequest, ComprehendOperation.DetectKeyPhrasesError, DetectKeyPhrasesResponse, Nothing, Nothing](alg.detectKeyPhrases(text, languageCode))
    def detectPiiEntities(text: String, languageCode: LanguageCode): P1[DetectPiiEntitiesRequest, ComprehendOperation.DetectPiiEntitiesError, DetectPiiEntitiesResponse, Nothing, Nothing] = f[DetectPiiEntitiesRequest, ComprehendOperation.DetectPiiEntitiesError, DetectPiiEntitiesResponse, Nothing, Nothing](alg.detectPiiEntities(text, languageCode))
    def detectSentiment(text: CustomerInputString, languageCode: LanguageCode): P1[DetectSentimentRequest, ComprehendOperation.DetectSentimentError, DetectSentimentResponse, Nothing, Nothing] = f[DetectSentimentRequest, ComprehendOperation.DetectSentimentError, DetectSentimentResponse, Nothing, Nothing](alg.detectSentiment(text, languageCode))
    def detectSyntax(text: CustomerInputString, languageCode: SyntaxLanguageCode): P1[DetectSyntaxRequest, ComprehendOperation.DetectSyntaxError, DetectSyntaxResponse, Nothing, Nothing] = f[DetectSyntaxRequest, ComprehendOperation.DetectSyntaxError, DetectSyntaxResponse, Nothing, Nothing](alg.detectSyntax(text, languageCode))
    def detectTargetedSentiment(text: CustomerInputString, languageCode: LanguageCode): P1[DetectTargetedSentimentRequest, ComprehendOperation.DetectTargetedSentimentError, DetectTargetedSentimentResponse, Nothing, Nothing] = f[DetectTargetedSentimentRequest, ComprehendOperation.DetectTargetedSentimentError, DetectTargetedSentimentResponse, Nothing, Nothing](alg.detectTargetedSentiment(text, languageCode))
    def importModel(sourceModelArn: ComprehendModelArn, modelName: Option[ComprehendArnName] = None, versionName: Option[VersionName] = None, modelKmsKeyId: Option[KmsKeyId] = None, dataAccessRoleArn: Option[IamRoleArn] = None, tags: Option[List[Tag]] = None): P1[ImportModelRequest, ComprehendOperation.ImportModelError, ImportModelResponse, Nothing, Nothing] = f[ImportModelRequest, ComprehendOperation.ImportModelError, ImportModelResponse, Nothing, Nothing](alg.importModel(sourceModelArn, modelName, versionName, modelKmsKeyId, dataAccessRoleArn, tags))
    def listDatasets(flywheelArn: Option[ComprehendFlywheelArn] = None, filter: Option[DatasetFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListDatasetsRequest, ComprehendOperation.ListDatasetsError, ListDatasetsResponse, Nothing, Nothing] = f[ListDatasetsRequest, ComprehendOperation.ListDatasetsError, ListDatasetsResponse, Nothing, Nothing](alg.listDatasets(flywheelArn, filter, nextToken, maxResults))
    def listDocumentClassificationJobs(filter: Option[DocumentClassificationJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListDocumentClassificationJobsRequest, ComprehendOperation.ListDocumentClassificationJobsError, ListDocumentClassificationJobsResponse, Nothing, Nothing] = f[ListDocumentClassificationJobsRequest, ComprehendOperation.ListDocumentClassificationJobsError, ListDocumentClassificationJobsResponse, Nothing, Nothing](alg.listDocumentClassificationJobs(filter, nextToken, maxResults))
    def listDocumentClassifiers(filter: Option[DocumentClassifierFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListDocumentClassifiersRequest, ComprehendOperation.ListDocumentClassifiersError, ListDocumentClassifiersResponse, Nothing, Nothing] = f[ListDocumentClassifiersRequest, ComprehendOperation.ListDocumentClassifiersError, ListDocumentClassifiersResponse, Nothing, Nothing](alg.listDocumentClassifiers(filter, nextToken, maxResults))
    def listDocumentClassifierSummaries(nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListDocumentClassifierSummariesRequest, ComprehendOperation.ListDocumentClassifierSummariesError, ListDocumentClassifierSummariesResponse, Nothing, Nothing] = f[ListDocumentClassifierSummariesRequest, ComprehendOperation.ListDocumentClassifierSummariesError, ListDocumentClassifierSummariesResponse, Nothing, Nothing](alg.listDocumentClassifierSummaries(nextToken, maxResults))
    def listDominantLanguageDetectionJobs(filter: Option[DominantLanguageDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListDominantLanguageDetectionJobsRequest, ComprehendOperation.ListDominantLanguageDetectionJobsError, ListDominantLanguageDetectionJobsResponse, Nothing, Nothing] = f[ListDominantLanguageDetectionJobsRequest, ComprehendOperation.ListDominantLanguageDetectionJobsError, ListDominantLanguageDetectionJobsResponse, Nothing, Nothing](alg.listDominantLanguageDetectionJobs(filter, nextToken, maxResults))
    def listEndpoints(filter: Option[EndpointFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListEndpointsRequest, ComprehendOperation.ListEndpointsError, ListEndpointsResponse, Nothing, Nothing] = f[ListEndpointsRequest, ComprehendOperation.ListEndpointsError, ListEndpointsResponse, Nothing, Nothing](alg.listEndpoints(filter, nextToken, maxResults))
    def listEntitiesDetectionJobs(filter: Option[EntitiesDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListEntitiesDetectionJobsRequest, ComprehendOperation.ListEntitiesDetectionJobsError, ListEntitiesDetectionJobsResponse, Nothing, Nothing] = f[ListEntitiesDetectionJobsRequest, ComprehendOperation.ListEntitiesDetectionJobsError, ListEntitiesDetectionJobsResponse, Nothing, Nothing](alg.listEntitiesDetectionJobs(filter, nextToken, maxResults))
    def listEntityRecognizers(filter: Option[EntityRecognizerFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListEntityRecognizersRequest, ComprehendOperation.ListEntityRecognizersError, ListEntityRecognizersResponse, Nothing, Nothing] = f[ListEntityRecognizersRequest, ComprehendOperation.ListEntityRecognizersError, ListEntityRecognizersResponse, Nothing, Nothing](alg.listEntityRecognizers(filter, nextToken, maxResults))
    def listEntityRecognizerSummaries(nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListEntityRecognizerSummariesRequest, ComprehendOperation.ListEntityRecognizerSummariesError, ListEntityRecognizerSummariesResponse, Nothing, Nothing] = f[ListEntityRecognizerSummariesRequest, ComprehendOperation.ListEntityRecognizerSummariesError, ListEntityRecognizerSummariesResponse, Nothing, Nothing](alg.listEntityRecognizerSummaries(nextToken, maxResults))
    def listEventsDetectionJobs(filter: Option[EventsDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListEventsDetectionJobsRequest, ComprehendOperation.ListEventsDetectionJobsError, ListEventsDetectionJobsResponse, Nothing, Nothing] = f[ListEventsDetectionJobsRequest, ComprehendOperation.ListEventsDetectionJobsError, ListEventsDetectionJobsResponse, Nothing, Nothing](alg.listEventsDetectionJobs(filter, nextToken, maxResults))
    def listFlywheelIterationHistory(flywheelArn: ComprehendFlywheelArn, filter: Option[FlywheelIterationFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListFlywheelIterationHistoryRequest, ComprehendOperation.ListFlywheelIterationHistoryError, ListFlywheelIterationHistoryResponse, Nothing, Nothing] = f[ListFlywheelIterationHistoryRequest, ComprehendOperation.ListFlywheelIterationHistoryError, ListFlywheelIterationHistoryResponse, Nothing, Nothing](alg.listFlywheelIterationHistory(flywheelArn, filter, nextToken, maxResults))
    def listFlywheels(filter: Option[FlywheelFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListFlywheelsRequest, ComprehendOperation.ListFlywheelsError, ListFlywheelsResponse, Nothing, Nothing] = f[ListFlywheelsRequest, ComprehendOperation.ListFlywheelsError, ListFlywheelsResponse, Nothing, Nothing](alg.listFlywheels(filter, nextToken, maxResults))
    def listKeyPhrasesDetectionJobs(filter: Option[KeyPhrasesDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListKeyPhrasesDetectionJobsRequest, ComprehendOperation.ListKeyPhrasesDetectionJobsError, ListKeyPhrasesDetectionJobsResponse, Nothing, Nothing] = f[ListKeyPhrasesDetectionJobsRequest, ComprehendOperation.ListKeyPhrasesDetectionJobsError, ListKeyPhrasesDetectionJobsResponse, Nothing, Nothing](alg.listKeyPhrasesDetectionJobs(filter, nextToken, maxResults))
    def listPiiEntitiesDetectionJobs(filter: Option[PiiEntitiesDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListPiiEntitiesDetectionJobsRequest, ComprehendOperation.ListPiiEntitiesDetectionJobsError, ListPiiEntitiesDetectionJobsResponse, Nothing, Nothing] = f[ListPiiEntitiesDetectionJobsRequest, ComprehendOperation.ListPiiEntitiesDetectionJobsError, ListPiiEntitiesDetectionJobsResponse, Nothing, Nothing](alg.listPiiEntitiesDetectionJobs(filter, nextToken, maxResults))
    def listSentimentDetectionJobs(filter: Option[SentimentDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListSentimentDetectionJobsRequest, ComprehendOperation.ListSentimentDetectionJobsError, ListSentimentDetectionJobsResponse, Nothing, Nothing] = f[ListSentimentDetectionJobsRequest, ComprehendOperation.ListSentimentDetectionJobsError, ListSentimentDetectionJobsResponse, Nothing, Nothing](alg.listSentimentDetectionJobs(filter, nextToken, maxResults))
    def listTagsForResource(resourceArn: ComprehendArn): P1[ListTagsForResourceRequest, ComprehendOperation.ListTagsForResourceError, ListTagsForResourceResponse, Nothing, Nothing] = f[ListTagsForResourceRequest, ComprehendOperation.ListTagsForResourceError, ListTagsForResourceResponse, Nothing, Nothing](alg.listTagsForResource(resourceArn))
    def listTargetedSentimentDetectionJobs(filter: Option[TargetedSentimentDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListTargetedSentimentDetectionJobsRequest, ComprehendOperation.ListTargetedSentimentDetectionJobsError, ListTargetedSentimentDetectionJobsResponse, Nothing, Nothing] = f[ListTargetedSentimentDetectionJobsRequest, ComprehendOperation.ListTargetedSentimentDetectionJobsError, ListTargetedSentimentDetectionJobsResponse, Nothing, Nothing](alg.listTargetedSentimentDetectionJobs(filter, nextToken, maxResults))
    def listTopicsDetectionJobs(filter: Option[TopicsDetectionJobFilter] = None, nextToken: Option[String] = None, maxResults: Option[MaxResultsInteger] = None): P1[ListTopicsDetectionJobsRequest, ComprehendOperation.ListTopicsDetectionJobsError, ListTopicsDetectionJobsResponse, Nothing, Nothing] = f[ListTopicsDetectionJobsRequest, ComprehendOperation.ListTopicsDetectionJobsError, ListTopicsDetectionJobsResponse, Nothing, Nothing](alg.listTopicsDetectionJobs(filter, nextToken, maxResults))
    def putResourcePolicy(resourceArn: ComprehendModelArn, resourcePolicy: Policy, policyRevisionId: Option[PolicyRevisionId] = None): P1[PutResourcePolicyRequest, ComprehendOperation.PutResourcePolicyError, PutResourcePolicyResponse, Nothing, Nothing] = f[PutResourcePolicyRequest, ComprehendOperation.PutResourcePolicyError, PutResourcePolicyResponse, Nothing, Nothing](alg.putResourcePolicy(resourceArn, resourcePolicy, policyRevisionId))
    def startDocumentClassificationJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, jobName: Option[JobName] = None, documentClassifierArn: Option[DocumentClassifierArn] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): P1[StartDocumentClassificationJobRequest, ComprehendOperation.StartDocumentClassificationJobError, StartDocumentClassificationJobResponse, Nothing, Nothing] = f[StartDocumentClassificationJobRequest, ComprehendOperation.StartDocumentClassificationJobError, StartDocumentClassificationJobResponse, Nothing, Nothing](alg.startDocumentClassificationJob(inputDataConfig, outputDataConfig, dataAccessRoleArn, jobName, documentClassifierArn, clientRequestToken, volumeKmsKeyId, vpcConfig, tags, flywheelArn))
    def startDominantLanguageDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): P1[StartDominantLanguageDetectionJobRequest, ComprehendOperation.StartDominantLanguageDetectionJobError, StartDominantLanguageDetectionJobResponse, Nothing, Nothing] = f[StartDominantLanguageDetectionJobRequest, ComprehendOperation.StartDominantLanguageDetectionJobError, StartDominantLanguageDetectionJobResponse, Nothing, Nothing](alg.startDominantLanguageDetectionJob(inputDataConfig, outputDataConfig, dataAccessRoleArn, jobName, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def startEntitiesDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, entityRecognizerArn: Option[EntityRecognizerArn] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): P1[StartEntitiesDetectionJobRequest, ComprehendOperation.StartEntitiesDetectionJobError, StartEntitiesDetectionJobResponse, Nothing, Nothing] = f[StartEntitiesDetectionJobRequest, ComprehendOperation.StartEntitiesDetectionJobError, StartEntitiesDetectionJobResponse, Nothing, Nothing](alg.startEntitiesDetectionJob(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, jobName, entityRecognizerArn, clientRequestToken, volumeKmsKeyId, vpcConfig, tags, flywheelArn))
    def startEventsDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, targetEventTypes: List[EventTypeString], jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): P1[StartEventsDetectionJobRequest, ComprehendOperation.StartEventsDetectionJobError, StartEventsDetectionJobResponse, Nothing, Nothing] = f[StartEventsDetectionJobRequest, ComprehendOperation.StartEventsDetectionJobError, StartEventsDetectionJobResponse, Nothing, Nothing](alg.startEventsDetectionJob(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, targetEventTypes, jobName, clientRequestToken, tags))
    def startFlywheelIteration(flywheelArn: ComprehendFlywheelArn, clientRequestToken: Option[ClientRequestTokenString] = None): P1[StartFlywheelIterationRequest, ComprehendOperation.StartFlywheelIterationError, StartFlywheelIterationResponse, Nothing, Nothing] = f[StartFlywheelIterationRequest, ComprehendOperation.StartFlywheelIterationError, StartFlywheelIterationResponse, Nothing, Nothing](alg.startFlywheelIteration(flywheelArn, clientRequestToken))
    def startKeyPhrasesDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): P1[StartKeyPhrasesDetectionJobRequest, ComprehendOperation.StartKeyPhrasesDetectionJobError, StartKeyPhrasesDetectionJobResponse, Nothing, Nothing] = f[StartKeyPhrasesDetectionJobRequest, ComprehendOperation.StartKeyPhrasesDetectionJobError, StartKeyPhrasesDetectionJobResponse, Nothing, Nothing](alg.startKeyPhrasesDetectionJob(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, jobName, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def startPiiEntitiesDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, mode: PiiEntitiesDetectionMode, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, redactionConfig: Option[RedactionConfig] = None, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, tags: Option[List[Tag]] = None): P1[StartPiiEntitiesDetectionJobRequest, ComprehendOperation.StartPiiEntitiesDetectionJobError, StartPiiEntitiesDetectionJobResponse, Nothing, Nothing] = f[StartPiiEntitiesDetectionJobRequest, ComprehendOperation.StartPiiEntitiesDetectionJobError, StartPiiEntitiesDetectionJobResponse, Nothing, Nothing](alg.startPiiEntitiesDetectionJob(inputDataConfig, outputDataConfig, mode, dataAccessRoleArn, languageCode, redactionConfig, jobName, clientRequestToken, tags))
    def startSentimentDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): P1[StartSentimentDetectionJobRequest, ComprehendOperation.StartSentimentDetectionJobError, StartSentimentDetectionJobResponse, Nothing, Nothing] = f[StartSentimentDetectionJobRequest, ComprehendOperation.StartSentimentDetectionJobError, StartSentimentDetectionJobResponse, Nothing, Nothing](alg.startSentimentDetectionJob(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, jobName, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def startTargetedSentimentDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, languageCode: LanguageCode, jobName: Option[JobName] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): P1[StartTargetedSentimentDetectionJobRequest, ComprehendOperation.StartTargetedSentimentDetectionJobError, StartTargetedSentimentDetectionJobResponse, Nothing, Nothing] = f[StartTargetedSentimentDetectionJobRequest, ComprehendOperation.StartTargetedSentimentDetectionJobError, StartTargetedSentimentDetectionJobResponse, Nothing, Nothing](alg.startTargetedSentimentDetectionJob(inputDataConfig, outputDataConfig, dataAccessRoleArn, languageCode, jobName, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def startTopicsDetectionJob(inputDataConfig: InputDataConfig, outputDataConfig: OutputDataConfig, dataAccessRoleArn: IamRoleArn, jobName: Option[JobName] = None, numberOfTopics: Option[NumberOfTopicsInteger] = None, clientRequestToken: Option[ClientRequestTokenString] = None, volumeKmsKeyId: Option[KmsKeyId] = None, vpcConfig: Option[VpcConfig] = None, tags: Option[List[Tag]] = None): P1[StartTopicsDetectionJobRequest, ComprehendOperation.StartTopicsDetectionJobError, StartTopicsDetectionJobResponse, Nothing, Nothing] = f[StartTopicsDetectionJobRequest, ComprehendOperation.StartTopicsDetectionJobError, StartTopicsDetectionJobResponse, Nothing, Nothing](alg.startTopicsDetectionJob(inputDataConfig, outputDataConfig, dataAccessRoleArn, jobName, numberOfTopics, clientRequestToken, volumeKmsKeyId, vpcConfig, tags))
    def stopDominantLanguageDetectionJob(jobId: JobId): P1[StopDominantLanguageDetectionJobRequest, ComprehendOperation.StopDominantLanguageDetectionJobError, StopDominantLanguageDetectionJobResponse, Nothing, Nothing] = f[StopDominantLanguageDetectionJobRequest, ComprehendOperation.StopDominantLanguageDetectionJobError, StopDominantLanguageDetectionJobResponse, Nothing, Nothing](alg.stopDominantLanguageDetectionJob(jobId))
    def stopEntitiesDetectionJob(jobId: JobId): P1[StopEntitiesDetectionJobRequest, ComprehendOperation.StopEntitiesDetectionJobError, StopEntitiesDetectionJobResponse, Nothing, Nothing] = f[StopEntitiesDetectionJobRequest, ComprehendOperation.StopEntitiesDetectionJobError, StopEntitiesDetectionJobResponse, Nothing, Nothing](alg.stopEntitiesDetectionJob(jobId))
    def stopEventsDetectionJob(jobId: JobId): P1[StopEventsDetectionJobRequest, ComprehendOperation.StopEventsDetectionJobError, StopEventsDetectionJobResponse, Nothing, Nothing] = f[StopEventsDetectionJobRequest, ComprehendOperation.StopEventsDetectionJobError, StopEventsDetectionJobResponse, Nothing, Nothing](alg.stopEventsDetectionJob(jobId))
    def stopKeyPhrasesDetectionJob(jobId: JobId): P1[StopKeyPhrasesDetectionJobRequest, ComprehendOperation.StopKeyPhrasesDetectionJobError, StopKeyPhrasesDetectionJobResponse, Nothing, Nothing] = f[StopKeyPhrasesDetectionJobRequest, ComprehendOperation.StopKeyPhrasesDetectionJobError, StopKeyPhrasesDetectionJobResponse, Nothing, Nothing](alg.stopKeyPhrasesDetectionJob(jobId))
    def stopPiiEntitiesDetectionJob(jobId: JobId): P1[StopPiiEntitiesDetectionJobRequest, ComprehendOperation.StopPiiEntitiesDetectionJobError, StopPiiEntitiesDetectionJobResponse, Nothing, Nothing] = f[StopPiiEntitiesDetectionJobRequest, ComprehendOperation.StopPiiEntitiesDetectionJobError, StopPiiEntitiesDetectionJobResponse, Nothing, Nothing](alg.stopPiiEntitiesDetectionJob(jobId))
    def stopSentimentDetectionJob(jobId: JobId): P1[StopSentimentDetectionJobRequest, ComprehendOperation.StopSentimentDetectionJobError, StopSentimentDetectionJobResponse, Nothing, Nothing] = f[StopSentimentDetectionJobRequest, ComprehendOperation.StopSentimentDetectionJobError, StopSentimentDetectionJobResponse, Nothing, Nothing](alg.stopSentimentDetectionJob(jobId))
    def stopTargetedSentimentDetectionJob(jobId: JobId): P1[StopTargetedSentimentDetectionJobRequest, ComprehendOperation.StopTargetedSentimentDetectionJobError, StopTargetedSentimentDetectionJobResponse, Nothing, Nothing] = f[StopTargetedSentimentDetectionJobRequest, ComprehendOperation.StopTargetedSentimentDetectionJobError, StopTargetedSentimentDetectionJobResponse, Nothing, Nothing](alg.stopTargetedSentimentDetectionJob(jobId))
    def stopTrainingDocumentClassifier(documentClassifierArn: DocumentClassifierArn): P1[StopTrainingDocumentClassifierRequest, ComprehendOperation.StopTrainingDocumentClassifierError, StopTrainingDocumentClassifierResponse, Nothing, Nothing] = f[StopTrainingDocumentClassifierRequest, ComprehendOperation.StopTrainingDocumentClassifierError, StopTrainingDocumentClassifierResponse, Nothing, Nothing](alg.stopTrainingDocumentClassifier(documentClassifierArn))
    def stopTrainingEntityRecognizer(entityRecognizerArn: EntityRecognizerArn): P1[StopTrainingEntityRecognizerRequest, ComprehendOperation.StopTrainingEntityRecognizerError, StopTrainingEntityRecognizerResponse, Nothing, Nothing] = f[StopTrainingEntityRecognizerRequest, ComprehendOperation.StopTrainingEntityRecognizerError, StopTrainingEntityRecognizerResponse, Nothing, Nothing](alg.stopTrainingEntityRecognizer(entityRecognizerArn))
    def tagResource(resourceArn: ComprehendArn, tags: List[Tag]): P1[TagResourceRequest, ComprehendOperation.TagResourceError, TagResourceResponse, Nothing, Nothing] = f[TagResourceRequest, ComprehendOperation.TagResourceError, TagResourceResponse, Nothing, Nothing](alg.tagResource(resourceArn, tags))
    def untagResource(resourceArn: ComprehendArn, tagKeys: List[TagKey]): P1[UntagResourceRequest, ComprehendOperation.UntagResourceError, UntagResourceResponse, Nothing, Nothing] = f[UntagResourceRequest, ComprehendOperation.UntagResourceError, UntagResourceResponse, Nothing, Nothing](alg.untagResource(resourceArn, tagKeys))
    def updateEndpoint(endpointArn: ComprehendEndpointArn, desiredModelArn: Option[ComprehendModelArn] = None, desiredInferenceUnits: Option[InferenceUnitsInteger] = None, desiredDataAccessRoleArn: Option[IamRoleArn] = None, flywheelArn: Option[ComprehendFlywheelArn] = None): P1[UpdateEndpointRequest, ComprehendOperation.UpdateEndpointError, UpdateEndpointResponse, Nothing, Nothing] = f[UpdateEndpointRequest, ComprehendOperation.UpdateEndpointError, UpdateEndpointResponse, Nothing, Nothing](alg.updateEndpoint(endpointArn, desiredModelArn, desiredInferenceUnits, desiredDataAccessRoleArn, flywheelArn))
    def updateFlywheel(flywheelArn: ComprehendFlywheelArn, activeModelArn: Option[ComprehendModelArn] = None, dataAccessRoleArn: Option[IamRoleArn] = None, dataSecurityConfig: Option[UpdateDataSecurityConfig] = None): P1[UpdateFlywheelRequest, ComprehendOperation.UpdateFlywheelError, UpdateFlywheelResponse, Nothing, Nothing] = f[UpdateFlywheelRequest, ComprehendOperation.UpdateFlywheelError, UpdateFlywheelResponse, Nothing, Nothing](alg.updateFlywheel(flywheelArn, activeModelArn, dataAccessRoleArn, dataSecurityConfig))
  }

  def toPolyFunction[P[_, _, _, _, _]](impl: ComprehendGen[P]): PolyFunction5[ComprehendOperation, P] = new PolyFunction5[ComprehendOperation, P] {
    def apply[I, E, O, SI, SO](op: ComprehendOperation[I, E, O, SI, SO]): P[I, E, O, SI, SO] = op.run(impl) 
  }
  final case class BatchDetectDominantLanguage(input: BatchDetectDominantLanguageRequest) extends ComprehendOperation[BatchDetectDominantLanguageRequest, ComprehendOperation.BatchDetectDominantLanguageError, BatchDetectDominantLanguageResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[BatchDetectDominantLanguageRequest, ComprehendOperation.BatchDetectDominantLanguageError, BatchDetectDominantLanguageResponse, Nothing, Nothing] = impl.batchDetectDominantLanguage(input.textList)
    def ordinal: Int = 0
    def endpoint: smithy4s.Endpoint[ComprehendOperation,BatchDetectDominantLanguageRequest, ComprehendOperation.BatchDetectDominantLanguageError, BatchDetectDominantLanguageResponse, Nothing, Nothing] = BatchDetectDominantLanguage
  }
  object BatchDetectDominantLanguage extends smithy4s.Endpoint[ComprehendOperation,BatchDetectDominantLanguageRequest, ComprehendOperation.BatchDetectDominantLanguageError, BatchDetectDominantLanguageResponse, Nothing, Nothing] {
    val schema: OperationSchema[BatchDetectDominantLanguageRequest, ComprehendOperation.BatchDetectDominantLanguageError, BatchDetectDominantLanguageResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "BatchDetectDominantLanguage"))
      .withInput(BatchDetectDominantLanguageRequest.schema)
      .withError(BatchDetectDominantLanguageError.errorSchema)
      .withOutput(BatchDetectDominantLanguageResponse.schema)
      .withHints(smithy.api.Documentation("<p>Determines the dominant language of the input text for a batch of documents. For a list\n      of languages that Amazon Comprehend can detect, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/how-languages.html\">Amazon Comprehend Supported Languages</a>.\n    </p>"))
    def wrap(input: BatchDetectDominantLanguageRequest): BatchDetectDominantLanguage = BatchDetectDominantLanguage(input)
  }
  sealed trait BatchDetectDominantLanguageError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: BatchDetectDominantLanguageError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = BatchDetectDominantLanguageError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def batchSizeLimitExceededException: Option[BatchSizeLimitExceededException] = BatchDetectDominantLanguageError.BatchSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.batchSizeLimitExceededException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = BatchDetectDominantLanguageError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = BatchDetectDominantLanguageError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: BatchDetectDominantLanguageError.Visitor[A]): A = this match {
      case value: BatchDetectDominantLanguageError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: BatchDetectDominantLanguageError.BatchSizeLimitExceededExceptionCase => visitor.batchSizeLimitExceededException(value.batchSizeLimitExceededException)
      case value: BatchDetectDominantLanguageError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: BatchDetectDominantLanguageError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object BatchDetectDominantLanguageError extends ErrorSchema.Companion[BatchDetectDominantLanguageError] {

    def internalServerException(internalServerException: InternalServerException): BatchDetectDominantLanguageError = InternalServerExceptionCase(internalServerException)
    def batchSizeLimitExceededException(batchSizeLimitExceededException: BatchSizeLimitExceededException): BatchDetectDominantLanguageError = BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): BatchDetectDominantLanguageError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): BatchDetectDominantLanguageError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "BatchDetectDominantLanguageError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends BatchDetectDominantLanguageError { final def $ordinal: Int = 0 }
    final case class BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException: BatchSizeLimitExceededException) extends BatchDetectDominantLanguageError { final def $ordinal: Int = 1 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends BatchDetectDominantLanguageError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends BatchDetectDominantLanguageError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectDominantLanguageError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), BatchDetectDominantLanguageError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[BatchDetectDominantLanguageError]("InternalServerException")
    }
    object BatchSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectDominantLanguageError.BatchSizeLimitExceededExceptionCase] = bijection(BatchSizeLimitExceededException.schema.addHints(hints), BatchDetectDominantLanguageError.BatchSizeLimitExceededExceptionCase(_), _.batchSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectDominantLanguageError]("BatchSizeLimitExceededException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectDominantLanguageError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), BatchDetectDominantLanguageError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectDominantLanguageError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectDominantLanguageError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), BatchDetectDominantLanguageError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[BatchDetectDominantLanguageError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[BatchDetectDominantLanguageError] = union(
      BatchDetectDominantLanguageError.InternalServerExceptionCase.alt,
      BatchDetectDominantLanguageError.BatchSizeLimitExceededExceptionCase.alt,
      BatchDetectDominantLanguageError.TextSizeLimitExceededExceptionCase.alt,
      BatchDetectDominantLanguageError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[BatchDetectDominantLanguageError] = throwable match {
      case e: InternalServerException => Some(BatchDetectDominantLanguageError.InternalServerExceptionCase(e))
      case e: BatchSizeLimitExceededException => Some(BatchDetectDominantLanguageError.BatchSizeLimitExceededExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(BatchDetectDominantLanguageError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(BatchDetectDominantLanguageError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: BatchDetectDominantLanguageError): Throwable = e match {
      case BatchDetectDominantLanguageError.InternalServerExceptionCase(e) => e
      case BatchDetectDominantLanguageError.BatchSizeLimitExceededExceptionCase(e) => e
      case BatchDetectDominantLanguageError.TextSizeLimitExceededExceptionCase(e) => e
      case BatchDetectDominantLanguageError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class BatchDetectEntities(input: BatchDetectEntitiesRequest) extends ComprehendOperation[BatchDetectEntitiesRequest, ComprehendOperation.BatchDetectEntitiesError, BatchDetectEntitiesResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[BatchDetectEntitiesRequest, ComprehendOperation.BatchDetectEntitiesError, BatchDetectEntitiesResponse, Nothing, Nothing] = impl.batchDetectEntities(input.textList, input.languageCode)
    def ordinal: Int = 1
    def endpoint: smithy4s.Endpoint[ComprehendOperation,BatchDetectEntitiesRequest, ComprehendOperation.BatchDetectEntitiesError, BatchDetectEntitiesResponse, Nothing, Nothing] = BatchDetectEntities
  }
  object BatchDetectEntities extends smithy4s.Endpoint[ComprehendOperation,BatchDetectEntitiesRequest, ComprehendOperation.BatchDetectEntitiesError, BatchDetectEntitiesResponse, Nothing, Nothing] {
    val schema: OperationSchema[BatchDetectEntitiesRequest, ComprehendOperation.BatchDetectEntitiesError, BatchDetectEntitiesResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "BatchDetectEntities"))
      .withInput(BatchDetectEntitiesRequest.schema)
      .withError(BatchDetectEntitiesError.errorSchema)
      .withOutput(BatchDetectEntitiesResponse.schema)
      .withHints(smithy.api.Documentation("<p>Inspects the text of a batch of documents for named entities and returns information\n      about them. For more information about named entities, see\n      <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/how-entities.html\">Entities</a> in the Comprehend Developer Guide.\n    </p>"))
    def wrap(input: BatchDetectEntitiesRequest): BatchDetectEntities = BatchDetectEntities(input)
  }
  sealed trait BatchDetectEntitiesError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: BatchDetectEntitiesError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = BatchDetectEntitiesError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def batchSizeLimitExceededException: Option[BatchSizeLimitExceededException] = BatchDetectEntitiesError.BatchSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.batchSizeLimitExceededException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = BatchDetectEntitiesError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = BatchDetectEntitiesError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = BatchDetectEntitiesError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: BatchDetectEntitiesError.Visitor[A]): A = this match {
      case value: BatchDetectEntitiesError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: BatchDetectEntitiesError.BatchSizeLimitExceededExceptionCase => visitor.batchSizeLimitExceededException(value.batchSizeLimitExceededException)
      case value: BatchDetectEntitiesError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: BatchDetectEntitiesError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: BatchDetectEntitiesError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object BatchDetectEntitiesError extends ErrorSchema.Companion[BatchDetectEntitiesError] {

    def internalServerException(internalServerException: InternalServerException): BatchDetectEntitiesError = InternalServerExceptionCase(internalServerException)
    def batchSizeLimitExceededException(batchSizeLimitExceededException: BatchSizeLimitExceededException): BatchDetectEntitiesError = BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): BatchDetectEntitiesError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): BatchDetectEntitiesError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): BatchDetectEntitiesError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "BatchDetectEntitiesError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends BatchDetectEntitiesError { final def $ordinal: Int = 0 }
    final case class BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException: BatchSizeLimitExceededException) extends BatchDetectEntitiesError { final def $ordinal: Int = 1 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends BatchDetectEntitiesError { final def $ordinal: Int = 2 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends BatchDetectEntitiesError { final def $ordinal: Int = 3 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends BatchDetectEntitiesError { final def $ordinal: Int = 4 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectEntitiesError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), BatchDetectEntitiesError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[BatchDetectEntitiesError]("InternalServerException")
    }
    object BatchSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectEntitiesError.BatchSizeLimitExceededExceptionCase] = bijection(BatchSizeLimitExceededException.schema.addHints(hints), BatchDetectEntitiesError.BatchSizeLimitExceededExceptionCase(_), _.batchSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectEntitiesError]("BatchSizeLimitExceededException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectEntitiesError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), BatchDetectEntitiesError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[BatchDetectEntitiesError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectEntitiesError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), BatchDetectEntitiesError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectEntitiesError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectEntitiesError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), BatchDetectEntitiesError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[BatchDetectEntitiesError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[BatchDetectEntitiesError] = union(
      BatchDetectEntitiesError.InternalServerExceptionCase.alt,
      BatchDetectEntitiesError.BatchSizeLimitExceededExceptionCase.alt,
      BatchDetectEntitiesError.UnsupportedLanguageExceptionCase.alt,
      BatchDetectEntitiesError.TextSizeLimitExceededExceptionCase.alt,
      BatchDetectEntitiesError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[BatchDetectEntitiesError] = throwable match {
      case e: InternalServerException => Some(BatchDetectEntitiesError.InternalServerExceptionCase(e))
      case e: BatchSizeLimitExceededException => Some(BatchDetectEntitiesError.BatchSizeLimitExceededExceptionCase(e))
      case e: UnsupportedLanguageException => Some(BatchDetectEntitiesError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(BatchDetectEntitiesError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(BatchDetectEntitiesError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: BatchDetectEntitiesError): Throwable = e match {
      case BatchDetectEntitiesError.InternalServerExceptionCase(e) => e
      case BatchDetectEntitiesError.BatchSizeLimitExceededExceptionCase(e) => e
      case BatchDetectEntitiesError.UnsupportedLanguageExceptionCase(e) => e
      case BatchDetectEntitiesError.TextSizeLimitExceededExceptionCase(e) => e
      case BatchDetectEntitiesError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class BatchDetectKeyPhrases(input: BatchDetectKeyPhrasesRequest) extends ComprehendOperation[BatchDetectKeyPhrasesRequest, ComprehendOperation.BatchDetectKeyPhrasesError, BatchDetectKeyPhrasesResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[BatchDetectKeyPhrasesRequest, ComprehendOperation.BatchDetectKeyPhrasesError, BatchDetectKeyPhrasesResponse, Nothing, Nothing] = impl.batchDetectKeyPhrases(input.textList, input.languageCode)
    def ordinal: Int = 2
    def endpoint: smithy4s.Endpoint[ComprehendOperation,BatchDetectKeyPhrasesRequest, ComprehendOperation.BatchDetectKeyPhrasesError, BatchDetectKeyPhrasesResponse, Nothing, Nothing] = BatchDetectKeyPhrases
  }
  object BatchDetectKeyPhrases extends smithy4s.Endpoint[ComprehendOperation,BatchDetectKeyPhrasesRequest, ComprehendOperation.BatchDetectKeyPhrasesError, BatchDetectKeyPhrasesResponse, Nothing, Nothing] {
    val schema: OperationSchema[BatchDetectKeyPhrasesRequest, ComprehendOperation.BatchDetectKeyPhrasesError, BatchDetectKeyPhrasesResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "BatchDetectKeyPhrases"))
      .withInput(BatchDetectKeyPhrasesRequest.schema)
      .withError(BatchDetectKeyPhrasesError.errorSchema)
      .withOutput(BatchDetectKeyPhrasesResponse.schema)
      .withHints(smithy.api.Documentation("<p>Detects the key noun phrases found in a batch of documents.</p>"))
    def wrap(input: BatchDetectKeyPhrasesRequest): BatchDetectKeyPhrases = BatchDetectKeyPhrases(input)
  }
  sealed trait BatchDetectKeyPhrasesError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: BatchDetectKeyPhrasesError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = BatchDetectKeyPhrasesError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def batchSizeLimitExceededException: Option[BatchSizeLimitExceededException] = BatchDetectKeyPhrasesError.BatchSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.batchSizeLimitExceededException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = BatchDetectKeyPhrasesError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = BatchDetectKeyPhrasesError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = BatchDetectKeyPhrasesError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: BatchDetectKeyPhrasesError.Visitor[A]): A = this match {
      case value: BatchDetectKeyPhrasesError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: BatchDetectKeyPhrasesError.BatchSizeLimitExceededExceptionCase => visitor.batchSizeLimitExceededException(value.batchSizeLimitExceededException)
      case value: BatchDetectKeyPhrasesError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: BatchDetectKeyPhrasesError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: BatchDetectKeyPhrasesError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object BatchDetectKeyPhrasesError extends ErrorSchema.Companion[BatchDetectKeyPhrasesError] {

    def internalServerException(internalServerException: InternalServerException): BatchDetectKeyPhrasesError = InternalServerExceptionCase(internalServerException)
    def batchSizeLimitExceededException(batchSizeLimitExceededException: BatchSizeLimitExceededException): BatchDetectKeyPhrasesError = BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): BatchDetectKeyPhrasesError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): BatchDetectKeyPhrasesError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): BatchDetectKeyPhrasesError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "BatchDetectKeyPhrasesError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends BatchDetectKeyPhrasesError { final def $ordinal: Int = 0 }
    final case class BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException: BatchSizeLimitExceededException) extends BatchDetectKeyPhrasesError { final def $ordinal: Int = 1 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends BatchDetectKeyPhrasesError { final def $ordinal: Int = 2 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends BatchDetectKeyPhrasesError { final def $ordinal: Int = 3 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends BatchDetectKeyPhrasesError { final def $ordinal: Int = 4 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectKeyPhrasesError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), BatchDetectKeyPhrasesError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[BatchDetectKeyPhrasesError]("InternalServerException")
    }
    object BatchSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectKeyPhrasesError.BatchSizeLimitExceededExceptionCase] = bijection(BatchSizeLimitExceededException.schema.addHints(hints), BatchDetectKeyPhrasesError.BatchSizeLimitExceededExceptionCase(_), _.batchSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectKeyPhrasesError]("BatchSizeLimitExceededException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectKeyPhrasesError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), BatchDetectKeyPhrasesError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[BatchDetectKeyPhrasesError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectKeyPhrasesError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), BatchDetectKeyPhrasesError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectKeyPhrasesError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectKeyPhrasesError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), BatchDetectKeyPhrasesError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[BatchDetectKeyPhrasesError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[BatchDetectKeyPhrasesError] = union(
      BatchDetectKeyPhrasesError.InternalServerExceptionCase.alt,
      BatchDetectKeyPhrasesError.BatchSizeLimitExceededExceptionCase.alt,
      BatchDetectKeyPhrasesError.UnsupportedLanguageExceptionCase.alt,
      BatchDetectKeyPhrasesError.TextSizeLimitExceededExceptionCase.alt,
      BatchDetectKeyPhrasesError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[BatchDetectKeyPhrasesError] = throwable match {
      case e: InternalServerException => Some(BatchDetectKeyPhrasesError.InternalServerExceptionCase(e))
      case e: BatchSizeLimitExceededException => Some(BatchDetectKeyPhrasesError.BatchSizeLimitExceededExceptionCase(e))
      case e: UnsupportedLanguageException => Some(BatchDetectKeyPhrasesError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(BatchDetectKeyPhrasesError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(BatchDetectKeyPhrasesError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: BatchDetectKeyPhrasesError): Throwable = e match {
      case BatchDetectKeyPhrasesError.InternalServerExceptionCase(e) => e
      case BatchDetectKeyPhrasesError.BatchSizeLimitExceededExceptionCase(e) => e
      case BatchDetectKeyPhrasesError.UnsupportedLanguageExceptionCase(e) => e
      case BatchDetectKeyPhrasesError.TextSizeLimitExceededExceptionCase(e) => e
      case BatchDetectKeyPhrasesError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class BatchDetectSentiment(input: BatchDetectSentimentRequest) extends ComprehendOperation[BatchDetectSentimentRequest, ComprehendOperation.BatchDetectSentimentError, BatchDetectSentimentResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[BatchDetectSentimentRequest, ComprehendOperation.BatchDetectSentimentError, BatchDetectSentimentResponse, Nothing, Nothing] = impl.batchDetectSentiment(input.textList, input.languageCode)
    def ordinal: Int = 3
    def endpoint: smithy4s.Endpoint[ComprehendOperation,BatchDetectSentimentRequest, ComprehendOperation.BatchDetectSentimentError, BatchDetectSentimentResponse, Nothing, Nothing] = BatchDetectSentiment
  }
  object BatchDetectSentiment extends smithy4s.Endpoint[ComprehendOperation,BatchDetectSentimentRequest, ComprehendOperation.BatchDetectSentimentError, BatchDetectSentimentResponse, Nothing, Nothing] {
    val schema: OperationSchema[BatchDetectSentimentRequest, ComprehendOperation.BatchDetectSentimentError, BatchDetectSentimentResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "BatchDetectSentiment"))
      .withInput(BatchDetectSentimentRequest.schema)
      .withError(BatchDetectSentimentError.errorSchema)
      .withOutput(BatchDetectSentimentResponse.schema)
      .withHints(smithy.api.Documentation("<p>Inspects a batch of documents and returns an inference of the prevailing sentiment,\n        <code>POSITIVE</code>, <code>NEUTRAL</code>, <code>MIXED</code>, or <code>NEGATIVE</code>,\n      in each one.</p>"))
    def wrap(input: BatchDetectSentimentRequest): BatchDetectSentiment = BatchDetectSentiment(input)
  }
  sealed trait BatchDetectSentimentError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: BatchDetectSentimentError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = BatchDetectSentimentError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def batchSizeLimitExceededException: Option[BatchSizeLimitExceededException] = BatchDetectSentimentError.BatchSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.batchSizeLimitExceededException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = BatchDetectSentimentError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = BatchDetectSentimentError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = BatchDetectSentimentError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: BatchDetectSentimentError.Visitor[A]): A = this match {
      case value: BatchDetectSentimentError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: BatchDetectSentimentError.BatchSizeLimitExceededExceptionCase => visitor.batchSizeLimitExceededException(value.batchSizeLimitExceededException)
      case value: BatchDetectSentimentError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: BatchDetectSentimentError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: BatchDetectSentimentError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object BatchDetectSentimentError extends ErrorSchema.Companion[BatchDetectSentimentError] {

    def internalServerException(internalServerException: InternalServerException): BatchDetectSentimentError = InternalServerExceptionCase(internalServerException)
    def batchSizeLimitExceededException(batchSizeLimitExceededException: BatchSizeLimitExceededException): BatchDetectSentimentError = BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): BatchDetectSentimentError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): BatchDetectSentimentError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): BatchDetectSentimentError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "BatchDetectSentimentError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends BatchDetectSentimentError { final def $ordinal: Int = 0 }
    final case class BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException: BatchSizeLimitExceededException) extends BatchDetectSentimentError { final def $ordinal: Int = 1 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends BatchDetectSentimentError { final def $ordinal: Int = 2 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends BatchDetectSentimentError { final def $ordinal: Int = 3 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends BatchDetectSentimentError { final def $ordinal: Int = 4 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSentimentError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), BatchDetectSentimentError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[BatchDetectSentimentError]("InternalServerException")
    }
    object BatchSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSentimentError.BatchSizeLimitExceededExceptionCase] = bijection(BatchSizeLimitExceededException.schema.addHints(hints), BatchDetectSentimentError.BatchSizeLimitExceededExceptionCase(_), _.batchSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectSentimentError]("BatchSizeLimitExceededException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSentimentError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), BatchDetectSentimentError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[BatchDetectSentimentError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSentimentError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), BatchDetectSentimentError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectSentimentError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSentimentError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), BatchDetectSentimentError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[BatchDetectSentimentError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[BatchDetectSentimentError] = union(
      BatchDetectSentimentError.InternalServerExceptionCase.alt,
      BatchDetectSentimentError.BatchSizeLimitExceededExceptionCase.alt,
      BatchDetectSentimentError.UnsupportedLanguageExceptionCase.alt,
      BatchDetectSentimentError.TextSizeLimitExceededExceptionCase.alt,
      BatchDetectSentimentError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[BatchDetectSentimentError] = throwable match {
      case e: InternalServerException => Some(BatchDetectSentimentError.InternalServerExceptionCase(e))
      case e: BatchSizeLimitExceededException => Some(BatchDetectSentimentError.BatchSizeLimitExceededExceptionCase(e))
      case e: UnsupportedLanguageException => Some(BatchDetectSentimentError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(BatchDetectSentimentError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(BatchDetectSentimentError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: BatchDetectSentimentError): Throwable = e match {
      case BatchDetectSentimentError.InternalServerExceptionCase(e) => e
      case BatchDetectSentimentError.BatchSizeLimitExceededExceptionCase(e) => e
      case BatchDetectSentimentError.UnsupportedLanguageExceptionCase(e) => e
      case BatchDetectSentimentError.TextSizeLimitExceededExceptionCase(e) => e
      case BatchDetectSentimentError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class BatchDetectSyntax(input: BatchDetectSyntaxRequest) extends ComprehendOperation[BatchDetectSyntaxRequest, ComprehendOperation.BatchDetectSyntaxError, BatchDetectSyntaxResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[BatchDetectSyntaxRequest, ComprehendOperation.BatchDetectSyntaxError, BatchDetectSyntaxResponse, Nothing, Nothing] = impl.batchDetectSyntax(input.textList, input.languageCode)
    def ordinal: Int = 4
    def endpoint: smithy4s.Endpoint[ComprehendOperation,BatchDetectSyntaxRequest, ComprehendOperation.BatchDetectSyntaxError, BatchDetectSyntaxResponse, Nothing, Nothing] = BatchDetectSyntax
  }
  object BatchDetectSyntax extends smithy4s.Endpoint[ComprehendOperation,BatchDetectSyntaxRequest, ComprehendOperation.BatchDetectSyntaxError, BatchDetectSyntaxResponse, Nothing, Nothing] {
    val schema: OperationSchema[BatchDetectSyntaxRequest, ComprehendOperation.BatchDetectSyntaxError, BatchDetectSyntaxResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "BatchDetectSyntax"))
      .withInput(BatchDetectSyntaxRequest.schema)
      .withError(BatchDetectSyntaxError.errorSchema)
      .withOutput(BatchDetectSyntaxResponse.schema)
      .withHints(smithy.api.Documentation("<p>Inspects the text of a batch of documents for the syntax and part of speech of the words\n      in the document and returns information about them. For more information, see\n      <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html\">Syntax</a> in the Comprehend Developer Guide.\n    </p>"))
    def wrap(input: BatchDetectSyntaxRequest): BatchDetectSyntax = BatchDetectSyntax(input)
  }
  sealed trait BatchDetectSyntaxError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: BatchDetectSyntaxError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = BatchDetectSyntaxError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def batchSizeLimitExceededException: Option[BatchSizeLimitExceededException] = BatchDetectSyntaxError.BatchSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.batchSizeLimitExceededException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = BatchDetectSyntaxError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = BatchDetectSyntaxError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = BatchDetectSyntaxError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: BatchDetectSyntaxError.Visitor[A]): A = this match {
      case value: BatchDetectSyntaxError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: BatchDetectSyntaxError.BatchSizeLimitExceededExceptionCase => visitor.batchSizeLimitExceededException(value.batchSizeLimitExceededException)
      case value: BatchDetectSyntaxError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: BatchDetectSyntaxError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: BatchDetectSyntaxError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object BatchDetectSyntaxError extends ErrorSchema.Companion[BatchDetectSyntaxError] {

    def internalServerException(internalServerException: InternalServerException): BatchDetectSyntaxError = InternalServerExceptionCase(internalServerException)
    def batchSizeLimitExceededException(batchSizeLimitExceededException: BatchSizeLimitExceededException): BatchDetectSyntaxError = BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): BatchDetectSyntaxError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): BatchDetectSyntaxError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): BatchDetectSyntaxError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "BatchDetectSyntaxError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends BatchDetectSyntaxError { final def $ordinal: Int = 0 }
    final case class BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException: BatchSizeLimitExceededException) extends BatchDetectSyntaxError { final def $ordinal: Int = 1 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends BatchDetectSyntaxError { final def $ordinal: Int = 2 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends BatchDetectSyntaxError { final def $ordinal: Int = 3 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends BatchDetectSyntaxError { final def $ordinal: Int = 4 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSyntaxError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), BatchDetectSyntaxError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[BatchDetectSyntaxError]("InternalServerException")
    }
    object BatchSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSyntaxError.BatchSizeLimitExceededExceptionCase] = bijection(BatchSizeLimitExceededException.schema.addHints(hints), BatchDetectSyntaxError.BatchSizeLimitExceededExceptionCase(_), _.batchSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectSyntaxError]("BatchSizeLimitExceededException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSyntaxError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), BatchDetectSyntaxError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[BatchDetectSyntaxError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSyntaxError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), BatchDetectSyntaxError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectSyntaxError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectSyntaxError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), BatchDetectSyntaxError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[BatchDetectSyntaxError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[BatchDetectSyntaxError] = union(
      BatchDetectSyntaxError.InternalServerExceptionCase.alt,
      BatchDetectSyntaxError.BatchSizeLimitExceededExceptionCase.alt,
      BatchDetectSyntaxError.UnsupportedLanguageExceptionCase.alt,
      BatchDetectSyntaxError.TextSizeLimitExceededExceptionCase.alt,
      BatchDetectSyntaxError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[BatchDetectSyntaxError] = throwable match {
      case e: InternalServerException => Some(BatchDetectSyntaxError.InternalServerExceptionCase(e))
      case e: BatchSizeLimitExceededException => Some(BatchDetectSyntaxError.BatchSizeLimitExceededExceptionCase(e))
      case e: UnsupportedLanguageException => Some(BatchDetectSyntaxError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(BatchDetectSyntaxError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(BatchDetectSyntaxError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: BatchDetectSyntaxError): Throwable = e match {
      case BatchDetectSyntaxError.InternalServerExceptionCase(e) => e
      case BatchDetectSyntaxError.BatchSizeLimitExceededExceptionCase(e) => e
      case BatchDetectSyntaxError.UnsupportedLanguageExceptionCase(e) => e
      case BatchDetectSyntaxError.TextSizeLimitExceededExceptionCase(e) => e
      case BatchDetectSyntaxError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class BatchDetectTargetedSentiment(input: BatchDetectTargetedSentimentRequest) extends ComprehendOperation[BatchDetectTargetedSentimentRequest, ComprehendOperation.BatchDetectTargetedSentimentError, BatchDetectTargetedSentimentResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[BatchDetectTargetedSentimentRequest, ComprehendOperation.BatchDetectTargetedSentimentError, BatchDetectTargetedSentimentResponse, Nothing, Nothing] = impl.batchDetectTargetedSentiment(input.textList, input.languageCode)
    def ordinal: Int = 5
    def endpoint: smithy4s.Endpoint[ComprehendOperation,BatchDetectTargetedSentimentRequest, ComprehendOperation.BatchDetectTargetedSentimentError, BatchDetectTargetedSentimentResponse, Nothing, Nothing] = BatchDetectTargetedSentiment
  }
  object BatchDetectTargetedSentiment extends smithy4s.Endpoint[ComprehendOperation,BatchDetectTargetedSentimentRequest, ComprehendOperation.BatchDetectTargetedSentimentError, BatchDetectTargetedSentimentResponse, Nothing, Nothing] {
    val schema: OperationSchema[BatchDetectTargetedSentimentRequest, ComprehendOperation.BatchDetectTargetedSentimentError, BatchDetectTargetedSentimentResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "BatchDetectTargetedSentiment"))
      .withInput(BatchDetectTargetedSentimentRequest.schema)
      .withError(BatchDetectTargetedSentimentError.errorSchema)
      .withOutput(BatchDetectTargetedSentimentResponse.schema)
      .withHints(smithy.api.Documentation("<p>Inspects a batch of documents and returns a sentiment analysis\n      for each entity identified in the documents.</p>\n         <p>For more information about targeted sentiment, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html\">Targeted sentiment</a>.</p>"))
    def wrap(input: BatchDetectTargetedSentimentRequest): BatchDetectTargetedSentiment = BatchDetectTargetedSentiment(input)
  }
  sealed trait BatchDetectTargetedSentimentError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: BatchDetectTargetedSentimentError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = BatchDetectTargetedSentimentError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def batchSizeLimitExceededException: Option[BatchSizeLimitExceededException] = BatchDetectTargetedSentimentError.BatchSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.batchSizeLimitExceededException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = BatchDetectTargetedSentimentError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = BatchDetectTargetedSentimentError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = BatchDetectTargetedSentimentError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: BatchDetectTargetedSentimentError.Visitor[A]): A = this match {
      case value: BatchDetectTargetedSentimentError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: BatchDetectTargetedSentimentError.BatchSizeLimitExceededExceptionCase => visitor.batchSizeLimitExceededException(value.batchSizeLimitExceededException)
      case value: BatchDetectTargetedSentimentError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: BatchDetectTargetedSentimentError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: BatchDetectTargetedSentimentError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object BatchDetectTargetedSentimentError extends ErrorSchema.Companion[BatchDetectTargetedSentimentError] {

    def internalServerException(internalServerException: InternalServerException): BatchDetectTargetedSentimentError = InternalServerExceptionCase(internalServerException)
    def batchSizeLimitExceededException(batchSizeLimitExceededException: BatchSizeLimitExceededException): BatchDetectTargetedSentimentError = BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): BatchDetectTargetedSentimentError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): BatchDetectTargetedSentimentError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): BatchDetectTargetedSentimentError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "BatchDetectTargetedSentimentError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends BatchDetectTargetedSentimentError { final def $ordinal: Int = 0 }
    final case class BatchSizeLimitExceededExceptionCase(batchSizeLimitExceededException: BatchSizeLimitExceededException) extends BatchDetectTargetedSentimentError { final def $ordinal: Int = 1 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends BatchDetectTargetedSentimentError { final def $ordinal: Int = 2 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends BatchDetectTargetedSentimentError { final def $ordinal: Int = 3 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends BatchDetectTargetedSentimentError { final def $ordinal: Int = 4 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectTargetedSentimentError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), BatchDetectTargetedSentimentError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[BatchDetectTargetedSentimentError]("InternalServerException")
    }
    object BatchSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectTargetedSentimentError.BatchSizeLimitExceededExceptionCase] = bijection(BatchSizeLimitExceededException.schema.addHints(hints), BatchDetectTargetedSentimentError.BatchSizeLimitExceededExceptionCase(_), _.batchSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectTargetedSentimentError]("BatchSizeLimitExceededException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectTargetedSentimentError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), BatchDetectTargetedSentimentError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[BatchDetectTargetedSentimentError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectTargetedSentimentError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), BatchDetectTargetedSentimentError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[BatchDetectTargetedSentimentError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[BatchDetectTargetedSentimentError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), BatchDetectTargetedSentimentError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[BatchDetectTargetedSentimentError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def batchSizeLimitExceededException(value: BatchSizeLimitExceededException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[BatchDetectTargetedSentimentError] = union(
      BatchDetectTargetedSentimentError.InternalServerExceptionCase.alt,
      BatchDetectTargetedSentimentError.BatchSizeLimitExceededExceptionCase.alt,
      BatchDetectTargetedSentimentError.UnsupportedLanguageExceptionCase.alt,
      BatchDetectTargetedSentimentError.TextSizeLimitExceededExceptionCase.alt,
      BatchDetectTargetedSentimentError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[BatchDetectTargetedSentimentError] = throwable match {
      case e: InternalServerException => Some(BatchDetectTargetedSentimentError.InternalServerExceptionCase(e))
      case e: BatchSizeLimitExceededException => Some(BatchDetectTargetedSentimentError.BatchSizeLimitExceededExceptionCase(e))
      case e: UnsupportedLanguageException => Some(BatchDetectTargetedSentimentError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(BatchDetectTargetedSentimentError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(BatchDetectTargetedSentimentError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: BatchDetectTargetedSentimentError): Throwable = e match {
      case BatchDetectTargetedSentimentError.InternalServerExceptionCase(e) => e
      case BatchDetectTargetedSentimentError.BatchSizeLimitExceededExceptionCase(e) => e
      case BatchDetectTargetedSentimentError.UnsupportedLanguageExceptionCase(e) => e
      case BatchDetectTargetedSentimentError.TextSizeLimitExceededExceptionCase(e) => e
      case BatchDetectTargetedSentimentError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ClassifyDocument(input: ClassifyDocumentRequest) extends ComprehendOperation[ClassifyDocumentRequest, ComprehendOperation.ClassifyDocumentError, ClassifyDocumentResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ClassifyDocumentRequest, ComprehendOperation.ClassifyDocumentError, ClassifyDocumentResponse, Nothing, Nothing] = impl.classifyDocument(input.endpointArn, input.text, input.bytes, input.documentReaderConfig)
    def ordinal: Int = 6
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ClassifyDocumentRequest, ComprehendOperation.ClassifyDocumentError, ClassifyDocumentResponse, Nothing, Nothing] = ClassifyDocument
  }
  object ClassifyDocument extends smithy4s.Endpoint[ComprehendOperation,ClassifyDocumentRequest, ComprehendOperation.ClassifyDocumentError, ClassifyDocumentResponse, Nothing, Nothing] {
    val schema: OperationSchema[ClassifyDocumentRequest, ComprehendOperation.ClassifyDocumentError, ClassifyDocumentResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ClassifyDocument"))
      .withInput(ClassifyDocumentRequest.schema)
      .withError(ClassifyDocumentError.errorSchema)
      .withOutput(ClassifyDocumentResponse.schema)
      .withHints(smithy.api.Documentation("<p>Creates a new document classification request to analyze a single document in real-time,\n      using a previously created and trained custom model and an endpoint.</p>\n         <p>You can input plain text or you can upload a single-page input document (text, PDF, Word, or image). </p>\n         <p>If the system detects errors while processing a page in the input document,\n      the API response includes an entry in <code>Errors</code> that describes the errors.</p>\n         <p>If the system detects a document-level error in your input document, the API returns an\n      <code>InvalidRequestException</code> error response.\n      For details about this exception, see\n      <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/idp-inputs-sync-err.html\">\n        Errors in semi-structured documents</a> in the Comprehend Developer Guide.\n    </p>"))
    def wrap(input: ClassifyDocumentRequest): ClassifyDocument = ClassifyDocument(input)
  }
  sealed trait ClassifyDocumentError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ClassifyDocumentError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = ClassifyDocumentError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = ClassifyDocumentError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = ClassifyDocumentError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = ClassifyDocumentError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ClassifyDocumentError.Visitor[A]): A = this match {
      case value: ClassifyDocumentError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ClassifyDocumentError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: ClassifyDocumentError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: ClassifyDocumentError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ClassifyDocumentError extends ErrorSchema.Companion[ClassifyDocumentError] {

    def internalServerException(internalServerException: InternalServerException): ClassifyDocumentError = InternalServerExceptionCase(internalServerException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): ClassifyDocumentError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): ClassifyDocumentError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ClassifyDocumentError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ClassifyDocumentError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ClassifyDocumentError { final def $ordinal: Int = 0 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends ClassifyDocumentError { final def $ordinal: Int = 1 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends ClassifyDocumentError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ClassifyDocumentError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ClassifyDocumentError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ClassifyDocumentError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ClassifyDocumentError]("InternalServerException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ClassifyDocumentError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), ClassifyDocumentError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[ClassifyDocumentError]("ResourceUnavailableException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ClassifyDocumentError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), ClassifyDocumentError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[ClassifyDocumentError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ClassifyDocumentError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ClassifyDocumentError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ClassifyDocumentError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ClassifyDocumentError] = union(
      ClassifyDocumentError.InternalServerExceptionCase.alt,
      ClassifyDocumentError.ResourceUnavailableExceptionCase.alt,
      ClassifyDocumentError.TextSizeLimitExceededExceptionCase.alt,
      ClassifyDocumentError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ClassifyDocumentError] = throwable match {
      case e: InternalServerException => Some(ClassifyDocumentError.InternalServerExceptionCase(e))
      case e: ResourceUnavailableException => Some(ClassifyDocumentError.ResourceUnavailableExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(ClassifyDocumentError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(ClassifyDocumentError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ClassifyDocumentError): Throwable = e match {
      case ClassifyDocumentError.InternalServerExceptionCase(e) => e
      case ClassifyDocumentError.ResourceUnavailableExceptionCase(e) => e
      case ClassifyDocumentError.TextSizeLimitExceededExceptionCase(e) => e
      case ClassifyDocumentError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ContainsPiiEntities(input: ContainsPiiEntitiesRequest) extends ComprehendOperation[ContainsPiiEntitiesRequest, ComprehendOperation.ContainsPiiEntitiesError, ContainsPiiEntitiesResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ContainsPiiEntitiesRequest, ComprehendOperation.ContainsPiiEntitiesError, ContainsPiiEntitiesResponse, Nothing, Nothing] = impl.containsPiiEntities(input.text, input.languageCode)
    def ordinal: Int = 7
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ContainsPiiEntitiesRequest, ComprehendOperation.ContainsPiiEntitiesError, ContainsPiiEntitiesResponse, Nothing, Nothing] = ContainsPiiEntities
  }
  object ContainsPiiEntities extends smithy4s.Endpoint[ComprehendOperation,ContainsPiiEntitiesRequest, ComprehendOperation.ContainsPiiEntitiesError, ContainsPiiEntitiesResponse, Nothing, Nothing] {
    val schema: OperationSchema[ContainsPiiEntitiesRequest, ComprehendOperation.ContainsPiiEntitiesError, ContainsPiiEntitiesResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ContainsPiiEntities"))
      .withInput(ContainsPiiEntitiesRequest.schema)
      .withError(ContainsPiiEntitiesError.errorSchema)
      .withOutput(ContainsPiiEntitiesResponse.schema)
      .withHints(smithy.api.Documentation("<p>Analyzes input text for the presence of personally identifiable information (PII) and\n      returns the labels of identified PII entity types such as name, address, bank account number,\n      or phone number.</p>"))
    def wrap(input: ContainsPiiEntitiesRequest): ContainsPiiEntities = ContainsPiiEntities(input)
  }
  sealed trait ContainsPiiEntitiesError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ContainsPiiEntitiesError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = ContainsPiiEntitiesError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = ContainsPiiEntitiesError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = ContainsPiiEntitiesError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = ContainsPiiEntitiesError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ContainsPiiEntitiesError.Visitor[A]): A = this match {
      case value: ContainsPiiEntitiesError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ContainsPiiEntitiesError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: ContainsPiiEntitiesError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: ContainsPiiEntitiesError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ContainsPiiEntitiesError extends ErrorSchema.Companion[ContainsPiiEntitiesError] {

    def internalServerException(internalServerException: InternalServerException): ContainsPiiEntitiesError = InternalServerExceptionCase(internalServerException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): ContainsPiiEntitiesError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): ContainsPiiEntitiesError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ContainsPiiEntitiesError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ContainsPiiEntitiesError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ContainsPiiEntitiesError { final def $ordinal: Int = 0 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends ContainsPiiEntitiesError { final def $ordinal: Int = 1 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends ContainsPiiEntitiesError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ContainsPiiEntitiesError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ContainsPiiEntitiesError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ContainsPiiEntitiesError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ContainsPiiEntitiesError]("InternalServerException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ContainsPiiEntitiesError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), ContainsPiiEntitiesError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[ContainsPiiEntitiesError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ContainsPiiEntitiesError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), ContainsPiiEntitiesError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[ContainsPiiEntitiesError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ContainsPiiEntitiesError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ContainsPiiEntitiesError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ContainsPiiEntitiesError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ContainsPiiEntitiesError] = union(
      ContainsPiiEntitiesError.InternalServerExceptionCase.alt,
      ContainsPiiEntitiesError.UnsupportedLanguageExceptionCase.alt,
      ContainsPiiEntitiesError.TextSizeLimitExceededExceptionCase.alt,
      ContainsPiiEntitiesError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ContainsPiiEntitiesError] = throwable match {
      case e: InternalServerException => Some(ContainsPiiEntitiesError.InternalServerExceptionCase(e))
      case e: UnsupportedLanguageException => Some(ContainsPiiEntitiesError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(ContainsPiiEntitiesError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(ContainsPiiEntitiesError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ContainsPiiEntitiesError): Throwable = e match {
      case ContainsPiiEntitiesError.InternalServerExceptionCase(e) => e
      case ContainsPiiEntitiesError.UnsupportedLanguageExceptionCase(e) => e
      case ContainsPiiEntitiesError.TextSizeLimitExceededExceptionCase(e) => e
      case ContainsPiiEntitiesError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class CreateDataset(input: CreateDatasetRequest) extends ComprehendOperation[CreateDatasetRequest, ComprehendOperation.CreateDatasetError, CreateDatasetResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[CreateDatasetRequest, ComprehendOperation.CreateDatasetError, CreateDatasetResponse, Nothing, Nothing] = impl.createDataset(input.flywheelArn, input.datasetName, input.inputDataConfig, input.datasetType, input.description, input.clientRequestToken, input.tags)
    def ordinal: Int = 8
    def endpoint: smithy4s.Endpoint[ComprehendOperation,CreateDatasetRequest, ComprehendOperation.CreateDatasetError, CreateDatasetResponse, Nothing, Nothing] = CreateDataset
  }
  object CreateDataset extends smithy4s.Endpoint[ComprehendOperation,CreateDatasetRequest, ComprehendOperation.CreateDatasetError, CreateDatasetResponse, Nothing, Nothing] {
    val schema: OperationSchema[CreateDatasetRequest, ComprehendOperation.CreateDatasetError, CreateDatasetResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "CreateDataset"))
      .withInput(CreateDatasetRequest.schema)
      .withError(CreateDatasetError.errorSchema)
      .withOutput(CreateDatasetResponse.schema)
      .withHints(smithy.api.Documentation("<p>Creates a dataset to upload training or test data for a model associated with a flywheel.\n      For more information about datasets, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html\">\n      Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>"))
    def wrap(input: CreateDatasetRequest): CreateDataset = CreateDataset(input)
  }
  sealed trait CreateDatasetError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: CreateDatasetError = this
    def $ordinal: Int

    object project {
      def resourceLimitExceededException: Option[ResourceLimitExceededException] = CreateDatasetError.ResourceLimitExceededExceptionCase.alt.project.lift(self).map(_.resourceLimitExceededException)
      def internalServerException: Option[InternalServerException] = CreateDatasetError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = CreateDatasetError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def resourceInUseException: Option[ResourceInUseException] = CreateDatasetError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = CreateDatasetError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = CreateDatasetError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = CreateDatasetError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: CreateDatasetError.Visitor[A]): A = this match {
      case value: CreateDatasetError.ResourceLimitExceededExceptionCase => visitor.resourceLimitExceededException(value.resourceLimitExceededException)
      case value: CreateDatasetError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: CreateDatasetError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: CreateDatasetError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: CreateDatasetError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: CreateDatasetError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: CreateDatasetError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object CreateDatasetError extends ErrorSchema.Companion[CreateDatasetError] {

    def resourceLimitExceededException(resourceLimitExceededException: ResourceLimitExceededException): CreateDatasetError = ResourceLimitExceededExceptionCase(resourceLimitExceededException)
    def internalServerException(internalServerException: InternalServerException): CreateDatasetError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): CreateDatasetError = TooManyTagsExceptionCase(tooManyTagsException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): CreateDatasetError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): CreateDatasetError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): CreateDatasetError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): CreateDatasetError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "CreateDatasetError")

    val hints: Hints = Hints.empty

    final case class ResourceLimitExceededExceptionCase(resourceLimitExceededException: ResourceLimitExceededException) extends CreateDatasetError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends CreateDatasetError { final def $ordinal: Int = 1 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends CreateDatasetError { final def $ordinal: Int = 2 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends CreateDatasetError { final def $ordinal: Int = 3 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends CreateDatasetError { final def $ordinal: Int = 4 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends CreateDatasetError { final def $ordinal: Int = 5 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends CreateDatasetError { final def $ordinal: Int = 6 }

    object ResourceLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDatasetError.ResourceLimitExceededExceptionCase] = bijection(ResourceLimitExceededException.schema.addHints(hints), CreateDatasetError.ResourceLimitExceededExceptionCase(_), _.resourceLimitExceededException)
      val alt = schema.oneOf[CreateDatasetError]("ResourceLimitExceededException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDatasetError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), CreateDatasetError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[CreateDatasetError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDatasetError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), CreateDatasetError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[CreateDatasetError]("TooManyTagsException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDatasetError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), CreateDatasetError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[CreateDatasetError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDatasetError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), CreateDatasetError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[CreateDatasetError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDatasetError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), CreateDatasetError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[CreateDatasetError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDatasetError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), CreateDatasetError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[CreateDatasetError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def resourceLimitExceededException(value: ResourceLimitExceededException): A
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def resourceLimitExceededException(value: ResourceLimitExceededException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[CreateDatasetError] = union(
      CreateDatasetError.ResourceLimitExceededExceptionCase.alt,
      CreateDatasetError.InternalServerExceptionCase.alt,
      CreateDatasetError.TooManyTagsExceptionCase.alt,
      CreateDatasetError.ResourceInUseExceptionCase.alt,
      CreateDatasetError.TooManyRequestsExceptionCase.alt,
      CreateDatasetError.InvalidRequestExceptionCase.alt,
      CreateDatasetError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[CreateDatasetError] = throwable match {
      case e: ResourceLimitExceededException => Some(CreateDatasetError.ResourceLimitExceededExceptionCase(e))
      case e: InternalServerException => Some(CreateDatasetError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(CreateDatasetError.TooManyTagsExceptionCase(e))
      case e: ResourceInUseException => Some(CreateDatasetError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(CreateDatasetError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(CreateDatasetError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(CreateDatasetError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: CreateDatasetError): Throwable = e match {
      case CreateDatasetError.ResourceLimitExceededExceptionCase(e) => e
      case CreateDatasetError.InternalServerExceptionCase(e) => e
      case CreateDatasetError.TooManyTagsExceptionCase(e) => e
      case CreateDatasetError.ResourceInUseExceptionCase(e) => e
      case CreateDatasetError.TooManyRequestsExceptionCase(e) => e
      case CreateDatasetError.InvalidRequestExceptionCase(e) => e
      case CreateDatasetError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class CreateDocumentClassifier(input: CreateDocumentClassifierRequest) extends ComprehendOperation[CreateDocumentClassifierRequest, ComprehendOperation.CreateDocumentClassifierError, CreateDocumentClassifierResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[CreateDocumentClassifierRequest, ComprehendOperation.CreateDocumentClassifierError, CreateDocumentClassifierResponse, Nothing, Nothing] = impl.createDocumentClassifier(input.documentClassifierName, input.dataAccessRoleArn, input.inputDataConfig, input.languageCode, input.versionName, input.tags, input.outputDataConfig, input.clientRequestToken, input.volumeKmsKeyId, input.vpcConfig, input.mode, input.modelKmsKeyId, input.modelPolicy)
    def ordinal: Int = 9
    def endpoint: smithy4s.Endpoint[ComprehendOperation,CreateDocumentClassifierRequest, ComprehendOperation.CreateDocumentClassifierError, CreateDocumentClassifierResponse, Nothing, Nothing] = CreateDocumentClassifier
  }
  object CreateDocumentClassifier extends smithy4s.Endpoint[ComprehendOperation,CreateDocumentClassifierRequest, ComprehendOperation.CreateDocumentClassifierError, CreateDocumentClassifierResponse, Nothing, Nothing] {
    val schema: OperationSchema[CreateDocumentClassifierRequest, ComprehendOperation.CreateDocumentClassifierError, CreateDocumentClassifierResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "CreateDocumentClassifier"))
      .withInput(CreateDocumentClassifierRequest.schema)
      .withError(CreateDocumentClassifierError.errorSchema)
      .withOutput(CreateDocumentClassifierResponse.schema)
      .withHints(smithy.api.Documentation("<p>Creates a new document classifier that you can use to categorize documents. To create a\n      classifier, you provide a set of training documents that are labeled with the categories that you\n      want to use. For more information, see\n      <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/training-classifier-model.html\">Training classifier models</a>\n      in the Comprehend Developer Guide.\n    </p>"))
    def wrap(input: CreateDocumentClassifierRequest): CreateDocumentClassifier = CreateDocumentClassifier(input)
  }
  sealed trait CreateDocumentClassifierError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: CreateDocumentClassifierError = this
    def $ordinal: Int

    object project {
      def resourceLimitExceededException: Option[ResourceLimitExceededException] = CreateDocumentClassifierError.ResourceLimitExceededExceptionCase.alt.project.lift(self).map(_.resourceLimitExceededException)
      def internalServerException: Option[InternalServerException] = CreateDocumentClassifierError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = CreateDocumentClassifierError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = CreateDocumentClassifierError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = CreateDocumentClassifierError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = CreateDocumentClassifierError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = CreateDocumentClassifierError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = CreateDocumentClassifierError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: CreateDocumentClassifierError.Visitor[A]): A = this match {
      case value: CreateDocumentClassifierError.ResourceLimitExceededExceptionCase => visitor.resourceLimitExceededException(value.resourceLimitExceededException)
      case value: CreateDocumentClassifierError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: CreateDocumentClassifierError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: CreateDocumentClassifierError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: CreateDocumentClassifierError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: CreateDocumentClassifierError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: CreateDocumentClassifierError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: CreateDocumentClassifierError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object CreateDocumentClassifierError extends ErrorSchema.Companion[CreateDocumentClassifierError] {

    def resourceLimitExceededException(resourceLimitExceededException: ResourceLimitExceededException): CreateDocumentClassifierError = ResourceLimitExceededExceptionCase(resourceLimitExceededException)
    def internalServerException(internalServerException: InternalServerException): CreateDocumentClassifierError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): CreateDocumentClassifierError = TooManyTagsExceptionCase(tooManyTagsException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): CreateDocumentClassifierError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): CreateDocumentClassifierError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): CreateDocumentClassifierError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): CreateDocumentClassifierError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): CreateDocumentClassifierError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "CreateDocumentClassifierError")

    val hints: Hints = Hints.empty

    final case class ResourceLimitExceededExceptionCase(resourceLimitExceededException: ResourceLimitExceededException) extends CreateDocumentClassifierError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends CreateDocumentClassifierError { final def $ordinal: Int = 1 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends CreateDocumentClassifierError { final def $ordinal: Int = 2 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends CreateDocumentClassifierError { final def $ordinal: Int = 3 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends CreateDocumentClassifierError { final def $ordinal: Int = 4 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends CreateDocumentClassifierError { final def $ordinal: Int = 5 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends CreateDocumentClassifierError { final def $ordinal: Int = 6 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends CreateDocumentClassifierError { final def $ordinal: Int = 7 }

    object ResourceLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDocumentClassifierError.ResourceLimitExceededExceptionCase] = bijection(ResourceLimitExceededException.schema.addHints(hints), CreateDocumentClassifierError.ResourceLimitExceededExceptionCase(_), _.resourceLimitExceededException)
      val alt = schema.oneOf[CreateDocumentClassifierError]("ResourceLimitExceededException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDocumentClassifierError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), CreateDocumentClassifierError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[CreateDocumentClassifierError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDocumentClassifierError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), CreateDocumentClassifierError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[CreateDocumentClassifierError]("TooManyTagsException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDocumentClassifierError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), CreateDocumentClassifierError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[CreateDocumentClassifierError]("UnsupportedLanguageException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDocumentClassifierError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), CreateDocumentClassifierError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[CreateDocumentClassifierError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDocumentClassifierError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), CreateDocumentClassifierError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[CreateDocumentClassifierError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDocumentClassifierError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), CreateDocumentClassifierError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[CreateDocumentClassifierError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateDocumentClassifierError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), CreateDocumentClassifierError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[CreateDocumentClassifierError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def resourceLimitExceededException(value: ResourceLimitExceededException): A
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def resourceLimitExceededException(value: ResourceLimitExceededException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[CreateDocumentClassifierError] = union(
      CreateDocumentClassifierError.ResourceLimitExceededExceptionCase.alt,
      CreateDocumentClassifierError.InternalServerExceptionCase.alt,
      CreateDocumentClassifierError.TooManyTagsExceptionCase.alt,
      CreateDocumentClassifierError.UnsupportedLanguageExceptionCase.alt,
      CreateDocumentClassifierError.KmsKeyValidationExceptionCase.alt,
      CreateDocumentClassifierError.ResourceInUseExceptionCase.alt,
      CreateDocumentClassifierError.TooManyRequestsExceptionCase.alt,
      CreateDocumentClassifierError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[CreateDocumentClassifierError] = throwable match {
      case e: ResourceLimitExceededException => Some(CreateDocumentClassifierError.ResourceLimitExceededExceptionCase(e))
      case e: InternalServerException => Some(CreateDocumentClassifierError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(CreateDocumentClassifierError.TooManyTagsExceptionCase(e))
      case e: UnsupportedLanguageException => Some(CreateDocumentClassifierError.UnsupportedLanguageExceptionCase(e))
      case e: KmsKeyValidationException => Some(CreateDocumentClassifierError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(CreateDocumentClassifierError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(CreateDocumentClassifierError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(CreateDocumentClassifierError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: CreateDocumentClassifierError): Throwable = e match {
      case CreateDocumentClassifierError.ResourceLimitExceededExceptionCase(e) => e
      case CreateDocumentClassifierError.InternalServerExceptionCase(e) => e
      case CreateDocumentClassifierError.TooManyTagsExceptionCase(e) => e
      case CreateDocumentClassifierError.UnsupportedLanguageExceptionCase(e) => e
      case CreateDocumentClassifierError.KmsKeyValidationExceptionCase(e) => e
      case CreateDocumentClassifierError.ResourceInUseExceptionCase(e) => e
      case CreateDocumentClassifierError.TooManyRequestsExceptionCase(e) => e
      case CreateDocumentClassifierError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class CreateEndpoint(input: CreateEndpointRequest) extends ComprehendOperation[CreateEndpointRequest, ComprehendOperation.CreateEndpointError, CreateEndpointResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[CreateEndpointRequest, ComprehendOperation.CreateEndpointError, CreateEndpointResponse, Nothing, Nothing] = impl.createEndpoint(input.endpointName, input.desiredInferenceUnits, input.modelArn, input.clientRequestToken, input.tags, input.dataAccessRoleArn, input.flywheelArn)
    def ordinal: Int = 10
    def endpoint: smithy4s.Endpoint[ComprehendOperation,CreateEndpointRequest, ComprehendOperation.CreateEndpointError, CreateEndpointResponse, Nothing, Nothing] = CreateEndpoint
  }
  object CreateEndpoint extends smithy4s.Endpoint[ComprehendOperation,CreateEndpointRequest, ComprehendOperation.CreateEndpointError, CreateEndpointResponse, Nothing, Nothing] {
    val schema: OperationSchema[CreateEndpointRequest, ComprehendOperation.CreateEndpointError, CreateEndpointResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "CreateEndpoint"))
      .withInput(CreateEndpointRequest.schema)
      .withError(CreateEndpointError.errorSchema)
      .withOutput(CreateEndpointResponse.schema)
      .withHints(smithy.api.Documentation("<p>Creates a model-specific endpoint for synchronous inference for a previously trained\n      custom model\n      For information about endpoints, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html\">Managing endpoints</a>.</p>"))
    def wrap(input: CreateEndpointRequest): CreateEndpoint = CreateEndpoint(input)
  }
  sealed trait CreateEndpointError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: CreateEndpointError = this
    def $ordinal: Int

    object project {
      def resourceLimitExceededException: Option[ResourceLimitExceededException] = CreateEndpointError.ResourceLimitExceededExceptionCase.alt.project.lift(self).map(_.resourceLimitExceededException)
      def internalServerException: Option[InternalServerException] = CreateEndpointError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = CreateEndpointError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = CreateEndpointError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def resourceInUseException: Option[ResourceInUseException] = CreateEndpointError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = CreateEndpointError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = CreateEndpointError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = CreateEndpointError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: CreateEndpointError.Visitor[A]): A = this match {
      case value: CreateEndpointError.ResourceLimitExceededExceptionCase => visitor.resourceLimitExceededException(value.resourceLimitExceededException)
      case value: CreateEndpointError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: CreateEndpointError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: CreateEndpointError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: CreateEndpointError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: CreateEndpointError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: CreateEndpointError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: CreateEndpointError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object CreateEndpointError extends ErrorSchema.Companion[CreateEndpointError] {

    def resourceLimitExceededException(resourceLimitExceededException: ResourceLimitExceededException): CreateEndpointError = ResourceLimitExceededExceptionCase(resourceLimitExceededException)
    def internalServerException(internalServerException: InternalServerException): CreateEndpointError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): CreateEndpointError = TooManyTagsExceptionCase(tooManyTagsException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): CreateEndpointError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): CreateEndpointError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): CreateEndpointError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): CreateEndpointError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): CreateEndpointError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "CreateEndpointError")

    val hints: Hints = Hints.empty

    final case class ResourceLimitExceededExceptionCase(resourceLimitExceededException: ResourceLimitExceededException) extends CreateEndpointError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends CreateEndpointError { final def $ordinal: Int = 1 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends CreateEndpointError { final def $ordinal: Int = 2 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends CreateEndpointError { final def $ordinal: Int = 3 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends CreateEndpointError { final def $ordinal: Int = 4 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends CreateEndpointError { final def $ordinal: Int = 5 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends CreateEndpointError { final def $ordinal: Int = 6 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends CreateEndpointError { final def $ordinal: Int = 7 }

    object ResourceLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEndpointError.ResourceLimitExceededExceptionCase] = bijection(ResourceLimitExceededException.schema.addHints(hints), CreateEndpointError.ResourceLimitExceededExceptionCase(_), _.resourceLimitExceededException)
      val alt = schema.oneOf[CreateEndpointError]("ResourceLimitExceededException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEndpointError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), CreateEndpointError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[CreateEndpointError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEndpointError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), CreateEndpointError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[CreateEndpointError]("TooManyTagsException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEndpointError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), CreateEndpointError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[CreateEndpointError]("ResourceUnavailableException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEndpointError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), CreateEndpointError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[CreateEndpointError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEndpointError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), CreateEndpointError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[CreateEndpointError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEndpointError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), CreateEndpointError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[CreateEndpointError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEndpointError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), CreateEndpointError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[CreateEndpointError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def resourceLimitExceededException(value: ResourceLimitExceededException): A
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def resourceLimitExceededException(value: ResourceLimitExceededException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[CreateEndpointError] = union(
      CreateEndpointError.ResourceLimitExceededExceptionCase.alt,
      CreateEndpointError.InternalServerExceptionCase.alt,
      CreateEndpointError.TooManyTagsExceptionCase.alt,
      CreateEndpointError.ResourceUnavailableExceptionCase.alt,
      CreateEndpointError.ResourceInUseExceptionCase.alt,
      CreateEndpointError.TooManyRequestsExceptionCase.alt,
      CreateEndpointError.InvalidRequestExceptionCase.alt,
      CreateEndpointError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[CreateEndpointError] = throwable match {
      case e: ResourceLimitExceededException => Some(CreateEndpointError.ResourceLimitExceededExceptionCase(e))
      case e: InternalServerException => Some(CreateEndpointError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(CreateEndpointError.TooManyTagsExceptionCase(e))
      case e: ResourceUnavailableException => Some(CreateEndpointError.ResourceUnavailableExceptionCase(e))
      case e: ResourceInUseException => Some(CreateEndpointError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(CreateEndpointError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(CreateEndpointError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(CreateEndpointError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: CreateEndpointError): Throwable = e match {
      case CreateEndpointError.ResourceLimitExceededExceptionCase(e) => e
      case CreateEndpointError.InternalServerExceptionCase(e) => e
      case CreateEndpointError.TooManyTagsExceptionCase(e) => e
      case CreateEndpointError.ResourceUnavailableExceptionCase(e) => e
      case CreateEndpointError.ResourceInUseExceptionCase(e) => e
      case CreateEndpointError.TooManyRequestsExceptionCase(e) => e
      case CreateEndpointError.InvalidRequestExceptionCase(e) => e
      case CreateEndpointError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class CreateEntityRecognizer(input: CreateEntityRecognizerRequest) extends ComprehendOperation[CreateEntityRecognizerRequest, ComprehendOperation.CreateEntityRecognizerError, CreateEntityRecognizerResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[CreateEntityRecognizerRequest, ComprehendOperation.CreateEntityRecognizerError, CreateEntityRecognizerResponse, Nothing, Nothing] = impl.createEntityRecognizer(input.recognizerName, input.dataAccessRoleArn, input.inputDataConfig, input.languageCode, input.versionName, input.tags, input.clientRequestToken, input.volumeKmsKeyId, input.vpcConfig, input.modelKmsKeyId, input.modelPolicy)
    def ordinal: Int = 11
    def endpoint: smithy4s.Endpoint[ComprehendOperation,CreateEntityRecognizerRequest, ComprehendOperation.CreateEntityRecognizerError, CreateEntityRecognizerResponse, Nothing, Nothing] = CreateEntityRecognizer
  }
  object CreateEntityRecognizer extends smithy4s.Endpoint[ComprehendOperation,CreateEntityRecognizerRequest, ComprehendOperation.CreateEntityRecognizerError, CreateEntityRecognizerResponse, Nothing, Nothing] {
    val schema: OperationSchema[CreateEntityRecognizerRequest, ComprehendOperation.CreateEntityRecognizerError, CreateEntityRecognizerResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "CreateEntityRecognizer"))
      .withInput(CreateEntityRecognizerRequest.schema)
      .withError(CreateEntityRecognizerError.errorSchema)
      .withOutput(CreateEntityRecognizerResponse.schema)
      .withHints(smithy.api.Documentation("<p>Creates an entity recognizer using submitted files. After your\n        <code>CreateEntityRecognizer</code> request is submitted, you can check job status using the\n        <code>DescribeEntityRecognizer</code> API. </p>"))
    def wrap(input: CreateEntityRecognizerRequest): CreateEntityRecognizer = CreateEntityRecognizer(input)
  }
  sealed trait CreateEntityRecognizerError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: CreateEntityRecognizerError = this
    def $ordinal: Int

    object project {
      def resourceLimitExceededException: Option[ResourceLimitExceededException] = CreateEntityRecognizerError.ResourceLimitExceededExceptionCase.alt.project.lift(self).map(_.resourceLimitExceededException)
      def internalServerException: Option[InternalServerException] = CreateEntityRecognizerError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = CreateEntityRecognizerError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = CreateEntityRecognizerError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = CreateEntityRecognizerError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = CreateEntityRecognizerError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = CreateEntityRecognizerError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = CreateEntityRecognizerError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: CreateEntityRecognizerError.Visitor[A]): A = this match {
      case value: CreateEntityRecognizerError.ResourceLimitExceededExceptionCase => visitor.resourceLimitExceededException(value.resourceLimitExceededException)
      case value: CreateEntityRecognizerError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: CreateEntityRecognizerError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: CreateEntityRecognizerError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: CreateEntityRecognizerError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: CreateEntityRecognizerError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: CreateEntityRecognizerError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: CreateEntityRecognizerError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object CreateEntityRecognizerError extends ErrorSchema.Companion[CreateEntityRecognizerError] {

    def resourceLimitExceededException(resourceLimitExceededException: ResourceLimitExceededException): CreateEntityRecognizerError = ResourceLimitExceededExceptionCase(resourceLimitExceededException)
    def internalServerException(internalServerException: InternalServerException): CreateEntityRecognizerError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): CreateEntityRecognizerError = TooManyTagsExceptionCase(tooManyTagsException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): CreateEntityRecognizerError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): CreateEntityRecognizerError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): CreateEntityRecognizerError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): CreateEntityRecognizerError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): CreateEntityRecognizerError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "CreateEntityRecognizerError")

    val hints: Hints = Hints.empty

    final case class ResourceLimitExceededExceptionCase(resourceLimitExceededException: ResourceLimitExceededException) extends CreateEntityRecognizerError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends CreateEntityRecognizerError { final def $ordinal: Int = 1 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends CreateEntityRecognizerError { final def $ordinal: Int = 2 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends CreateEntityRecognizerError { final def $ordinal: Int = 3 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends CreateEntityRecognizerError { final def $ordinal: Int = 4 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends CreateEntityRecognizerError { final def $ordinal: Int = 5 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends CreateEntityRecognizerError { final def $ordinal: Int = 6 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends CreateEntityRecognizerError { final def $ordinal: Int = 7 }

    object ResourceLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEntityRecognizerError.ResourceLimitExceededExceptionCase] = bijection(ResourceLimitExceededException.schema.addHints(hints), CreateEntityRecognizerError.ResourceLimitExceededExceptionCase(_), _.resourceLimitExceededException)
      val alt = schema.oneOf[CreateEntityRecognizerError]("ResourceLimitExceededException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEntityRecognizerError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), CreateEntityRecognizerError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[CreateEntityRecognizerError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEntityRecognizerError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), CreateEntityRecognizerError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[CreateEntityRecognizerError]("TooManyTagsException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEntityRecognizerError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), CreateEntityRecognizerError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[CreateEntityRecognizerError]("UnsupportedLanguageException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEntityRecognizerError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), CreateEntityRecognizerError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[CreateEntityRecognizerError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEntityRecognizerError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), CreateEntityRecognizerError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[CreateEntityRecognizerError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEntityRecognizerError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), CreateEntityRecognizerError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[CreateEntityRecognizerError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateEntityRecognizerError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), CreateEntityRecognizerError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[CreateEntityRecognizerError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def resourceLimitExceededException(value: ResourceLimitExceededException): A
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def resourceLimitExceededException(value: ResourceLimitExceededException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[CreateEntityRecognizerError] = union(
      CreateEntityRecognizerError.ResourceLimitExceededExceptionCase.alt,
      CreateEntityRecognizerError.InternalServerExceptionCase.alt,
      CreateEntityRecognizerError.TooManyTagsExceptionCase.alt,
      CreateEntityRecognizerError.UnsupportedLanguageExceptionCase.alt,
      CreateEntityRecognizerError.KmsKeyValidationExceptionCase.alt,
      CreateEntityRecognizerError.ResourceInUseExceptionCase.alt,
      CreateEntityRecognizerError.TooManyRequestsExceptionCase.alt,
      CreateEntityRecognizerError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[CreateEntityRecognizerError] = throwable match {
      case e: ResourceLimitExceededException => Some(CreateEntityRecognizerError.ResourceLimitExceededExceptionCase(e))
      case e: InternalServerException => Some(CreateEntityRecognizerError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(CreateEntityRecognizerError.TooManyTagsExceptionCase(e))
      case e: UnsupportedLanguageException => Some(CreateEntityRecognizerError.UnsupportedLanguageExceptionCase(e))
      case e: KmsKeyValidationException => Some(CreateEntityRecognizerError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(CreateEntityRecognizerError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(CreateEntityRecognizerError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(CreateEntityRecognizerError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: CreateEntityRecognizerError): Throwable = e match {
      case CreateEntityRecognizerError.ResourceLimitExceededExceptionCase(e) => e
      case CreateEntityRecognizerError.InternalServerExceptionCase(e) => e
      case CreateEntityRecognizerError.TooManyTagsExceptionCase(e) => e
      case CreateEntityRecognizerError.UnsupportedLanguageExceptionCase(e) => e
      case CreateEntityRecognizerError.KmsKeyValidationExceptionCase(e) => e
      case CreateEntityRecognizerError.ResourceInUseExceptionCase(e) => e
      case CreateEntityRecognizerError.TooManyRequestsExceptionCase(e) => e
      case CreateEntityRecognizerError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class CreateFlywheel(input: CreateFlywheelRequest) extends ComprehendOperation[CreateFlywheelRequest, ComprehendOperation.CreateFlywheelError, CreateFlywheelResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[CreateFlywheelRequest, ComprehendOperation.CreateFlywheelError, CreateFlywheelResponse, Nothing, Nothing] = impl.createFlywheel(input.flywheelName, input.dataAccessRoleArn, input.dataLakeS3Uri, input.activeModelArn, input.taskConfig, input.modelType, input.dataSecurityConfig, input.clientRequestToken, input.tags)
    def ordinal: Int = 12
    def endpoint: smithy4s.Endpoint[ComprehendOperation,CreateFlywheelRequest, ComprehendOperation.CreateFlywheelError, CreateFlywheelResponse, Nothing, Nothing] = CreateFlywheel
  }
  object CreateFlywheel extends smithy4s.Endpoint[ComprehendOperation,CreateFlywheelRequest, ComprehendOperation.CreateFlywheelError, CreateFlywheelResponse, Nothing, Nothing] {
    val schema: OperationSchema[CreateFlywheelRequest, ComprehendOperation.CreateFlywheelError, CreateFlywheelResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "CreateFlywheel"))
      .withInput(CreateFlywheelRequest.schema)
      .withError(CreateFlywheelError.errorSchema)
      .withOutput(CreateFlywheelResponse.schema)
      .withHints(smithy.api.Documentation("<p>A flywheel is an Amazon Web Services resource that orchestrates the ongoing training of a model for custom classification\n      or custom entity recognition. You can create a flywheel to start with an existing trained model, or\n      Comprehend can create and train a new model.</p>\n         <p>When you create the flywheel, Comprehend creates a data lake in your account. The data lake holds the training\n      data and test data for all versions of the model.</p>\n         <p>To use a flywheel with an existing trained model, you specify the active model version. Comprehend copies the model\'s\n      training data and test data into the flywheel\'s data lake.</p>\n         <p>To use the flywheel with a new model, you need to provide a dataset for training data (and optional test data)\n      when you create the flywheel.</p>\n         <p>For more information about flywheels, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html\">\n      Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>"))
    def wrap(input: CreateFlywheelRequest): CreateFlywheel = CreateFlywheel(input)
  }
  sealed trait CreateFlywheelError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: CreateFlywheelError = this
    def $ordinal: Int

    object project {
      def resourceLimitExceededException: Option[ResourceLimitExceededException] = CreateFlywheelError.ResourceLimitExceededExceptionCase.alt.project.lift(self).map(_.resourceLimitExceededException)
      def internalServerException: Option[InternalServerException] = CreateFlywheelError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = CreateFlywheelError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = CreateFlywheelError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = CreateFlywheelError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = CreateFlywheelError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = CreateFlywheelError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = CreateFlywheelError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = CreateFlywheelError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = CreateFlywheelError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: CreateFlywheelError.Visitor[A]): A = this match {
      case value: CreateFlywheelError.ResourceLimitExceededExceptionCase => visitor.resourceLimitExceededException(value.resourceLimitExceededException)
      case value: CreateFlywheelError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: CreateFlywheelError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: CreateFlywheelError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: CreateFlywheelError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: CreateFlywheelError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: CreateFlywheelError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: CreateFlywheelError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: CreateFlywheelError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: CreateFlywheelError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object CreateFlywheelError extends ErrorSchema.Companion[CreateFlywheelError] {

    def resourceLimitExceededException(resourceLimitExceededException: ResourceLimitExceededException): CreateFlywheelError = ResourceLimitExceededExceptionCase(resourceLimitExceededException)
    def internalServerException(internalServerException: InternalServerException): CreateFlywheelError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): CreateFlywheelError = TooManyTagsExceptionCase(tooManyTagsException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): CreateFlywheelError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): CreateFlywheelError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): CreateFlywheelError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): CreateFlywheelError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): CreateFlywheelError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): CreateFlywheelError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): CreateFlywheelError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "CreateFlywheelError")

    val hints: Hints = Hints.empty

    final case class ResourceLimitExceededExceptionCase(resourceLimitExceededException: ResourceLimitExceededException) extends CreateFlywheelError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends CreateFlywheelError { final def $ordinal: Int = 1 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends CreateFlywheelError { final def $ordinal: Int = 2 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends CreateFlywheelError { final def $ordinal: Int = 3 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends CreateFlywheelError { final def $ordinal: Int = 4 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends CreateFlywheelError { final def $ordinal: Int = 5 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends CreateFlywheelError { final def $ordinal: Int = 6 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends CreateFlywheelError { final def $ordinal: Int = 7 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends CreateFlywheelError { final def $ordinal: Int = 8 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends CreateFlywheelError { final def $ordinal: Int = 9 }

    object ResourceLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.ResourceLimitExceededExceptionCase] = bijection(ResourceLimitExceededException.schema.addHints(hints), CreateFlywheelError.ResourceLimitExceededExceptionCase(_), _.resourceLimitExceededException)
      val alt = schema.oneOf[CreateFlywheelError]("ResourceLimitExceededException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), CreateFlywheelError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[CreateFlywheelError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), CreateFlywheelError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[CreateFlywheelError]("TooManyTagsException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), CreateFlywheelError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[CreateFlywheelError]("UnsupportedLanguageException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), CreateFlywheelError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[CreateFlywheelError]("ResourceUnavailableException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), CreateFlywheelError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[CreateFlywheelError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), CreateFlywheelError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[CreateFlywheelError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), CreateFlywheelError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[CreateFlywheelError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), CreateFlywheelError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[CreateFlywheelError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[CreateFlywheelError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), CreateFlywheelError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[CreateFlywheelError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def resourceLimitExceededException(value: ResourceLimitExceededException): A
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def resourceLimitExceededException(value: ResourceLimitExceededException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[CreateFlywheelError] = union(
      CreateFlywheelError.ResourceLimitExceededExceptionCase.alt,
      CreateFlywheelError.InternalServerExceptionCase.alt,
      CreateFlywheelError.TooManyTagsExceptionCase.alt,
      CreateFlywheelError.UnsupportedLanguageExceptionCase.alt,
      CreateFlywheelError.ResourceUnavailableExceptionCase.alt,
      CreateFlywheelError.KmsKeyValidationExceptionCase.alt,
      CreateFlywheelError.ResourceInUseExceptionCase.alt,
      CreateFlywheelError.TooManyRequestsExceptionCase.alt,
      CreateFlywheelError.InvalidRequestExceptionCase.alt,
      CreateFlywheelError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[CreateFlywheelError] = throwable match {
      case e: ResourceLimitExceededException => Some(CreateFlywheelError.ResourceLimitExceededExceptionCase(e))
      case e: InternalServerException => Some(CreateFlywheelError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(CreateFlywheelError.TooManyTagsExceptionCase(e))
      case e: UnsupportedLanguageException => Some(CreateFlywheelError.UnsupportedLanguageExceptionCase(e))
      case e: ResourceUnavailableException => Some(CreateFlywheelError.ResourceUnavailableExceptionCase(e))
      case e: KmsKeyValidationException => Some(CreateFlywheelError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(CreateFlywheelError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(CreateFlywheelError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(CreateFlywheelError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(CreateFlywheelError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: CreateFlywheelError): Throwable = e match {
      case CreateFlywheelError.ResourceLimitExceededExceptionCase(e) => e
      case CreateFlywheelError.InternalServerExceptionCase(e) => e
      case CreateFlywheelError.TooManyTagsExceptionCase(e) => e
      case CreateFlywheelError.UnsupportedLanguageExceptionCase(e) => e
      case CreateFlywheelError.ResourceUnavailableExceptionCase(e) => e
      case CreateFlywheelError.KmsKeyValidationExceptionCase(e) => e
      case CreateFlywheelError.ResourceInUseExceptionCase(e) => e
      case CreateFlywheelError.TooManyRequestsExceptionCase(e) => e
      case CreateFlywheelError.InvalidRequestExceptionCase(e) => e
      case CreateFlywheelError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DeleteDocumentClassifier(input: DeleteDocumentClassifierRequest) extends ComprehendOperation[DeleteDocumentClassifierRequest, ComprehendOperation.DeleteDocumentClassifierError, DeleteDocumentClassifierResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DeleteDocumentClassifierRequest, ComprehendOperation.DeleteDocumentClassifierError, DeleteDocumentClassifierResponse, Nothing, Nothing] = impl.deleteDocumentClassifier(input.documentClassifierArn)
    def ordinal: Int = 13
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DeleteDocumentClassifierRequest, ComprehendOperation.DeleteDocumentClassifierError, DeleteDocumentClassifierResponse, Nothing, Nothing] = DeleteDocumentClassifier
  }
  object DeleteDocumentClassifier extends smithy4s.Endpoint[ComprehendOperation,DeleteDocumentClassifierRequest, ComprehendOperation.DeleteDocumentClassifierError, DeleteDocumentClassifierResponse, Nothing, Nothing] {
    val schema: OperationSchema[DeleteDocumentClassifierRequest, ComprehendOperation.DeleteDocumentClassifierError, DeleteDocumentClassifierResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DeleteDocumentClassifier"))
      .withInput(DeleteDocumentClassifierRequest.schema)
      .withError(DeleteDocumentClassifierError.errorSchema)
      .withOutput(DeleteDocumentClassifierResponse.schema)
      .withHints(smithy.api.Documentation("<p>Deletes a previously created document classifier</p>\n         <p>Only those classifiers that are in terminated states (IN_ERROR, TRAINED) will be deleted.\n      If an active inference job is using the model, a <code>ResourceInUseException</code> will be\n      returned.</p>\n         <p>This is an asynchronous action that puts the classifier into a DELETING state, and it is\n      then removed by a background job. Once removed, the classifier disappears from your account\n      and is no longer available for use. </p>"))
    def wrap(input: DeleteDocumentClassifierRequest): DeleteDocumentClassifier = DeleteDocumentClassifier(input)
  }
  sealed trait DeleteDocumentClassifierError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DeleteDocumentClassifierError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DeleteDocumentClassifierError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = DeleteDocumentClassifierError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def resourceInUseException: Option[ResourceInUseException] = DeleteDocumentClassifierError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DeleteDocumentClassifierError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DeleteDocumentClassifierError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DeleteDocumentClassifierError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DeleteDocumentClassifierError.Visitor[A]): A = this match {
      case value: DeleteDocumentClassifierError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DeleteDocumentClassifierError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: DeleteDocumentClassifierError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: DeleteDocumentClassifierError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DeleteDocumentClassifierError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DeleteDocumentClassifierError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DeleteDocumentClassifierError extends ErrorSchema.Companion[DeleteDocumentClassifierError] {

    def internalServerException(internalServerException: InternalServerException): DeleteDocumentClassifierError = InternalServerExceptionCase(internalServerException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): DeleteDocumentClassifierError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): DeleteDocumentClassifierError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DeleteDocumentClassifierError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DeleteDocumentClassifierError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DeleteDocumentClassifierError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DeleteDocumentClassifierError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DeleteDocumentClassifierError { final def $ordinal: Int = 0 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends DeleteDocumentClassifierError { final def $ordinal: Int = 1 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends DeleteDocumentClassifierError { final def $ordinal: Int = 2 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DeleteDocumentClassifierError { final def $ordinal: Int = 3 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DeleteDocumentClassifierError { final def $ordinal: Int = 4 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DeleteDocumentClassifierError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteDocumentClassifierError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DeleteDocumentClassifierError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DeleteDocumentClassifierError]("InternalServerException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteDocumentClassifierError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), DeleteDocumentClassifierError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[DeleteDocumentClassifierError]("ResourceUnavailableException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteDocumentClassifierError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), DeleteDocumentClassifierError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[DeleteDocumentClassifierError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteDocumentClassifierError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DeleteDocumentClassifierError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DeleteDocumentClassifierError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteDocumentClassifierError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DeleteDocumentClassifierError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DeleteDocumentClassifierError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteDocumentClassifierError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DeleteDocumentClassifierError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DeleteDocumentClassifierError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DeleteDocumentClassifierError] = union(
      DeleteDocumentClassifierError.InternalServerExceptionCase.alt,
      DeleteDocumentClassifierError.ResourceUnavailableExceptionCase.alt,
      DeleteDocumentClassifierError.ResourceInUseExceptionCase.alt,
      DeleteDocumentClassifierError.TooManyRequestsExceptionCase.alt,
      DeleteDocumentClassifierError.InvalidRequestExceptionCase.alt,
      DeleteDocumentClassifierError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DeleteDocumentClassifierError] = throwable match {
      case e: InternalServerException => Some(DeleteDocumentClassifierError.InternalServerExceptionCase(e))
      case e: ResourceUnavailableException => Some(DeleteDocumentClassifierError.ResourceUnavailableExceptionCase(e))
      case e: ResourceInUseException => Some(DeleteDocumentClassifierError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(DeleteDocumentClassifierError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DeleteDocumentClassifierError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DeleteDocumentClassifierError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DeleteDocumentClassifierError): Throwable = e match {
      case DeleteDocumentClassifierError.InternalServerExceptionCase(e) => e
      case DeleteDocumentClassifierError.ResourceUnavailableExceptionCase(e) => e
      case DeleteDocumentClassifierError.ResourceInUseExceptionCase(e) => e
      case DeleteDocumentClassifierError.TooManyRequestsExceptionCase(e) => e
      case DeleteDocumentClassifierError.InvalidRequestExceptionCase(e) => e
      case DeleteDocumentClassifierError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DeleteEndpoint(input: DeleteEndpointRequest) extends ComprehendOperation[DeleteEndpointRequest, ComprehendOperation.DeleteEndpointError, DeleteEndpointResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DeleteEndpointRequest, ComprehendOperation.DeleteEndpointError, DeleteEndpointResponse, Nothing, Nothing] = impl.deleteEndpoint(input.endpointArn)
    def ordinal: Int = 14
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DeleteEndpointRequest, ComprehendOperation.DeleteEndpointError, DeleteEndpointResponse, Nothing, Nothing] = DeleteEndpoint
  }
  object DeleteEndpoint extends smithy4s.Endpoint[ComprehendOperation,DeleteEndpointRequest, ComprehendOperation.DeleteEndpointError, DeleteEndpointResponse, Nothing, Nothing] {
    val schema: OperationSchema[DeleteEndpointRequest, ComprehendOperation.DeleteEndpointError, DeleteEndpointResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DeleteEndpoint"))
      .withInput(DeleteEndpointRequest.schema)
      .withError(DeleteEndpointError.errorSchema)
      .withOutput(DeleteEndpointResponse.schema)
      .withHints(smithy.api.Documentation("<p>Deletes a model-specific endpoint for a previously-trained custom model. All endpoints\n      must be deleted in order for the model to be deleted.\n      For information about endpoints, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html\">Managing endpoints</a>.</p>"))
    def wrap(input: DeleteEndpointRequest): DeleteEndpoint = DeleteEndpoint(input)
  }
  sealed trait DeleteEndpointError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DeleteEndpointError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DeleteEndpointError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def resourceInUseException: Option[ResourceInUseException] = DeleteEndpointError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DeleteEndpointError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DeleteEndpointError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DeleteEndpointError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DeleteEndpointError.Visitor[A]): A = this match {
      case value: DeleteEndpointError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DeleteEndpointError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: DeleteEndpointError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DeleteEndpointError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DeleteEndpointError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DeleteEndpointError extends ErrorSchema.Companion[DeleteEndpointError] {

    def internalServerException(internalServerException: InternalServerException): DeleteEndpointError = InternalServerExceptionCase(internalServerException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): DeleteEndpointError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DeleteEndpointError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DeleteEndpointError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DeleteEndpointError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DeleteEndpointError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DeleteEndpointError { final def $ordinal: Int = 0 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends DeleteEndpointError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DeleteEndpointError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DeleteEndpointError { final def $ordinal: Int = 3 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DeleteEndpointError { final def $ordinal: Int = 4 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEndpointError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DeleteEndpointError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DeleteEndpointError]("InternalServerException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEndpointError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), DeleteEndpointError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[DeleteEndpointError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEndpointError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DeleteEndpointError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DeleteEndpointError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEndpointError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DeleteEndpointError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DeleteEndpointError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEndpointError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DeleteEndpointError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DeleteEndpointError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DeleteEndpointError] = union(
      DeleteEndpointError.InternalServerExceptionCase.alt,
      DeleteEndpointError.ResourceInUseExceptionCase.alt,
      DeleteEndpointError.TooManyRequestsExceptionCase.alt,
      DeleteEndpointError.InvalidRequestExceptionCase.alt,
      DeleteEndpointError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DeleteEndpointError] = throwable match {
      case e: InternalServerException => Some(DeleteEndpointError.InternalServerExceptionCase(e))
      case e: ResourceInUseException => Some(DeleteEndpointError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(DeleteEndpointError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DeleteEndpointError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DeleteEndpointError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DeleteEndpointError): Throwable = e match {
      case DeleteEndpointError.InternalServerExceptionCase(e) => e
      case DeleteEndpointError.ResourceInUseExceptionCase(e) => e
      case DeleteEndpointError.TooManyRequestsExceptionCase(e) => e
      case DeleteEndpointError.InvalidRequestExceptionCase(e) => e
      case DeleteEndpointError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DeleteEntityRecognizer(input: DeleteEntityRecognizerRequest) extends ComprehendOperation[DeleteEntityRecognizerRequest, ComprehendOperation.DeleteEntityRecognizerError, DeleteEntityRecognizerResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DeleteEntityRecognizerRequest, ComprehendOperation.DeleteEntityRecognizerError, DeleteEntityRecognizerResponse, Nothing, Nothing] = impl.deleteEntityRecognizer(input.entityRecognizerArn)
    def ordinal: Int = 15
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DeleteEntityRecognizerRequest, ComprehendOperation.DeleteEntityRecognizerError, DeleteEntityRecognizerResponse, Nothing, Nothing] = DeleteEntityRecognizer
  }
  object DeleteEntityRecognizer extends smithy4s.Endpoint[ComprehendOperation,DeleteEntityRecognizerRequest, ComprehendOperation.DeleteEntityRecognizerError, DeleteEntityRecognizerResponse, Nothing, Nothing] {
    val schema: OperationSchema[DeleteEntityRecognizerRequest, ComprehendOperation.DeleteEntityRecognizerError, DeleteEntityRecognizerResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DeleteEntityRecognizer"))
      .withInput(DeleteEntityRecognizerRequest.schema)
      .withError(DeleteEntityRecognizerError.errorSchema)
      .withOutput(DeleteEntityRecognizerResponse.schema)
      .withHints(smithy.api.Documentation("<p>Deletes an entity recognizer.</p>\n         <p>Only those recognizers that are in terminated states (IN_ERROR, TRAINED) will be deleted.\n      If an active inference job is using the model, a <code>ResourceInUseException</code> will be\n      returned.</p>\n         <p>This is an asynchronous action that puts the recognizer into a DELETING state, and it is\n      then removed by a background job. Once removed, the recognizer disappears from your account\n      and is no longer available for use. </p>"))
    def wrap(input: DeleteEntityRecognizerRequest): DeleteEntityRecognizer = DeleteEntityRecognizer(input)
  }
  sealed trait DeleteEntityRecognizerError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DeleteEntityRecognizerError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DeleteEntityRecognizerError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = DeleteEntityRecognizerError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def resourceInUseException: Option[ResourceInUseException] = DeleteEntityRecognizerError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DeleteEntityRecognizerError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DeleteEntityRecognizerError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DeleteEntityRecognizerError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DeleteEntityRecognizerError.Visitor[A]): A = this match {
      case value: DeleteEntityRecognizerError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DeleteEntityRecognizerError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: DeleteEntityRecognizerError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: DeleteEntityRecognizerError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DeleteEntityRecognizerError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DeleteEntityRecognizerError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DeleteEntityRecognizerError extends ErrorSchema.Companion[DeleteEntityRecognizerError] {

    def internalServerException(internalServerException: InternalServerException): DeleteEntityRecognizerError = InternalServerExceptionCase(internalServerException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): DeleteEntityRecognizerError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): DeleteEntityRecognizerError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DeleteEntityRecognizerError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DeleteEntityRecognizerError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DeleteEntityRecognizerError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DeleteEntityRecognizerError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DeleteEntityRecognizerError { final def $ordinal: Int = 0 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends DeleteEntityRecognizerError { final def $ordinal: Int = 1 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends DeleteEntityRecognizerError { final def $ordinal: Int = 2 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DeleteEntityRecognizerError { final def $ordinal: Int = 3 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DeleteEntityRecognizerError { final def $ordinal: Int = 4 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DeleteEntityRecognizerError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEntityRecognizerError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DeleteEntityRecognizerError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DeleteEntityRecognizerError]("InternalServerException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEntityRecognizerError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), DeleteEntityRecognizerError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[DeleteEntityRecognizerError]("ResourceUnavailableException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEntityRecognizerError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), DeleteEntityRecognizerError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[DeleteEntityRecognizerError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEntityRecognizerError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DeleteEntityRecognizerError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DeleteEntityRecognizerError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEntityRecognizerError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DeleteEntityRecognizerError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DeleteEntityRecognizerError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteEntityRecognizerError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DeleteEntityRecognizerError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DeleteEntityRecognizerError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DeleteEntityRecognizerError] = union(
      DeleteEntityRecognizerError.InternalServerExceptionCase.alt,
      DeleteEntityRecognizerError.ResourceUnavailableExceptionCase.alt,
      DeleteEntityRecognizerError.ResourceInUseExceptionCase.alt,
      DeleteEntityRecognizerError.TooManyRequestsExceptionCase.alt,
      DeleteEntityRecognizerError.InvalidRequestExceptionCase.alt,
      DeleteEntityRecognizerError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DeleteEntityRecognizerError] = throwable match {
      case e: InternalServerException => Some(DeleteEntityRecognizerError.InternalServerExceptionCase(e))
      case e: ResourceUnavailableException => Some(DeleteEntityRecognizerError.ResourceUnavailableExceptionCase(e))
      case e: ResourceInUseException => Some(DeleteEntityRecognizerError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(DeleteEntityRecognizerError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DeleteEntityRecognizerError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DeleteEntityRecognizerError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DeleteEntityRecognizerError): Throwable = e match {
      case DeleteEntityRecognizerError.InternalServerExceptionCase(e) => e
      case DeleteEntityRecognizerError.ResourceUnavailableExceptionCase(e) => e
      case DeleteEntityRecognizerError.ResourceInUseExceptionCase(e) => e
      case DeleteEntityRecognizerError.TooManyRequestsExceptionCase(e) => e
      case DeleteEntityRecognizerError.InvalidRequestExceptionCase(e) => e
      case DeleteEntityRecognizerError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DeleteFlywheel(input: DeleteFlywheelRequest) extends ComprehendOperation[DeleteFlywheelRequest, ComprehendOperation.DeleteFlywheelError, DeleteFlywheelResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DeleteFlywheelRequest, ComprehendOperation.DeleteFlywheelError, DeleteFlywheelResponse, Nothing, Nothing] = impl.deleteFlywheel(input.flywheelArn)
    def ordinal: Int = 16
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DeleteFlywheelRequest, ComprehendOperation.DeleteFlywheelError, DeleteFlywheelResponse, Nothing, Nothing] = DeleteFlywheel
  }
  object DeleteFlywheel extends smithy4s.Endpoint[ComprehendOperation,DeleteFlywheelRequest, ComprehendOperation.DeleteFlywheelError, DeleteFlywheelResponse, Nothing, Nothing] {
    val schema: OperationSchema[DeleteFlywheelRequest, ComprehendOperation.DeleteFlywheelError, DeleteFlywheelResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DeleteFlywheel"))
      .withInput(DeleteFlywheelRequest.schema)
      .withError(DeleteFlywheelError.errorSchema)
      .withOutput(DeleteFlywheelResponse.schema)
      .withHints(smithy.api.Documentation("<p>Deletes a flywheel. When you delete the flywheel, Amazon Comprehend\n      does not delete the data lake or the model associated with the flywheel.</p>\n         <p>For more information about flywheels, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html\">\n      Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>"))
    def wrap(input: DeleteFlywheelRequest): DeleteFlywheel = DeleteFlywheel(input)
  }
  sealed trait DeleteFlywheelError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DeleteFlywheelError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DeleteFlywheelError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = DeleteFlywheelError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def resourceInUseException: Option[ResourceInUseException] = DeleteFlywheelError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DeleteFlywheelError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DeleteFlywheelError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DeleteFlywheelError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DeleteFlywheelError.Visitor[A]): A = this match {
      case value: DeleteFlywheelError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DeleteFlywheelError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: DeleteFlywheelError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: DeleteFlywheelError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DeleteFlywheelError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DeleteFlywheelError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DeleteFlywheelError extends ErrorSchema.Companion[DeleteFlywheelError] {

    def internalServerException(internalServerException: InternalServerException): DeleteFlywheelError = InternalServerExceptionCase(internalServerException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): DeleteFlywheelError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): DeleteFlywheelError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DeleteFlywheelError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DeleteFlywheelError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DeleteFlywheelError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DeleteFlywheelError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DeleteFlywheelError { final def $ordinal: Int = 0 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends DeleteFlywheelError { final def $ordinal: Int = 1 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends DeleteFlywheelError { final def $ordinal: Int = 2 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DeleteFlywheelError { final def $ordinal: Int = 3 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DeleteFlywheelError { final def $ordinal: Int = 4 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DeleteFlywheelError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteFlywheelError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DeleteFlywheelError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DeleteFlywheelError]("InternalServerException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteFlywheelError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), DeleteFlywheelError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[DeleteFlywheelError]("ResourceUnavailableException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteFlywheelError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), DeleteFlywheelError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[DeleteFlywheelError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteFlywheelError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DeleteFlywheelError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DeleteFlywheelError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteFlywheelError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DeleteFlywheelError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DeleteFlywheelError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteFlywheelError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DeleteFlywheelError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DeleteFlywheelError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DeleteFlywheelError] = union(
      DeleteFlywheelError.InternalServerExceptionCase.alt,
      DeleteFlywheelError.ResourceUnavailableExceptionCase.alt,
      DeleteFlywheelError.ResourceInUseExceptionCase.alt,
      DeleteFlywheelError.TooManyRequestsExceptionCase.alt,
      DeleteFlywheelError.InvalidRequestExceptionCase.alt,
      DeleteFlywheelError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DeleteFlywheelError] = throwable match {
      case e: InternalServerException => Some(DeleteFlywheelError.InternalServerExceptionCase(e))
      case e: ResourceUnavailableException => Some(DeleteFlywheelError.ResourceUnavailableExceptionCase(e))
      case e: ResourceInUseException => Some(DeleteFlywheelError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(DeleteFlywheelError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DeleteFlywheelError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DeleteFlywheelError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DeleteFlywheelError): Throwable = e match {
      case DeleteFlywheelError.InternalServerExceptionCase(e) => e
      case DeleteFlywheelError.ResourceUnavailableExceptionCase(e) => e
      case DeleteFlywheelError.ResourceInUseExceptionCase(e) => e
      case DeleteFlywheelError.TooManyRequestsExceptionCase(e) => e
      case DeleteFlywheelError.InvalidRequestExceptionCase(e) => e
      case DeleteFlywheelError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DeleteResourcePolicy(input: DeleteResourcePolicyRequest) extends ComprehendOperation[DeleteResourcePolicyRequest, ComprehendOperation.DeleteResourcePolicyError, DeleteResourcePolicyResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DeleteResourcePolicyRequest, ComprehendOperation.DeleteResourcePolicyError, DeleteResourcePolicyResponse, Nothing, Nothing] = impl.deleteResourcePolicy(input.resourceArn, input.policyRevisionId)
    def ordinal: Int = 17
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DeleteResourcePolicyRequest, ComprehendOperation.DeleteResourcePolicyError, DeleteResourcePolicyResponse, Nothing, Nothing] = DeleteResourcePolicy
  }
  object DeleteResourcePolicy extends smithy4s.Endpoint[ComprehendOperation,DeleteResourcePolicyRequest, ComprehendOperation.DeleteResourcePolicyError, DeleteResourcePolicyResponse, Nothing, Nothing] {
    val schema: OperationSchema[DeleteResourcePolicyRequest, ComprehendOperation.DeleteResourcePolicyError, DeleteResourcePolicyResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DeleteResourcePolicy"))
      .withInput(DeleteResourcePolicyRequest.schema)
      .withError(DeleteResourcePolicyError.errorSchema)
      .withOutput(DeleteResourcePolicyResponse.schema)
      .withHints(smithy.api.Documentation("<p>Deletes a resource-based policy that is attached to a custom model.</p>"))
    def wrap(input: DeleteResourcePolicyRequest): DeleteResourcePolicy = DeleteResourcePolicy(input)
  }
  sealed trait DeleteResourcePolicyError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DeleteResourcePolicyError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DeleteResourcePolicyError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = DeleteResourcePolicyError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DeleteResourcePolicyError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DeleteResourcePolicyError.Visitor[A]): A = this match {
      case value: DeleteResourcePolicyError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DeleteResourcePolicyError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DeleteResourcePolicyError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DeleteResourcePolicyError extends ErrorSchema.Companion[DeleteResourcePolicyError] {

    def internalServerException(internalServerException: InternalServerException): DeleteResourcePolicyError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DeleteResourcePolicyError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DeleteResourcePolicyError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DeleteResourcePolicyError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DeleteResourcePolicyError { final def $ordinal: Int = 0 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DeleteResourcePolicyError { final def $ordinal: Int = 1 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DeleteResourcePolicyError { final def $ordinal: Int = 2 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteResourcePolicyError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DeleteResourcePolicyError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DeleteResourcePolicyError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteResourcePolicyError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DeleteResourcePolicyError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DeleteResourcePolicyError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DeleteResourcePolicyError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DeleteResourcePolicyError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DeleteResourcePolicyError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DeleteResourcePolicyError] = union(
      DeleteResourcePolicyError.InternalServerExceptionCase.alt,
      DeleteResourcePolicyError.InvalidRequestExceptionCase.alt,
      DeleteResourcePolicyError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DeleteResourcePolicyError] = throwable match {
      case e: InternalServerException => Some(DeleteResourcePolicyError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(DeleteResourcePolicyError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DeleteResourcePolicyError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DeleteResourcePolicyError): Throwable = e match {
      case DeleteResourcePolicyError.InternalServerExceptionCase(e) => e
      case DeleteResourcePolicyError.InvalidRequestExceptionCase(e) => e
      case DeleteResourcePolicyError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DescribeDataset(input: DescribeDatasetRequest) extends ComprehendOperation[DescribeDatasetRequest, ComprehendOperation.DescribeDatasetError, DescribeDatasetResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeDatasetRequest, ComprehendOperation.DescribeDatasetError, DescribeDatasetResponse, Nothing, Nothing] = impl.describeDataset(input.datasetArn)
    def ordinal: Int = 18
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeDatasetRequest, ComprehendOperation.DescribeDatasetError, DescribeDatasetResponse, Nothing, Nothing] = DescribeDataset
  }
  object DescribeDataset extends smithy4s.Endpoint[ComprehendOperation,DescribeDatasetRequest, ComprehendOperation.DescribeDatasetError, DescribeDatasetResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeDatasetRequest, ComprehendOperation.DescribeDatasetError, DescribeDatasetResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeDataset"))
      .withInput(DescribeDatasetRequest.schema)
      .withError(DescribeDatasetError.errorSchema)
      .withOutput(DescribeDatasetResponse.schema)
      .withHints(smithy.api.Documentation("<p>Returns information about the dataset that you specify.\n      For more information about datasets, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html\">\n      Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>"))
    def wrap(input: DescribeDatasetRequest): DescribeDataset = DescribeDataset(input)
  }
  sealed trait DescribeDatasetError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeDatasetError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DescribeDatasetError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeDatasetError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeDatasetError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DescribeDatasetError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DescribeDatasetError.Visitor[A]): A = this match {
      case value: DescribeDatasetError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeDatasetError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeDatasetError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DescribeDatasetError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DescribeDatasetError extends ErrorSchema.Companion[DescribeDatasetError] {

    def internalServerException(internalServerException: InternalServerException): DescribeDatasetError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeDatasetError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeDatasetError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DescribeDatasetError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeDatasetError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeDatasetError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeDatasetError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeDatasetError { final def $ordinal: Int = 2 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DescribeDatasetError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDatasetError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeDatasetError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeDatasetError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDatasetError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeDatasetError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeDatasetError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDatasetError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeDatasetError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeDatasetError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDatasetError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DescribeDatasetError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DescribeDatasetError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DescribeDatasetError] = union(
      DescribeDatasetError.InternalServerExceptionCase.alt,
      DescribeDatasetError.TooManyRequestsExceptionCase.alt,
      DescribeDatasetError.InvalidRequestExceptionCase.alt,
      DescribeDatasetError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeDatasetError] = throwable match {
      case e: InternalServerException => Some(DescribeDatasetError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeDatasetError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeDatasetError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DescribeDatasetError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeDatasetError): Throwable = e match {
      case DescribeDatasetError.InternalServerExceptionCase(e) => e
      case DescribeDatasetError.TooManyRequestsExceptionCase(e) => e
      case DescribeDatasetError.InvalidRequestExceptionCase(e) => e
      case DescribeDatasetError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DescribeDocumentClassificationJob(input: DescribeDocumentClassificationJobRequest) extends ComprehendOperation[DescribeDocumentClassificationJobRequest, ComprehendOperation.DescribeDocumentClassificationJobError, DescribeDocumentClassificationJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeDocumentClassificationJobRequest, ComprehendOperation.DescribeDocumentClassificationJobError, DescribeDocumentClassificationJobResponse, Nothing, Nothing] = impl.describeDocumentClassificationJob(input.jobId)
    def ordinal: Int = 19
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeDocumentClassificationJobRequest, ComprehendOperation.DescribeDocumentClassificationJobError, DescribeDocumentClassificationJobResponse, Nothing, Nothing] = DescribeDocumentClassificationJob
  }
  object DescribeDocumentClassificationJob extends smithy4s.Endpoint[ComprehendOperation,DescribeDocumentClassificationJobRequest, ComprehendOperation.DescribeDocumentClassificationJobError, DescribeDocumentClassificationJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeDocumentClassificationJobRequest, ComprehendOperation.DescribeDocumentClassificationJobError, DescribeDocumentClassificationJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeDocumentClassificationJob"))
      .withInput(DescribeDocumentClassificationJobRequest.schema)
      .withError(DescribeDocumentClassificationJobError.errorSchema)
      .withOutput(DescribeDocumentClassificationJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with a document classification job. Use this operation to\n      get the status of a classification job.</p>"))
    def wrap(input: DescribeDocumentClassificationJobRequest): DescribeDocumentClassificationJob = DescribeDocumentClassificationJob(input)
  }
  sealed trait DescribeDocumentClassificationJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeDocumentClassificationJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = DescribeDocumentClassificationJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = DescribeDocumentClassificationJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeDocumentClassificationJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeDocumentClassificationJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DescribeDocumentClassificationJobError.Visitor[A]): A = this match {
      case value: DescribeDocumentClassificationJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: DescribeDocumentClassificationJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeDocumentClassificationJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeDocumentClassificationJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DescribeDocumentClassificationJobError extends ErrorSchema.Companion[DescribeDocumentClassificationJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): DescribeDocumentClassificationJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): DescribeDocumentClassificationJobError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeDocumentClassificationJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeDocumentClassificationJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeDocumentClassificationJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends DescribeDocumentClassificationJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeDocumentClassificationJobError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeDocumentClassificationJobError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeDocumentClassificationJobError { final def $ordinal: Int = 3 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDocumentClassificationJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), DescribeDocumentClassificationJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[DescribeDocumentClassificationJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDocumentClassificationJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeDocumentClassificationJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeDocumentClassificationJobError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDocumentClassificationJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeDocumentClassificationJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeDocumentClassificationJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDocumentClassificationJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeDocumentClassificationJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeDocumentClassificationJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DescribeDocumentClassificationJobError] = union(
      DescribeDocumentClassificationJobError.JobNotFoundExceptionCase.alt,
      DescribeDocumentClassificationJobError.InternalServerExceptionCase.alt,
      DescribeDocumentClassificationJobError.TooManyRequestsExceptionCase.alt,
      DescribeDocumentClassificationJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeDocumentClassificationJobError] = throwable match {
      case e: JobNotFoundException => Some(DescribeDocumentClassificationJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(DescribeDocumentClassificationJobError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeDocumentClassificationJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeDocumentClassificationJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeDocumentClassificationJobError): Throwable = e match {
      case DescribeDocumentClassificationJobError.JobNotFoundExceptionCase(e) => e
      case DescribeDocumentClassificationJobError.InternalServerExceptionCase(e) => e
      case DescribeDocumentClassificationJobError.TooManyRequestsExceptionCase(e) => e
      case DescribeDocumentClassificationJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DescribeDocumentClassifier(input: DescribeDocumentClassifierRequest) extends ComprehendOperation[DescribeDocumentClassifierRequest, ComprehendOperation.DescribeDocumentClassifierError, DescribeDocumentClassifierResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeDocumentClassifierRequest, ComprehendOperation.DescribeDocumentClassifierError, DescribeDocumentClassifierResponse, Nothing, Nothing] = impl.describeDocumentClassifier(input.documentClassifierArn)
    def ordinal: Int = 20
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeDocumentClassifierRequest, ComprehendOperation.DescribeDocumentClassifierError, DescribeDocumentClassifierResponse, Nothing, Nothing] = DescribeDocumentClassifier
  }
  object DescribeDocumentClassifier extends smithy4s.Endpoint[ComprehendOperation,DescribeDocumentClassifierRequest, ComprehendOperation.DescribeDocumentClassifierError, DescribeDocumentClassifierResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeDocumentClassifierRequest, ComprehendOperation.DescribeDocumentClassifierError, DescribeDocumentClassifierResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeDocumentClassifier"))
      .withInput(DescribeDocumentClassifierRequest.schema)
      .withError(DescribeDocumentClassifierError.errorSchema)
      .withOutput(DescribeDocumentClassifierResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with a document classifier.</p>"))
    def wrap(input: DescribeDocumentClassifierRequest): DescribeDocumentClassifier = DescribeDocumentClassifier(input)
  }
  sealed trait DescribeDocumentClassifierError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeDocumentClassifierError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DescribeDocumentClassifierError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeDocumentClassifierError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeDocumentClassifierError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DescribeDocumentClassifierError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DescribeDocumentClassifierError.Visitor[A]): A = this match {
      case value: DescribeDocumentClassifierError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeDocumentClassifierError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeDocumentClassifierError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DescribeDocumentClassifierError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DescribeDocumentClassifierError extends ErrorSchema.Companion[DescribeDocumentClassifierError] {

    def internalServerException(internalServerException: InternalServerException): DescribeDocumentClassifierError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeDocumentClassifierError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeDocumentClassifierError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DescribeDocumentClassifierError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeDocumentClassifierError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeDocumentClassifierError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeDocumentClassifierError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeDocumentClassifierError { final def $ordinal: Int = 2 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DescribeDocumentClassifierError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDocumentClassifierError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeDocumentClassifierError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeDocumentClassifierError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDocumentClassifierError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeDocumentClassifierError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeDocumentClassifierError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDocumentClassifierError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeDocumentClassifierError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeDocumentClassifierError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDocumentClassifierError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DescribeDocumentClassifierError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DescribeDocumentClassifierError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DescribeDocumentClassifierError] = union(
      DescribeDocumentClassifierError.InternalServerExceptionCase.alt,
      DescribeDocumentClassifierError.TooManyRequestsExceptionCase.alt,
      DescribeDocumentClassifierError.InvalidRequestExceptionCase.alt,
      DescribeDocumentClassifierError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeDocumentClassifierError] = throwable match {
      case e: InternalServerException => Some(DescribeDocumentClassifierError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeDocumentClassifierError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeDocumentClassifierError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DescribeDocumentClassifierError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeDocumentClassifierError): Throwable = e match {
      case DescribeDocumentClassifierError.InternalServerExceptionCase(e) => e
      case DescribeDocumentClassifierError.TooManyRequestsExceptionCase(e) => e
      case DescribeDocumentClassifierError.InvalidRequestExceptionCase(e) => e
      case DescribeDocumentClassifierError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DescribeDominantLanguageDetectionJob(input: DescribeDominantLanguageDetectionJobRequest) extends ComprehendOperation[DescribeDominantLanguageDetectionJobRequest, ComprehendOperation.DescribeDominantLanguageDetectionJobError, DescribeDominantLanguageDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeDominantLanguageDetectionJobRequest, ComprehendOperation.DescribeDominantLanguageDetectionJobError, DescribeDominantLanguageDetectionJobResponse, Nothing, Nothing] = impl.describeDominantLanguageDetectionJob(input.jobId)
    def ordinal: Int = 21
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeDominantLanguageDetectionJobRequest, ComprehendOperation.DescribeDominantLanguageDetectionJobError, DescribeDominantLanguageDetectionJobResponse, Nothing, Nothing] = DescribeDominantLanguageDetectionJob
  }
  object DescribeDominantLanguageDetectionJob extends smithy4s.Endpoint[ComprehendOperation,DescribeDominantLanguageDetectionJobRequest, ComprehendOperation.DescribeDominantLanguageDetectionJobError, DescribeDominantLanguageDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeDominantLanguageDetectionJobRequest, ComprehendOperation.DescribeDominantLanguageDetectionJobError, DescribeDominantLanguageDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeDominantLanguageDetectionJob"))
      .withInput(DescribeDominantLanguageDetectionJobRequest.schema)
      .withError(DescribeDominantLanguageDetectionJobError.errorSchema)
      .withOutput(DescribeDominantLanguageDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with a dominant language detection job. Use this operation\n      to get the status of a detection job.</p>"))
    def wrap(input: DescribeDominantLanguageDetectionJobRequest): DescribeDominantLanguageDetectionJob = DescribeDominantLanguageDetectionJob(input)
  }
  sealed trait DescribeDominantLanguageDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeDominantLanguageDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = DescribeDominantLanguageDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = DescribeDominantLanguageDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeDominantLanguageDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeDominantLanguageDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DescribeDominantLanguageDetectionJobError.Visitor[A]): A = this match {
      case value: DescribeDominantLanguageDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: DescribeDominantLanguageDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeDominantLanguageDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeDominantLanguageDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DescribeDominantLanguageDetectionJobError extends ErrorSchema.Companion[DescribeDominantLanguageDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): DescribeDominantLanguageDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): DescribeDominantLanguageDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeDominantLanguageDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeDominantLanguageDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeDominantLanguageDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends DescribeDominantLanguageDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeDominantLanguageDetectionJobError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeDominantLanguageDetectionJobError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeDominantLanguageDetectionJobError { final def $ordinal: Int = 3 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDominantLanguageDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), DescribeDominantLanguageDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[DescribeDominantLanguageDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDominantLanguageDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeDominantLanguageDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeDominantLanguageDetectionJobError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDominantLanguageDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeDominantLanguageDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeDominantLanguageDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeDominantLanguageDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeDominantLanguageDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeDominantLanguageDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DescribeDominantLanguageDetectionJobError] = union(
      DescribeDominantLanguageDetectionJobError.JobNotFoundExceptionCase.alt,
      DescribeDominantLanguageDetectionJobError.InternalServerExceptionCase.alt,
      DescribeDominantLanguageDetectionJobError.TooManyRequestsExceptionCase.alt,
      DescribeDominantLanguageDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeDominantLanguageDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(DescribeDominantLanguageDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(DescribeDominantLanguageDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeDominantLanguageDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeDominantLanguageDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeDominantLanguageDetectionJobError): Throwable = e match {
      case DescribeDominantLanguageDetectionJobError.JobNotFoundExceptionCase(e) => e
      case DescribeDominantLanguageDetectionJobError.InternalServerExceptionCase(e) => e
      case DescribeDominantLanguageDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case DescribeDominantLanguageDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DescribeEndpoint(input: DescribeEndpointRequest) extends ComprehendOperation[DescribeEndpointRequest, ComprehendOperation.DescribeEndpointError, DescribeEndpointResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeEndpointRequest, ComprehendOperation.DescribeEndpointError, DescribeEndpointResponse, Nothing, Nothing] = impl.describeEndpoint(input.endpointArn)
    def ordinal: Int = 22
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeEndpointRequest, ComprehendOperation.DescribeEndpointError, DescribeEndpointResponse, Nothing, Nothing] = DescribeEndpoint
  }
  object DescribeEndpoint extends smithy4s.Endpoint[ComprehendOperation,DescribeEndpointRequest, ComprehendOperation.DescribeEndpointError, DescribeEndpointResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeEndpointRequest, ComprehendOperation.DescribeEndpointError, DescribeEndpointResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeEndpoint"))
      .withInput(DescribeEndpointRequest.schema)
      .withError(DescribeEndpointError.errorSchema)
      .withOutput(DescribeEndpointResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with a specific endpoint. Use this operation to get the\n      status of an endpoint.\n      For information about endpoints, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html\">Managing endpoints</a>.</p>"))
    def wrap(input: DescribeEndpointRequest): DescribeEndpoint = DescribeEndpoint(input)
  }
  sealed trait DescribeEndpointError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeEndpointError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DescribeEndpointError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeEndpointError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeEndpointError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DescribeEndpointError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DescribeEndpointError.Visitor[A]): A = this match {
      case value: DescribeEndpointError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeEndpointError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeEndpointError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DescribeEndpointError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DescribeEndpointError extends ErrorSchema.Companion[DescribeEndpointError] {

    def internalServerException(internalServerException: InternalServerException): DescribeEndpointError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeEndpointError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeEndpointError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DescribeEndpointError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeEndpointError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeEndpointError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeEndpointError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeEndpointError { final def $ordinal: Int = 2 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DescribeEndpointError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEndpointError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeEndpointError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeEndpointError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEndpointError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeEndpointError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeEndpointError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEndpointError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeEndpointError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeEndpointError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEndpointError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DescribeEndpointError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DescribeEndpointError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DescribeEndpointError] = union(
      DescribeEndpointError.InternalServerExceptionCase.alt,
      DescribeEndpointError.TooManyRequestsExceptionCase.alt,
      DescribeEndpointError.InvalidRequestExceptionCase.alt,
      DescribeEndpointError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeEndpointError] = throwable match {
      case e: InternalServerException => Some(DescribeEndpointError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeEndpointError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeEndpointError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DescribeEndpointError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeEndpointError): Throwable = e match {
      case DescribeEndpointError.InternalServerExceptionCase(e) => e
      case DescribeEndpointError.TooManyRequestsExceptionCase(e) => e
      case DescribeEndpointError.InvalidRequestExceptionCase(e) => e
      case DescribeEndpointError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DescribeEntitiesDetectionJob(input: DescribeEntitiesDetectionJobRequest) extends ComprehendOperation[DescribeEntitiesDetectionJobRequest, ComprehendOperation.DescribeEntitiesDetectionJobError, DescribeEntitiesDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeEntitiesDetectionJobRequest, ComprehendOperation.DescribeEntitiesDetectionJobError, DescribeEntitiesDetectionJobResponse, Nothing, Nothing] = impl.describeEntitiesDetectionJob(input.jobId)
    def ordinal: Int = 23
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeEntitiesDetectionJobRequest, ComprehendOperation.DescribeEntitiesDetectionJobError, DescribeEntitiesDetectionJobResponse, Nothing, Nothing] = DescribeEntitiesDetectionJob
  }
  object DescribeEntitiesDetectionJob extends smithy4s.Endpoint[ComprehendOperation,DescribeEntitiesDetectionJobRequest, ComprehendOperation.DescribeEntitiesDetectionJobError, DescribeEntitiesDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeEntitiesDetectionJobRequest, ComprehendOperation.DescribeEntitiesDetectionJobError, DescribeEntitiesDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeEntitiesDetectionJob"))
      .withInput(DescribeEntitiesDetectionJobRequest.schema)
      .withError(DescribeEntitiesDetectionJobError.errorSchema)
      .withOutput(DescribeEntitiesDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with an entities detection job. Use this operation to get\n      the status of a detection job.</p>"))
    def wrap(input: DescribeEntitiesDetectionJobRequest): DescribeEntitiesDetectionJob = DescribeEntitiesDetectionJob(input)
  }
  sealed trait DescribeEntitiesDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeEntitiesDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = DescribeEntitiesDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = DescribeEntitiesDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeEntitiesDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeEntitiesDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DescribeEntitiesDetectionJobError.Visitor[A]): A = this match {
      case value: DescribeEntitiesDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: DescribeEntitiesDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeEntitiesDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeEntitiesDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DescribeEntitiesDetectionJobError extends ErrorSchema.Companion[DescribeEntitiesDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): DescribeEntitiesDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): DescribeEntitiesDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeEntitiesDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeEntitiesDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeEntitiesDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends DescribeEntitiesDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeEntitiesDetectionJobError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeEntitiesDetectionJobError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeEntitiesDetectionJobError { final def $ordinal: Int = 3 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEntitiesDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), DescribeEntitiesDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[DescribeEntitiesDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEntitiesDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeEntitiesDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeEntitiesDetectionJobError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEntitiesDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeEntitiesDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeEntitiesDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEntitiesDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeEntitiesDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeEntitiesDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DescribeEntitiesDetectionJobError] = union(
      DescribeEntitiesDetectionJobError.JobNotFoundExceptionCase.alt,
      DescribeEntitiesDetectionJobError.InternalServerExceptionCase.alt,
      DescribeEntitiesDetectionJobError.TooManyRequestsExceptionCase.alt,
      DescribeEntitiesDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeEntitiesDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(DescribeEntitiesDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(DescribeEntitiesDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeEntitiesDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeEntitiesDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeEntitiesDetectionJobError): Throwable = e match {
      case DescribeEntitiesDetectionJobError.JobNotFoundExceptionCase(e) => e
      case DescribeEntitiesDetectionJobError.InternalServerExceptionCase(e) => e
      case DescribeEntitiesDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case DescribeEntitiesDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DescribeEntityRecognizer(input: DescribeEntityRecognizerRequest) extends ComprehendOperation[DescribeEntityRecognizerRequest, ComprehendOperation.DescribeEntityRecognizerError, DescribeEntityRecognizerResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeEntityRecognizerRequest, ComprehendOperation.DescribeEntityRecognizerError, DescribeEntityRecognizerResponse, Nothing, Nothing] = impl.describeEntityRecognizer(input.entityRecognizerArn)
    def ordinal: Int = 24
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeEntityRecognizerRequest, ComprehendOperation.DescribeEntityRecognizerError, DescribeEntityRecognizerResponse, Nothing, Nothing] = DescribeEntityRecognizer
  }
  object DescribeEntityRecognizer extends smithy4s.Endpoint[ComprehendOperation,DescribeEntityRecognizerRequest, ComprehendOperation.DescribeEntityRecognizerError, DescribeEntityRecognizerResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeEntityRecognizerRequest, ComprehendOperation.DescribeEntityRecognizerError, DescribeEntityRecognizerResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeEntityRecognizer"))
      .withInput(DescribeEntityRecognizerRequest.schema)
      .withError(DescribeEntityRecognizerError.errorSchema)
      .withOutput(DescribeEntityRecognizerResponse.schema)
      .withHints(smithy.api.Documentation("<p>Provides details about an entity recognizer including status, S3 buckets containing\n      training data, recognizer metadata, metrics, and so on.</p>"))
    def wrap(input: DescribeEntityRecognizerRequest): DescribeEntityRecognizer = DescribeEntityRecognizer(input)
  }
  sealed trait DescribeEntityRecognizerError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeEntityRecognizerError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DescribeEntityRecognizerError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeEntityRecognizerError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeEntityRecognizerError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DescribeEntityRecognizerError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DescribeEntityRecognizerError.Visitor[A]): A = this match {
      case value: DescribeEntityRecognizerError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeEntityRecognizerError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeEntityRecognizerError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DescribeEntityRecognizerError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DescribeEntityRecognizerError extends ErrorSchema.Companion[DescribeEntityRecognizerError] {

    def internalServerException(internalServerException: InternalServerException): DescribeEntityRecognizerError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeEntityRecognizerError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeEntityRecognizerError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DescribeEntityRecognizerError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeEntityRecognizerError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeEntityRecognizerError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeEntityRecognizerError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeEntityRecognizerError { final def $ordinal: Int = 2 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DescribeEntityRecognizerError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEntityRecognizerError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeEntityRecognizerError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeEntityRecognizerError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEntityRecognizerError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeEntityRecognizerError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeEntityRecognizerError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEntityRecognizerError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeEntityRecognizerError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeEntityRecognizerError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEntityRecognizerError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DescribeEntityRecognizerError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DescribeEntityRecognizerError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DescribeEntityRecognizerError] = union(
      DescribeEntityRecognizerError.InternalServerExceptionCase.alt,
      DescribeEntityRecognizerError.TooManyRequestsExceptionCase.alt,
      DescribeEntityRecognizerError.InvalidRequestExceptionCase.alt,
      DescribeEntityRecognizerError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeEntityRecognizerError] = throwable match {
      case e: InternalServerException => Some(DescribeEntityRecognizerError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeEntityRecognizerError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeEntityRecognizerError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DescribeEntityRecognizerError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeEntityRecognizerError): Throwable = e match {
      case DescribeEntityRecognizerError.InternalServerExceptionCase(e) => e
      case DescribeEntityRecognizerError.TooManyRequestsExceptionCase(e) => e
      case DescribeEntityRecognizerError.InvalidRequestExceptionCase(e) => e
      case DescribeEntityRecognizerError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DescribeEventsDetectionJob(input: DescribeEventsDetectionJobRequest) extends ComprehendOperation[DescribeEventsDetectionJobRequest, ComprehendOperation.DescribeEventsDetectionJobError, DescribeEventsDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeEventsDetectionJobRequest, ComprehendOperation.DescribeEventsDetectionJobError, DescribeEventsDetectionJobResponse, Nothing, Nothing] = impl.describeEventsDetectionJob(input.jobId)
    def ordinal: Int = 25
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeEventsDetectionJobRequest, ComprehendOperation.DescribeEventsDetectionJobError, DescribeEventsDetectionJobResponse, Nothing, Nothing] = DescribeEventsDetectionJob
  }
  object DescribeEventsDetectionJob extends smithy4s.Endpoint[ComprehendOperation,DescribeEventsDetectionJobRequest, ComprehendOperation.DescribeEventsDetectionJobError, DescribeEventsDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeEventsDetectionJobRequest, ComprehendOperation.DescribeEventsDetectionJobError, DescribeEventsDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeEventsDetectionJob"))
      .withInput(DescribeEventsDetectionJobRequest.schema)
      .withError(DescribeEventsDetectionJobError.errorSchema)
      .withOutput(DescribeEventsDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the status and details of an events detection job.</p>"))
    def wrap(input: DescribeEventsDetectionJobRequest): DescribeEventsDetectionJob = DescribeEventsDetectionJob(input)
  }
  sealed trait DescribeEventsDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeEventsDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = DescribeEventsDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = DescribeEventsDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeEventsDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeEventsDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DescribeEventsDetectionJobError.Visitor[A]): A = this match {
      case value: DescribeEventsDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: DescribeEventsDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeEventsDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeEventsDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DescribeEventsDetectionJobError extends ErrorSchema.Companion[DescribeEventsDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): DescribeEventsDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): DescribeEventsDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeEventsDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeEventsDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeEventsDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends DescribeEventsDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeEventsDetectionJobError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeEventsDetectionJobError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeEventsDetectionJobError { final def $ordinal: Int = 3 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEventsDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), DescribeEventsDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[DescribeEventsDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEventsDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeEventsDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeEventsDetectionJobError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEventsDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeEventsDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeEventsDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeEventsDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeEventsDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeEventsDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DescribeEventsDetectionJobError] = union(
      DescribeEventsDetectionJobError.JobNotFoundExceptionCase.alt,
      DescribeEventsDetectionJobError.InternalServerExceptionCase.alt,
      DescribeEventsDetectionJobError.TooManyRequestsExceptionCase.alt,
      DescribeEventsDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeEventsDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(DescribeEventsDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(DescribeEventsDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeEventsDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeEventsDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeEventsDetectionJobError): Throwable = e match {
      case DescribeEventsDetectionJobError.JobNotFoundExceptionCase(e) => e
      case DescribeEventsDetectionJobError.InternalServerExceptionCase(e) => e
      case DescribeEventsDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case DescribeEventsDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DescribeFlywheel(input: DescribeFlywheelRequest) extends ComprehendOperation[DescribeFlywheelRequest, ComprehendOperation.DescribeFlywheelError, DescribeFlywheelResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeFlywheelRequest, ComprehendOperation.DescribeFlywheelError, DescribeFlywheelResponse, Nothing, Nothing] = impl.describeFlywheel(input.flywheelArn)
    def ordinal: Int = 26
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeFlywheelRequest, ComprehendOperation.DescribeFlywheelError, DescribeFlywheelResponse, Nothing, Nothing] = DescribeFlywheel
  }
  object DescribeFlywheel extends smithy4s.Endpoint[ComprehendOperation,DescribeFlywheelRequest, ComprehendOperation.DescribeFlywheelError, DescribeFlywheelResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeFlywheelRequest, ComprehendOperation.DescribeFlywheelError, DescribeFlywheelResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeFlywheel"))
      .withInput(DescribeFlywheelRequest.schema)
      .withError(DescribeFlywheelError.errorSchema)
      .withOutput(DescribeFlywheelResponse.schema)
      .withHints(smithy.api.Documentation("<p>Provides configuration information about the flywheel. For more information about flywheels, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html\">\n      Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>"))
    def wrap(input: DescribeFlywheelRequest): DescribeFlywheel = DescribeFlywheel(input)
  }
  sealed trait DescribeFlywheelError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeFlywheelError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DescribeFlywheelError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeFlywheelError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeFlywheelError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DescribeFlywheelError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DescribeFlywheelError.Visitor[A]): A = this match {
      case value: DescribeFlywheelError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeFlywheelError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeFlywheelError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DescribeFlywheelError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DescribeFlywheelError extends ErrorSchema.Companion[DescribeFlywheelError] {

    def internalServerException(internalServerException: InternalServerException): DescribeFlywheelError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeFlywheelError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeFlywheelError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DescribeFlywheelError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeFlywheelError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeFlywheelError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeFlywheelError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeFlywheelError { final def $ordinal: Int = 2 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DescribeFlywheelError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeFlywheelError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeFlywheelError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeFlywheelError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeFlywheelError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeFlywheelError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeFlywheelError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeFlywheelError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeFlywheelError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeFlywheelError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeFlywheelError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DescribeFlywheelError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DescribeFlywheelError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DescribeFlywheelError] = union(
      DescribeFlywheelError.InternalServerExceptionCase.alt,
      DescribeFlywheelError.TooManyRequestsExceptionCase.alt,
      DescribeFlywheelError.InvalidRequestExceptionCase.alt,
      DescribeFlywheelError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeFlywheelError] = throwable match {
      case e: InternalServerException => Some(DescribeFlywheelError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeFlywheelError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeFlywheelError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DescribeFlywheelError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeFlywheelError): Throwable = e match {
      case DescribeFlywheelError.InternalServerExceptionCase(e) => e
      case DescribeFlywheelError.TooManyRequestsExceptionCase(e) => e
      case DescribeFlywheelError.InvalidRequestExceptionCase(e) => e
      case DescribeFlywheelError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DescribeFlywheelIteration(input: DescribeFlywheelIterationRequest) extends ComprehendOperation[DescribeFlywheelIterationRequest, ComprehendOperation.DescribeFlywheelIterationError, DescribeFlywheelIterationResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeFlywheelIterationRequest, ComprehendOperation.DescribeFlywheelIterationError, DescribeFlywheelIterationResponse, Nothing, Nothing] = impl.describeFlywheelIteration(input.flywheelArn, input.flywheelIterationId)
    def ordinal: Int = 27
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeFlywheelIterationRequest, ComprehendOperation.DescribeFlywheelIterationError, DescribeFlywheelIterationResponse, Nothing, Nothing] = DescribeFlywheelIteration
  }
  object DescribeFlywheelIteration extends smithy4s.Endpoint[ComprehendOperation,DescribeFlywheelIterationRequest, ComprehendOperation.DescribeFlywheelIterationError, DescribeFlywheelIterationResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeFlywheelIterationRequest, ComprehendOperation.DescribeFlywheelIterationError, DescribeFlywheelIterationResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeFlywheelIteration"))
      .withInput(DescribeFlywheelIterationRequest.schema)
      .withError(DescribeFlywheelIterationError.errorSchema)
      .withOutput(DescribeFlywheelIterationResponse.schema)
      .withHints(smithy.api.Documentation("<p>Retrieve the configuration properties of a flywheel iteration.\n      For more information about flywheels, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html\">\n      Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>"))
    def wrap(input: DescribeFlywheelIterationRequest): DescribeFlywheelIteration = DescribeFlywheelIteration(input)
  }
  sealed trait DescribeFlywheelIterationError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeFlywheelIterationError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DescribeFlywheelIterationError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeFlywheelIterationError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeFlywheelIterationError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DescribeFlywheelIterationError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DescribeFlywheelIterationError.Visitor[A]): A = this match {
      case value: DescribeFlywheelIterationError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeFlywheelIterationError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeFlywheelIterationError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DescribeFlywheelIterationError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DescribeFlywheelIterationError extends ErrorSchema.Companion[DescribeFlywheelIterationError] {

    def internalServerException(internalServerException: InternalServerException): DescribeFlywheelIterationError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeFlywheelIterationError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeFlywheelIterationError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DescribeFlywheelIterationError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeFlywheelIterationError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeFlywheelIterationError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeFlywheelIterationError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeFlywheelIterationError { final def $ordinal: Int = 2 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DescribeFlywheelIterationError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeFlywheelIterationError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeFlywheelIterationError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeFlywheelIterationError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeFlywheelIterationError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeFlywheelIterationError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeFlywheelIterationError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeFlywheelIterationError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeFlywheelIterationError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeFlywheelIterationError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeFlywheelIterationError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DescribeFlywheelIterationError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DescribeFlywheelIterationError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DescribeFlywheelIterationError] = union(
      DescribeFlywheelIterationError.InternalServerExceptionCase.alt,
      DescribeFlywheelIterationError.TooManyRequestsExceptionCase.alt,
      DescribeFlywheelIterationError.InvalidRequestExceptionCase.alt,
      DescribeFlywheelIterationError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeFlywheelIterationError] = throwable match {
      case e: InternalServerException => Some(DescribeFlywheelIterationError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeFlywheelIterationError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeFlywheelIterationError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DescribeFlywheelIterationError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeFlywheelIterationError): Throwable = e match {
      case DescribeFlywheelIterationError.InternalServerExceptionCase(e) => e
      case DescribeFlywheelIterationError.TooManyRequestsExceptionCase(e) => e
      case DescribeFlywheelIterationError.InvalidRequestExceptionCase(e) => e
      case DescribeFlywheelIterationError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DescribeKeyPhrasesDetectionJob(input: DescribeKeyPhrasesDetectionJobRequest) extends ComprehendOperation[DescribeKeyPhrasesDetectionJobRequest, ComprehendOperation.DescribeKeyPhrasesDetectionJobError, DescribeKeyPhrasesDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeKeyPhrasesDetectionJobRequest, ComprehendOperation.DescribeKeyPhrasesDetectionJobError, DescribeKeyPhrasesDetectionJobResponse, Nothing, Nothing] = impl.describeKeyPhrasesDetectionJob(input.jobId)
    def ordinal: Int = 28
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeKeyPhrasesDetectionJobRequest, ComprehendOperation.DescribeKeyPhrasesDetectionJobError, DescribeKeyPhrasesDetectionJobResponse, Nothing, Nothing] = DescribeKeyPhrasesDetectionJob
  }
  object DescribeKeyPhrasesDetectionJob extends smithy4s.Endpoint[ComprehendOperation,DescribeKeyPhrasesDetectionJobRequest, ComprehendOperation.DescribeKeyPhrasesDetectionJobError, DescribeKeyPhrasesDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeKeyPhrasesDetectionJobRequest, ComprehendOperation.DescribeKeyPhrasesDetectionJobError, DescribeKeyPhrasesDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeKeyPhrasesDetectionJob"))
      .withInput(DescribeKeyPhrasesDetectionJobRequest.schema)
      .withError(DescribeKeyPhrasesDetectionJobError.errorSchema)
      .withOutput(DescribeKeyPhrasesDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with a key phrases detection job. Use this operation to get\n      the status of a detection job.</p>"))
    def wrap(input: DescribeKeyPhrasesDetectionJobRequest): DescribeKeyPhrasesDetectionJob = DescribeKeyPhrasesDetectionJob(input)
  }
  sealed trait DescribeKeyPhrasesDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeKeyPhrasesDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = DescribeKeyPhrasesDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = DescribeKeyPhrasesDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeKeyPhrasesDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DescribeKeyPhrasesDetectionJobError.Visitor[A]): A = this match {
      case value: DescribeKeyPhrasesDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: DescribeKeyPhrasesDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeKeyPhrasesDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DescribeKeyPhrasesDetectionJobError extends ErrorSchema.Companion[DescribeKeyPhrasesDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): DescribeKeyPhrasesDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): DescribeKeyPhrasesDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeKeyPhrasesDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeKeyPhrasesDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeKeyPhrasesDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends DescribeKeyPhrasesDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeKeyPhrasesDetectionJobError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeKeyPhrasesDetectionJobError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeKeyPhrasesDetectionJobError { final def $ordinal: Int = 3 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeKeyPhrasesDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), DescribeKeyPhrasesDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[DescribeKeyPhrasesDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeKeyPhrasesDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeKeyPhrasesDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeKeyPhrasesDetectionJobError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeKeyPhrasesDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeKeyPhrasesDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeKeyPhrasesDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeKeyPhrasesDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DescribeKeyPhrasesDetectionJobError] = union(
      DescribeKeyPhrasesDetectionJobError.JobNotFoundExceptionCase.alt,
      DescribeKeyPhrasesDetectionJobError.InternalServerExceptionCase.alt,
      DescribeKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase.alt,
      DescribeKeyPhrasesDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeKeyPhrasesDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(DescribeKeyPhrasesDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(DescribeKeyPhrasesDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeKeyPhrasesDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeKeyPhrasesDetectionJobError): Throwable = e match {
      case DescribeKeyPhrasesDetectionJobError.JobNotFoundExceptionCase(e) => e
      case DescribeKeyPhrasesDetectionJobError.InternalServerExceptionCase(e) => e
      case DescribeKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case DescribeKeyPhrasesDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DescribePiiEntitiesDetectionJob(input: DescribePiiEntitiesDetectionJobRequest) extends ComprehendOperation[DescribePiiEntitiesDetectionJobRequest, ComprehendOperation.DescribePiiEntitiesDetectionJobError, DescribePiiEntitiesDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribePiiEntitiesDetectionJobRequest, ComprehendOperation.DescribePiiEntitiesDetectionJobError, DescribePiiEntitiesDetectionJobResponse, Nothing, Nothing] = impl.describePiiEntitiesDetectionJob(input.jobId)
    def ordinal: Int = 29
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribePiiEntitiesDetectionJobRequest, ComprehendOperation.DescribePiiEntitiesDetectionJobError, DescribePiiEntitiesDetectionJobResponse, Nothing, Nothing] = DescribePiiEntitiesDetectionJob
  }
  object DescribePiiEntitiesDetectionJob extends smithy4s.Endpoint[ComprehendOperation,DescribePiiEntitiesDetectionJobRequest, ComprehendOperation.DescribePiiEntitiesDetectionJobError, DescribePiiEntitiesDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribePiiEntitiesDetectionJobRequest, ComprehendOperation.DescribePiiEntitiesDetectionJobError, DescribePiiEntitiesDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribePiiEntitiesDetectionJob"))
      .withInput(DescribePiiEntitiesDetectionJobRequest.schema)
      .withError(DescribePiiEntitiesDetectionJobError.errorSchema)
      .withOutput(DescribePiiEntitiesDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with a PII entities detection job. For example, you can use\n      this operation to get the job status.</p>"))
    def wrap(input: DescribePiiEntitiesDetectionJobRequest): DescribePiiEntitiesDetectionJob = DescribePiiEntitiesDetectionJob(input)
  }
  sealed trait DescribePiiEntitiesDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribePiiEntitiesDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = DescribePiiEntitiesDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = DescribePiiEntitiesDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribePiiEntitiesDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribePiiEntitiesDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DescribePiiEntitiesDetectionJobError.Visitor[A]): A = this match {
      case value: DescribePiiEntitiesDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: DescribePiiEntitiesDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribePiiEntitiesDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribePiiEntitiesDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DescribePiiEntitiesDetectionJobError extends ErrorSchema.Companion[DescribePiiEntitiesDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): DescribePiiEntitiesDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): DescribePiiEntitiesDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribePiiEntitiesDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribePiiEntitiesDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribePiiEntitiesDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends DescribePiiEntitiesDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribePiiEntitiesDetectionJobError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribePiiEntitiesDetectionJobError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribePiiEntitiesDetectionJobError { final def $ordinal: Int = 3 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribePiiEntitiesDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), DescribePiiEntitiesDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[DescribePiiEntitiesDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribePiiEntitiesDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribePiiEntitiesDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribePiiEntitiesDetectionJobError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribePiiEntitiesDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribePiiEntitiesDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribePiiEntitiesDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribePiiEntitiesDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribePiiEntitiesDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribePiiEntitiesDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DescribePiiEntitiesDetectionJobError] = union(
      DescribePiiEntitiesDetectionJobError.JobNotFoundExceptionCase.alt,
      DescribePiiEntitiesDetectionJobError.InternalServerExceptionCase.alt,
      DescribePiiEntitiesDetectionJobError.TooManyRequestsExceptionCase.alt,
      DescribePiiEntitiesDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribePiiEntitiesDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(DescribePiiEntitiesDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(DescribePiiEntitiesDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribePiiEntitiesDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribePiiEntitiesDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribePiiEntitiesDetectionJobError): Throwable = e match {
      case DescribePiiEntitiesDetectionJobError.JobNotFoundExceptionCase(e) => e
      case DescribePiiEntitiesDetectionJobError.InternalServerExceptionCase(e) => e
      case DescribePiiEntitiesDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case DescribePiiEntitiesDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DescribeResourcePolicy(input: DescribeResourcePolicyRequest) extends ComprehendOperation[DescribeResourcePolicyRequest, ComprehendOperation.DescribeResourcePolicyError, DescribeResourcePolicyResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeResourcePolicyRequest, ComprehendOperation.DescribeResourcePolicyError, DescribeResourcePolicyResponse, Nothing, Nothing] = impl.describeResourcePolicy(input.resourceArn)
    def ordinal: Int = 30
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeResourcePolicyRequest, ComprehendOperation.DescribeResourcePolicyError, DescribeResourcePolicyResponse, Nothing, Nothing] = DescribeResourcePolicy
  }
  object DescribeResourcePolicy extends smithy4s.Endpoint[ComprehendOperation,DescribeResourcePolicyRequest, ComprehendOperation.DescribeResourcePolicyError, DescribeResourcePolicyResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeResourcePolicyRequest, ComprehendOperation.DescribeResourcePolicyError, DescribeResourcePolicyResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeResourcePolicy"))
      .withInput(DescribeResourcePolicyRequest.schema)
      .withError(DescribeResourcePolicyError.errorSchema)
      .withOutput(DescribeResourcePolicyResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the details of a resource-based policy that is attached to a custom model, including\n      the JSON body of the policy.</p>"))
    def wrap(input: DescribeResourcePolicyRequest): DescribeResourcePolicy = DescribeResourcePolicy(input)
  }
  sealed trait DescribeResourcePolicyError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeResourcePolicyError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DescribeResourcePolicyError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeResourcePolicyError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = DescribeResourcePolicyError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: DescribeResourcePolicyError.Visitor[A]): A = this match {
      case value: DescribeResourcePolicyError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeResourcePolicyError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: DescribeResourcePolicyError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object DescribeResourcePolicyError extends ErrorSchema.Companion[DescribeResourcePolicyError] {

    def internalServerException(internalServerException: InternalServerException): DescribeResourcePolicyError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeResourcePolicyError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): DescribeResourcePolicyError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeResourcePolicyError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeResourcePolicyError { final def $ordinal: Int = 0 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeResourcePolicyError { final def $ordinal: Int = 1 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends DescribeResourcePolicyError { final def $ordinal: Int = 2 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeResourcePolicyError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeResourcePolicyError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeResourcePolicyError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeResourcePolicyError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeResourcePolicyError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeResourcePolicyError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeResourcePolicyError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), DescribeResourcePolicyError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[DescribeResourcePolicyError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[DescribeResourcePolicyError] = union(
      DescribeResourcePolicyError.InternalServerExceptionCase.alt,
      DescribeResourcePolicyError.InvalidRequestExceptionCase.alt,
      DescribeResourcePolicyError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeResourcePolicyError] = throwable match {
      case e: InternalServerException => Some(DescribeResourcePolicyError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeResourcePolicyError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(DescribeResourcePolicyError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeResourcePolicyError): Throwable = e match {
      case DescribeResourcePolicyError.InternalServerExceptionCase(e) => e
      case DescribeResourcePolicyError.InvalidRequestExceptionCase(e) => e
      case DescribeResourcePolicyError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class DescribeSentimentDetectionJob(input: DescribeSentimentDetectionJobRequest) extends ComprehendOperation[DescribeSentimentDetectionJobRequest, ComprehendOperation.DescribeSentimentDetectionJobError, DescribeSentimentDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeSentimentDetectionJobRequest, ComprehendOperation.DescribeSentimentDetectionJobError, DescribeSentimentDetectionJobResponse, Nothing, Nothing] = impl.describeSentimentDetectionJob(input.jobId)
    def ordinal: Int = 31
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeSentimentDetectionJobRequest, ComprehendOperation.DescribeSentimentDetectionJobError, DescribeSentimentDetectionJobResponse, Nothing, Nothing] = DescribeSentimentDetectionJob
  }
  object DescribeSentimentDetectionJob extends smithy4s.Endpoint[ComprehendOperation,DescribeSentimentDetectionJobRequest, ComprehendOperation.DescribeSentimentDetectionJobError, DescribeSentimentDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeSentimentDetectionJobRequest, ComprehendOperation.DescribeSentimentDetectionJobError, DescribeSentimentDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeSentimentDetectionJob"))
      .withInput(DescribeSentimentDetectionJobRequest.schema)
      .withError(DescribeSentimentDetectionJobError.errorSchema)
      .withOutput(DescribeSentimentDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with a sentiment detection job. Use this operation to get\n      the status of a detection job.</p>"))
    def wrap(input: DescribeSentimentDetectionJobRequest): DescribeSentimentDetectionJob = DescribeSentimentDetectionJob(input)
  }
  sealed trait DescribeSentimentDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeSentimentDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = DescribeSentimentDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = DescribeSentimentDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeSentimentDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeSentimentDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DescribeSentimentDetectionJobError.Visitor[A]): A = this match {
      case value: DescribeSentimentDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: DescribeSentimentDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeSentimentDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeSentimentDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DescribeSentimentDetectionJobError extends ErrorSchema.Companion[DescribeSentimentDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): DescribeSentimentDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): DescribeSentimentDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeSentimentDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeSentimentDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeSentimentDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends DescribeSentimentDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeSentimentDetectionJobError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeSentimentDetectionJobError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeSentimentDetectionJobError { final def $ordinal: Int = 3 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeSentimentDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), DescribeSentimentDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[DescribeSentimentDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeSentimentDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeSentimentDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeSentimentDetectionJobError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeSentimentDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeSentimentDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeSentimentDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeSentimentDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeSentimentDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeSentimentDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DescribeSentimentDetectionJobError] = union(
      DescribeSentimentDetectionJobError.JobNotFoundExceptionCase.alt,
      DescribeSentimentDetectionJobError.InternalServerExceptionCase.alt,
      DescribeSentimentDetectionJobError.TooManyRequestsExceptionCase.alt,
      DescribeSentimentDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeSentimentDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(DescribeSentimentDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(DescribeSentimentDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeSentimentDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeSentimentDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeSentimentDetectionJobError): Throwable = e match {
      case DescribeSentimentDetectionJobError.JobNotFoundExceptionCase(e) => e
      case DescribeSentimentDetectionJobError.InternalServerExceptionCase(e) => e
      case DescribeSentimentDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case DescribeSentimentDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DescribeTargetedSentimentDetectionJob(input: DescribeTargetedSentimentDetectionJobRequest) extends ComprehendOperation[DescribeTargetedSentimentDetectionJobRequest, ComprehendOperation.DescribeTargetedSentimentDetectionJobError, DescribeTargetedSentimentDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeTargetedSentimentDetectionJobRequest, ComprehendOperation.DescribeTargetedSentimentDetectionJobError, DescribeTargetedSentimentDetectionJobResponse, Nothing, Nothing] = impl.describeTargetedSentimentDetectionJob(input.jobId)
    def ordinal: Int = 32
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeTargetedSentimentDetectionJobRequest, ComprehendOperation.DescribeTargetedSentimentDetectionJobError, DescribeTargetedSentimentDetectionJobResponse, Nothing, Nothing] = DescribeTargetedSentimentDetectionJob
  }
  object DescribeTargetedSentimentDetectionJob extends smithy4s.Endpoint[ComprehendOperation,DescribeTargetedSentimentDetectionJobRequest, ComprehendOperation.DescribeTargetedSentimentDetectionJobError, DescribeTargetedSentimentDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeTargetedSentimentDetectionJobRequest, ComprehendOperation.DescribeTargetedSentimentDetectionJobError, DescribeTargetedSentimentDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeTargetedSentimentDetectionJob"))
      .withInput(DescribeTargetedSentimentDetectionJobRequest.schema)
      .withError(DescribeTargetedSentimentDetectionJobError.errorSchema)
      .withOutput(DescribeTargetedSentimentDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with a targeted sentiment detection job. Use this operation\n      to get the status of the job.</p>"))
    def wrap(input: DescribeTargetedSentimentDetectionJobRequest): DescribeTargetedSentimentDetectionJob = DescribeTargetedSentimentDetectionJob(input)
  }
  sealed trait DescribeTargetedSentimentDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeTargetedSentimentDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = DescribeTargetedSentimentDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = DescribeTargetedSentimentDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeTargetedSentimentDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DescribeTargetedSentimentDetectionJobError.Visitor[A]): A = this match {
      case value: DescribeTargetedSentimentDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: DescribeTargetedSentimentDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeTargetedSentimentDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DescribeTargetedSentimentDetectionJobError extends ErrorSchema.Companion[DescribeTargetedSentimentDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): DescribeTargetedSentimentDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): DescribeTargetedSentimentDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeTargetedSentimentDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeTargetedSentimentDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeTargetedSentimentDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends DescribeTargetedSentimentDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeTargetedSentimentDetectionJobError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeTargetedSentimentDetectionJobError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeTargetedSentimentDetectionJobError { final def $ordinal: Int = 3 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeTargetedSentimentDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), DescribeTargetedSentimentDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[DescribeTargetedSentimentDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeTargetedSentimentDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeTargetedSentimentDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeTargetedSentimentDetectionJobError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeTargetedSentimentDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeTargetedSentimentDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeTargetedSentimentDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeTargetedSentimentDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DescribeTargetedSentimentDetectionJobError] = union(
      DescribeTargetedSentimentDetectionJobError.JobNotFoundExceptionCase.alt,
      DescribeTargetedSentimentDetectionJobError.InternalServerExceptionCase.alt,
      DescribeTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase.alt,
      DescribeTargetedSentimentDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeTargetedSentimentDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(DescribeTargetedSentimentDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(DescribeTargetedSentimentDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeTargetedSentimentDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeTargetedSentimentDetectionJobError): Throwable = e match {
      case DescribeTargetedSentimentDetectionJobError.JobNotFoundExceptionCase(e) => e
      case DescribeTargetedSentimentDetectionJobError.InternalServerExceptionCase(e) => e
      case DescribeTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case DescribeTargetedSentimentDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DescribeTopicsDetectionJob(input: DescribeTopicsDetectionJobRequest) extends ComprehendOperation[DescribeTopicsDetectionJobRequest, ComprehendOperation.DescribeTopicsDetectionJobError, DescribeTopicsDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DescribeTopicsDetectionJobRequest, ComprehendOperation.DescribeTopicsDetectionJobError, DescribeTopicsDetectionJobResponse, Nothing, Nothing] = impl.describeTopicsDetectionJob(input.jobId)
    def ordinal: Int = 33
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DescribeTopicsDetectionJobRequest, ComprehendOperation.DescribeTopicsDetectionJobError, DescribeTopicsDetectionJobResponse, Nothing, Nothing] = DescribeTopicsDetectionJob
  }
  object DescribeTopicsDetectionJob extends smithy4s.Endpoint[ComprehendOperation,DescribeTopicsDetectionJobRequest, ComprehendOperation.DescribeTopicsDetectionJobError, DescribeTopicsDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[DescribeTopicsDetectionJobRequest, ComprehendOperation.DescribeTopicsDetectionJobError, DescribeTopicsDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DescribeTopicsDetectionJob"))
      .withInput(DescribeTopicsDetectionJobRequest.schema)
      .withError(DescribeTopicsDetectionJobError.errorSchema)
      .withOutput(DescribeTopicsDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets the properties associated with a topic detection job. Use this operation to get\n      the status of a detection job.</p>"))
    def wrap(input: DescribeTopicsDetectionJobRequest): DescribeTopicsDetectionJob = DescribeTopicsDetectionJob(input)
  }
  sealed trait DescribeTopicsDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DescribeTopicsDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = DescribeTopicsDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = DescribeTopicsDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = DescribeTopicsDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = DescribeTopicsDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DescribeTopicsDetectionJobError.Visitor[A]): A = this match {
      case value: DescribeTopicsDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: DescribeTopicsDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DescribeTopicsDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: DescribeTopicsDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DescribeTopicsDetectionJobError extends ErrorSchema.Companion[DescribeTopicsDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): DescribeTopicsDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): DescribeTopicsDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): DescribeTopicsDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DescribeTopicsDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DescribeTopicsDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends DescribeTopicsDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DescribeTopicsDetectionJobError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends DescribeTopicsDetectionJobError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DescribeTopicsDetectionJobError { final def $ordinal: Int = 3 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeTopicsDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), DescribeTopicsDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[DescribeTopicsDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeTopicsDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DescribeTopicsDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DescribeTopicsDetectionJobError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeTopicsDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), DescribeTopicsDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[DescribeTopicsDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DescribeTopicsDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DescribeTopicsDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DescribeTopicsDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DescribeTopicsDetectionJobError] = union(
      DescribeTopicsDetectionJobError.JobNotFoundExceptionCase.alt,
      DescribeTopicsDetectionJobError.InternalServerExceptionCase.alt,
      DescribeTopicsDetectionJobError.TooManyRequestsExceptionCase.alt,
      DescribeTopicsDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DescribeTopicsDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(DescribeTopicsDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(DescribeTopicsDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(DescribeTopicsDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(DescribeTopicsDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DescribeTopicsDetectionJobError): Throwable = e match {
      case DescribeTopicsDetectionJobError.JobNotFoundExceptionCase(e) => e
      case DescribeTopicsDetectionJobError.InternalServerExceptionCase(e) => e
      case DescribeTopicsDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case DescribeTopicsDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DetectDominantLanguage(input: DetectDominantLanguageRequest) extends ComprehendOperation[DetectDominantLanguageRequest, ComprehendOperation.DetectDominantLanguageError, DetectDominantLanguageResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DetectDominantLanguageRequest, ComprehendOperation.DetectDominantLanguageError, DetectDominantLanguageResponse, Nothing, Nothing] = impl.detectDominantLanguage(input.text)
    def ordinal: Int = 34
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DetectDominantLanguageRequest, ComprehendOperation.DetectDominantLanguageError, DetectDominantLanguageResponse, Nothing, Nothing] = DetectDominantLanguage
  }
  object DetectDominantLanguage extends smithy4s.Endpoint[ComprehendOperation,DetectDominantLanguageRequest, ComprehendOperation.DetectDominantLanguageError, DetectDominantLanguageResponse, Nothing, Nothing] {
    val schema: OperationSchema[DetectDominantLanguageRequest, ComprehendOperation.DetectDominantLanguageError, DetectDominantLanguageResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DetectDominantLanguage"))
      .withInput(DetectDominantLanguageRequest.schema)
      .withError(DetectDominantLanguageError.errorSchema)
      .withOutput(DetectDominantLanguageResponse.schema)
      .withHints(smithy.api.Documentation("<p>Determines the dominant language of the input text. For a list of languages that Amazon\n      Comprehend can detect, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/how-languages.html\">Amazon Comprehend Supported Languages</a>. </p>"))
    def wrap(input: DetectDominantLanguageRequest): DetectDominantLanguage = DetectDominantLanguage(input)
  }
  sealed trait DetectDominantLanguageError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DetectDominantLanguageError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DetectDominantLanguageError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = DetectDominantLanguageError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = DetectDominantLanguageError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DetectDominantLanguageError.Visitor[A]): A = this match {
      case value: DetectDominantLanguageError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DetectDominantLanguageError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: DetectDominantLanguageError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DetectDominantLanguageError extends ErrorSchema.Companion[DetectDominantLanguageError] {

    def internalServerException(internalServerException: InternalServerException): DetectDominantLanguageError = InternalServerExceptionCase(internalServerException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): DetectDominantLanguageError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DetectDominantLanguageError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DetectDominantLanguageError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DetectDominantLanguageError { final def $ordinal: Int = 0 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends DetectDominantLanguageError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DetectDominantLanguageError { final def $ordinal: Int = 2 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectDominantLanguageError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DetectDominantLanguageError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DetectDominantLanguageError]("InternalServerException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectDominantLanguageError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), DetectDominantLanguageError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[DetectDominantLanguageError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectDominantLanguageError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DetectDominantLanguageError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DetectDominantLanguageError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DetectDominantLanguageError] = union(
      DetectDominantLanguageError.InternalServerExceptionCase.alt,
      DetectDominantLanguageError.TextSizeLimitExceededExceptionCase.alt,
      DetectDominantLanguageError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DetectDominantLanguageError] = throwable match {
      case e: InternalServerException => Some(DetectDominantLanguageError.InternalServerExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(DetectDominantLanguageError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(DetectDominantLanguageError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DetectDominantLanguageError): Throwable = e match {
      case DetectDominantLanguageError.InternalServerExceptionCase(e) => e
      case DetectDominantLanguageError.TextSizeLimitExceededExceptionCase(e) => e
      case DetectDominantLanguageError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DetectEntities(input: DetectEntitiesRequest) extends ComprehendOperation[DetectEntitiesRequest, ComprehendOperation.DetectEntitiesError, DetectEntitiesResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DetectEntitiesRequest, ComprehendOperation.DetectEntitiesError, DetectEntitiesResponse, Nothing, Nothing] = impl.detectEntities(input.text, input.languageCode, input.endpointArn, input.bytes, input.documentReaderConfig)
    def ordinal: Int = 35
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DetectEntitiesRequest, ComprehendOperation.DetectEntitiesError, DetectEntitiesResponse, Nothing, Nothing] = DetectEntities
  }
  object DetectEntities extends smithy4s.Endpoint[ComprehendOperation,DetectEntitiesRequest, ComprehendOperation.DetectEntitiesError, DetectEntitiesResponse, Nothing, Nothing] {
    val schema: OperationSchema[DetectEntitiesRequest, ComprehendOperation.DetectEntitiesError, DetectEntitiesResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DetectEntities"))
      .withInput(DetectEntitiesRequest.schema)
      .withError(DetectEntitiesError.errorSchema)
      .withOutput(DetectEntitiesResponse.schema)
      .withHints(smithy.api.Documentation("<p>Detects named entities in input text when you use the pre-trained model.\n      Detects custom entities if you have a custom entity recognition model. </p>\n         <p>\n      When detecting named entities using the pre-trained model, use plain text as the input.\n      For more information about named entities, see\n      <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/how-entities.html\">Entities</a> in the Comprehend Developer Guide.</p>\n         <p>When you use a custom entity recognition model,\n      you can input plain text or you can upload a single-page input document (text, PDF, Word, or image). </p>\n         <p>If the system detects errors while processing a page in the input document, the API response\n       includes an entry in <code>Errors</code> for each error. </p>\n         <p>If the system detects a document-level error in your input document, the API returns an\n       <code>InvalidRequestException</code> error response.\n      For details about this exception, see\n      <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/idp-inputs-sync-err.html\">\n        Errors in semi-structured documents</a> in the Comprehend Developer Guide.\n    </p>"))
    def wrap(input: DetectEntitiesRequest): DetectEntities = DetectEntities(input)
  }
  sealed trait DetectEntitiesError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DetectEntitiesError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DetectEntitiesError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = DetectEntitiesError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = DetectEntitiesError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = DetectEntitiesError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = DetectEntitiesError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DetectEntitiesError.Visitor[A]): A = this match {
      case value: DetectEntitiesError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DetectEntitiesError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: DetectEntitiesError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: DetectEntitiesError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: DetectEntitiesError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DetectEntitiesError extends ErrorSchema.Companion[DetectEntitiesError] {

    def internalServerException(internalServerException: InternalServerException): DetectEntitiesError = InternalServerExceptionCase(internalServerException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): DetectEntitiesError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): DetectEntitiesError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): DetectEntitiesError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DetectEntitiesError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DetectEntitiesError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DetectEntitiesError { final def $ordinal: Int = 0 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends DetectEntitiesError { final def $ordinal: Int = 1 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends DetectEntitiesError { final def $ordinal: Int = 2 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends DetectEntitiesError { final def $ordinal: Int = 3 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DetectEntitiesError { final def $ordinal: Int = 4 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectEntitiesError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DetectEntitiesError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DetectEntitiesError]("InternalServerException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectEntitiesError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), DetectEntitiesError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[DetectEntitiesError]("UnsupportedLanguageException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectEntitiesError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), DetectEntitiesError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[DetectEntitiesError]("ResourceUnavailableException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectEntitiesError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), DetectEntitiesError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[DetectEntitiesError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectEntitiesError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DetectEntitiesError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DetectEntitiesError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DetectEntitiesError] = union(
      DetectEntitiesError.InternalServerExceptionCase.alt,
      DetectEntitiesError.UnsupportedLanguageExceptionCase.alt,
      DetectEntitiesError.ResourceUnavailableExceptionCase.alt,
      DetectEntitiesError.TextSizeLimitExceededExceptionCase.alt,
      DetectEntitiesError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DetectEntitiesError] = throwable match {
      case e: InternalServerException => Some(DetectEntitiesError.InternalServerExceptionCase(e))
      case e: UnsupportedLanguageException => Some(DetectEntitiesError.UnsupportedLanguageExceptionCase(e))
      case e: ResourceUnavailableException => Some(DetectEntitiesError.ResourceUnavailableExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(DetectEntitiesError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(DetectEntitiesError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DetectEntitiesError): Throwable = e match {
      case DetectEntitiesError.InternalServerExceptionCase(e) => e
      case DetectEntitiesError.UnsupportedLanguageExceptionCase(e) => e
      case DetectEntitiesError.ResourceUnavailableExceptionCase(e) => e
      case DetectEntitiesError.TextSizeLimitExceededExceptionCase(e) => e
      case DetectEntitiesError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DetectKeyPhrases(input: DetectKeyPhrasesRequest) extends ComprehendOperation[DetectKeyPhrasesRequest, ComprehendOperation.DetectKeyPhrasesError, DetectKeyPhrasesResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DetectKeyPhrasesRequest, ComprehendOperation.DetectKeyPhrasesError, DetectKeyPhrasesResponse, Nothing, Nothing] = impl.detectKeyPhrases(input.text, input.languageCode)
    def ordinal: Int = 36
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DetectKeyPhrasesRequest, ComprehendOperation.DetectKeyPhrasesError, DetectKeyPhrasesResponse, Nothing, Nothing] = DetectKeyPhrases
  }
  object DetectKeyPhrases extends smithy4s.Endpoint[ComprehendOperation,DetectKeyPhrasesRequest, ComprehendOperation.DetectKeyPhrasesError, DetectKeyPhrasesResponse, Nothing, Nothing] {
    val schema: OperationSchema[DetectKeyPhrasesRequest, ComprehendOperation.DetectKeyPhrasesError, DetectKeyPhrasesResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DetectKeyPhrases"))
      .withInput(DetectKeyPhrasesRequest.schema)
      .withError(DetectKeyPhrasesError.errorSchema)
      .withOutput(DetectKeyPhrasesResponse.schema)
      .withHints(smithy.api.Documentation("<p>Detects the key noun phrases found in the text. </p>"))
    def wrap(input: DetectKeyPhrasesRequest): DetectKeyPhrases = DetectKeyPhrases(input)
  }
  sealed trait DetectKeyPhrasesError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DetectKeyPhrasesError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DetectKeyPhrasesError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = DetectKeyPhrasesError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = DetectKeyPhrasesError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = DetectKeyPhrasesError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DetectKeyPhrasesError.Visitor[A]): A = this match {
      case value: DetectKeyPhrasesError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DetectKeyPhrasesError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: DetectKeyPhrasesError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: DetectKeyPhrasesError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DetectKeyPhrasesError extends ErrorSchema.Companion[DetectKeyPhrasesError] {

    def internalServerException(internalServerException: InternalServerException): DetectKeyPhrasesError = InternalServerExceptionCase(internalServerException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): DetectKeyPhrasesError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): DetectKeyPhrasesError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DetectKeyPhrasesError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DetectKeyPhrasesError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DetectKeyPhrasesError { final def $ordinal: Int = 0 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends DetectKeyPhrasesError { final def $ordinal: Int = 1 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends DetectKeyPhrasesError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DetectKeyPhrasesError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectKeyPhrasesError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DetectKeyPhrasesError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DetectKeyPhrasesError]("InternalServerException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectKeyPhrasesError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), DetectKeyPhrasesError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[DetectKeyPhrasesError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectKeyPhrasesError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), DetectKeyPhrasesError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[DetectKeyPhrasesError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectKeyPhrasesError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DetectKeyPhrasesError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DetectKeyPhrasesError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DetectKeyPhrasesError] = union(
      DetectKeyPhrasesError.InternalServerExceptionCase.alt,
      DetectKeyPhrasesError.UnsupportedLanguageExceptionCase.alt,
      DetectKeyPhrasesError.TextSizeLimitExceededExceptionCase.alt,
      DetectKeyPhrasesError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DetectKeyPhrasesError] = throwable match {
      case e: InternalServerException => Some(DetectKeyPhrasesError.InternalServerExceptionCase(e))
      case e: UnsupportedLanguageException => Some(DetectKeyPhrasesError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(DetectKeyPhrasesError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(DetectKeyPhrasesError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DetectKeyPhrasesError): Throwable = e match {
      case DetectKeyPhrasesError.InternalServerExceptionCase(e) => e
      case DetectKeyPhrasesError.UnsupportedLanguageExceptionCase(e) => e
      case DetectKeyPhrasesError.TextSizeLimitExceededExceptionCase(e) => e
      case DetectKeyPhrasesError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DetectPiiEntities(input: DetectPiiEntitiesRequest) extends ComprehendOperation[DetectPiiEntitiesRequest, ComprehendOperation.DetectPiiEntitiesError, DetectPiiEntitiesResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DetectPiiEntitiesRequest, ComprehendOperation.DetectPiiEntitiesError, DetectPiiEntitiesResponse, Nothing, Nothing] = impl.detectPiiEntities(input.text, input.languageCode)
    def ordinal: Int = 37
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DetectPiiEntitiesRequest, ComprehendOperation.DetectPiiEntitiesError, DetectPiiEntitiesResponse, Nothing, Nothing] = DetectPiiEntities
  }
  object DetectPiiEntities extends smithy4s.Endpoint[ComprehendOperation,DetectPiiEntitiesRequest, ComprehendOperation.DetectPiiEntitiesError, DetectPiiEntitiesResponse, Nothing, Nothing] {
    val schema: OperationSchema[DetectPiiEntitiesRequest, ComprehendOperation.DetectPiiEntitiesError, DetectPiiEntitiesResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DetectPiiEntities"))
      .withInput(DetectPiiEntitiesRequest.schema)
      .withError(DetectPiiEntitiesError.errorSchema)
      .withOutput(DetectPiiEntitiesResponse.schema)
      .withHints(smithy.api.Documentation("<p>Inspects the input text for entities that contain personally identifiable information\n      (PII) and returns information about them.</p>"))
    def wrap(input: DetectPiiEntitiesRequest): DetectPiiEntities = DetectPiiEntities(input)
  }
  sealed trait DetectPiiEntitiesError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DetectPiiEntitiesError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DetectPiiEntitiesError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = DetectPiiEntitiesError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = DetectPiiEntitiesError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = DetectPiiEntitiesError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DetectPiiEntitiesError.Visitor[A]): A = this match {
      case value: DetectPiiEntitiesError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DetectPiiEntitiesError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: DetectPiiEntitiesError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: DetectPiiEntitiesError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DetectPiiEntitiesError extends ErrorSchema.Companion[DetectPiiEntitiesError] {

    def internalServerException(internalServerException: InternalServerException): DetectPiiEntitiesError = InternalServerExceptionCase(internalServerException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): DetectPiiEntitiesError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): DetectPiiEntitiesError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DetectPiiEntitiesError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DetectPiiEntitiesError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DetectPiiEntitiesError { final def $ordinal: Int = 0 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends DetectPiiEntitiesError { final def $ordinal: Int = 1 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends DetectPiiEntitiesError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DetectPiiEntitiesError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectPiiEntitiesError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DetectPiiEntitiesError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DetectPiiEntitiesError]("InternalServerException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectPiiEntitiesError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), DetectPiiEntitiesError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[DetectPiiEntitiesError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectPiiEntitiesError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), DetectPiiEntitiesError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[DetectPiiEntitiesError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectPiiEntitiesError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DetectPiiEntitiesError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DetectPiiEntitiesError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DetectPiiEntitiesError] = union(
      DetectPiiEntitiesError.InternalServerExceptionCase.alt,
      DetectPiiEntitiesError.UnsupportedLanguageExceptionCase.alt,
      DetectPiiEntitiesError.TextSizeLimitExceededExceptionCase.alt,
      DetectPiiEntitiesError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DetectPiiEntitiesError] = throwable match {
      case e: InternalServerException => Some(DetectPiiEntitiesError.InternalServerExceptionCase(e))
      case e: UnsupportedLanguageException => Some(DetectPiiEntitiesError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(DetectPiiEntitiesError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(DetectPiiEntitiesError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DetectPiiEntitiesError): Throwable = e match {
      case DetectPiiEntitiesError.InternalServerExceptionCase(e) => e
      case DetectPiiEntitiesError.UnsupportedLanguageExceptionCase(e) => e
      case DetectPiiEntitiesError.TextSizeLimitExceededExceptionCase(e) => e
      case DetectPiiEntitiesError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DetectSentiment(input: DetectSentimentRequest) extends ComprehendOperation[DetectSentimentRequest, ComprehendOperation.DetectSentimentError, DetectSentimentResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DetectSentimentRequest, ComprehendOperation.DetectSentimentError, DetectSentimentResponse, Nothing, Nothing] = impl.detectSentiment(input.text, input.languageCode)
    def ordinal: Int = 38
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DetectSentimentRequest, ComprehendOperation.DetectSentimentError, DetectSentimentResponse, Nothing, Nothing] = DetectSentiment
  }
  object DetectSentiment extends smithy4s.Endpoint[ComprehendOperation,DetectSentimentRequest, ComprehendOperation.DetectSentimentError, DetectSentimentResponse, Nothing, Nothing] {
    val schema: OperationSchema[DetectSentimentRequest, ComprehendOperation.DetectSentimentError, DetectSentimentResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DetectSentiment"))
      .withInput(DetectSentimentRequest.schema)
      .withError(DetectSentimentError.errorSchema)
      .withOutput(DetectSentimentResponse.schema)
      .withHints(smithy.api.Documentation("<p>Inspects text and returns an inference of the prevailing sentiment\n        (<code>POSITIVE</code>, <code>NEUTRAL</code>, <code>MIXED</code>, or <code>NEGATIVE</code>). </p>"))
    def wrap(input: DetectSentimentRequest): DetectSentiment = DetectSentiment(input)
  }
  sealed trait DetectSentimentError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DetectSentimentError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DetectSentimentError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = DetectSentimentError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = DetectSentimentError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = DetectSentimentError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DetectSentimentError.Visitor[A]): A = this match {
      case value: DetectSentimentError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DetectSentimentError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: DetectSentimentError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: DetectSentimentError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DetectSentimentError extends ErrorSchema.Companion[DetectSentimentError] {

    def internalServerException(internalServerException: InternalServerException): DetectSentimentError = InternalServerExceptionCase(internalServerException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): DetectSentimentError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): DetectSentimentError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DetectSentimentError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DetectSentimentError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DetectSentimentError { final def $ordinal: Int = 0 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends DetectSentimentError { final def $ordinal: Int = 1 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends DetectSentimentError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DetectSentimentError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectSentimentError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DetectSentimentError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DetectSentimentError]("InternalServerException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectSentimentError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), DetectSentimentError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[DetectSentimentError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectSentimentError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), DetectSentimentError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[DetectSentimentError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectSentimentError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DetectSentimentError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DetectSentimentError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DetectSentimentError] = union(
      DetectSentimentError.InternalServerExceptionCase.alt,
      DetectSentimentError.UnsupportedLanguageExceptionCase.alt,
      DetectSentimentError.TextSizeLimitExceededExceptionCase.alt,
      DetectSentimentError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DetectSentimentError] = throwable match {
      case e: InternalServerException => Some(DetectSentimentError.InternalServerExceptionCase(e))
      case e: UnsupportedLanguageException => Some(DetectSentimentError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(DetectSentimentError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(DetectSentimentError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DetectSentimentError): Throwable = e match {
      case DetectSentimentError.InternalServerExceptionCase(e) => e
      case DetectSentimentError.UnsupportedLanguageExceptionCase(e) => e
      case DetectSentimentError.TextSizeLimitExceededExceptionCase(e) => e
      case DetectSentimentError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DetectSyntax(input: DetectSyntaxRequest) extends ComprehendOperation[DetectSyntaxRequest, ComprehendOperation.DetectSyntaxError, DetectSyntaxResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DetectSyntaxRequest, ComprehendOperation.DetectSyntaxError, DetectSyntaxResponse, Nothing, Nothing] = impl.detectSyntax(input.text, input.languageCode)
    def ordinal: Int = 39
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DetectSyntaxRequest, ComprehendOperation.DetectSyntaxError, DetectSyntaxResponse, Nothing, Nothing] = DetectSyntax
  }
  object DetectSyntax extends smithy4s.Endpoint[ComprehendOperation,DetectSyntaxRequest, ComprehendOperation.DetectSyntaxError, DetectSyntaxResponse, Nothing, Nothing] {
    val schema: OperationSchema[DetectSyntaxRequest, ComprehendOperation.DetectSyntaxError, DetectSyntaxResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DetectSyntax"))
      .withInput(DetectSyntaxRequest.schema)
      .withError(DetectSyntaxError.errorSchema)
      .withOutput(DetectSyntaxResponse.schema)
      .withHints(smithy.api.Documentation("<p>Inspects text for syntax and the part of speech of words in the document. For more\n      information, see\n      <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html\">Syntax</a> in the Comprehend Developer Guide.\n    </p>"))
    def wrap(input: DetectSyntaxRequest): DetectSyntax = DetectSyntax(input)
  }
  sealed trait DetectSyntaxError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DetectSyntaxError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DetectSyntaxError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = DetectSyntaxError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = DetectSyntaxError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = DetectSyntaxError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DetectSyntaxError.Visitor[A]): A = this match {
      case value: DetectSyntaxError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DetectSyntaxError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: DetectSyntaxError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: DetectSyntaxError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DetectSyntaxError extends ErrorSchema.Companion[DetectSyntaxError] {

    def internalServerException(internalServerException: InternalServerException): DetectSyntaxError = InternalServerExceptionCase(internalServerException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): DetectSyntaxError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): DetectSyntaxError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DetectSyntaxError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DetectSyntaxError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DetectSyntaxError { final def $ordinal: Int = 0 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends DetectSyntaxError { final def $ordinal: Int = 1 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends DetectSyntaxError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DetectSyntaxError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectSyntaxError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DetectSyntaxError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DetectSyntaxError]("InternalServerException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectSyntaxError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), DetectSyntaxError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[DetectSyntaxError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectSyntaxError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), DetectSyntaxError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[DetectSyntaxError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectSyntaxError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DetectSyntaxError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DetectSyntaxError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DetectSyntaxError] = union(
      DetectSyntaxError.InternalServerExceptionCase.alt,
      DetectSyntaxError.UnsupportedLanguageExceptionCase.alt,
      DetectSyntaxError.TextSizeLimitExceededExceptionCase.alt,
      DetectSyntaxError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DetectSyntaxError] = throwable match {
      case e: InternalServerException => Some(DetectSyntaxError.InternalServerExceptionCase(e))
      case e: UnsupportedLanguageException => Some(DetectSyntaxError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(DetectSyntaxError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(DetectSyntaxError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DetectSyntaxError): Throwable = e match {
      case DetectSyntaxError.InternalServerExceptionCase(e) => e
      case DetectSyntaxError.UnsupportedLanguageExceptionCase(e) => e
      case DetectSyntaxError.TextSizeLimitExceededExceptionCase(e) => e
      case DetectSyntaxError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class DetectTargetedSentiment(input: DetectTargetedSentimentRequest) extends ComprehendOperation[DetectTargetedSentimentRequest, ComprehendOperation.DetectTargetedSentimentError, DetectTargetedSentimentResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[DetectTargetedSentimentRequest, ComprehendOperation.DetectTargetedSentimentError, DetectTargetedSentimentResponse, Nothing, Nothing] = impl.detectTargetedSentiment(input.text, input.languageCode)
    def ordinal: Int = 40
    def endpoint: smithy4s.Endpoint[ComprehendOperation,DetectTargetedSentimentRequest, ComprehendOperation.DetectTargetedSentimentError, DetectTargetedSentimentResponse, Nothing, Nothing] = DetectTargetedSentiment
  }
  object DetectTargetedSentiment extends smithy4s.Endpoint[ComprehendOperation,DetectTargetedSentimentRequest, ComprehendOperation.DetectTargetedSentimentError, DetectTargetedSentimentResponse, Nothing, Nothing] {
    val schema: OperationSchema[DetectTargetedSentimentRequest, ComprehendOperation.DetectTargetedSentimentError, DetectTargetedSentimentResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "DetectTargetedSentiment"))
      .withInput(DetectTargetedSentimentRequest.schema)
      .withError(DetectTargetedSentimentError.errorSchema)
      .withOutput(DetectTargetedSentimentResponse.schema)
      .withHints(smithy.api.Documentation("<p>Inspects the input text and returns a sentiment analysis for each entity identified in the text.</p>\n         <p>For more information about targeted sentiment, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html\">Targeted sentiment</a>.</p>"))
    def wrap(input: DetectTargetedSentimentRequest): DetectTargetedSentiment = DetectTargetedSentiment(input)
  }
  sealed trait DetectTargetedSentimentError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: DetectTargetedSentimentError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = DetectTargetedSentimentError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def unsupportedLanguageException: Option[UnsupportedLanguageException] = DetectTargetedSentimentError.UnsupportedLanguageExceptionCase.alt.project.lift(self).map(_.unsupportedLanguageException)
      def textSizeLimitExceededException: Option[TextSizeLimitExceededException] = DetectTargetedSentimentError.TextSizeLimitExceededExceptionCase.alt.project.lift(self).map(_.textSizeLimitExceededException)
      def invalidRequestException: Option[InvalidRequestException] = DetectTargetedSentimentError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: DetectTargetedSentimentError.Visitor[A]): A = this match {
      case value: DetectTargetedSentimentError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: DetectTargetedSentimentError.UnsupportedLanguageExceptionCase => visitor.unsupportedLanguageException(value.unsupportedLanguageException)
      case value: DetectTargetedSentimentError.TextSizeLimitExceededExceptionCase => visitor.textSizeLimitExceededException(value.textSizeLimitExceededException)
      case value: DetectTargetedSentimentError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object DetectTargetedSentimentError extends ErrorSchema.Companion[DetectTargetedSentimentError] {

    def internalServerException(internalServerException: InternalServerException): DetectTargetedSentimentError = InternalServerExceptionCase(internalServerException)
    def unsupportedLanguageException(unsupportedLanguageException: UnsupportedLanguageException): DetectTargetedSentimentError = UnsupportedLanguageExceptionCase(unsupportedLanguageException)
    def textSizeLimitExceededException(textSizeLimitExceededException: TextSizeLimitExceededException): DetectTargetedSentimentError = TextSizeLimitExceededExceptionCase(textSizeLimitExceededException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): DetectTargetedSentimentError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "DetectTargetedSentimentError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends DetectTargetedSentimentError { final def $ordinal: Int = 0 }
    final case class UnsupportedLanguageExceptionCase(unsupportedLanguageException: UnsupportedLanguageException) extends DetectTargetedSentimentError { final def $ordinal: Int = 1 }
    final case class TextSizeLimitExceededExceptionCase(textSizeLimitExceededException: TextSizeLimitExceededException) extends DetectTargetedSentimentError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends DetectTargetedSentimentError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectTargetedSentimentError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), DetectTargetedSentimentError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[DetectTargetedSentimentError]("InternalServerException")
    }
    object UnsupportedLanguageExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectTargetedSentimentError.UnsupportedLanguageExceptionCase] = bijection(UnsupportedLanguageException.schema.addHints(hints), DetectTargetedSentimentError.UnsupportedLanguageExceptionCase(_), _.unsupportedLanguageException)
      val alt = schema.oneOf[DetectTargetedSentimentError]("UnsupportedLanguageException")
    }
    object TextSizeLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectTargetedSentimentError.TextSizeLimitExceededExceptionCase] = bijection(TextSizeLimitExceededException.schema.addHints(hints), DetectTargetedSentimentError.TextSizeLimitExceededExceptionCase(_), _.textSizeLimitExceededException)
      val alt = schema.oneOf[DetectTargetedSentimentError]("TextSizeLimitExceededException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[DetectTargetedSentimentError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), DetectTargetedSentimentError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[DetectTargetedSentimentError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def unsupportedLanguageException(value: UnsupportedLanguageException): A
      def textSizeLimitExceededException(value: TextSizeLimitExceededException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def unsupportedLanguageException(value: UnsupportedLanguageException): A = default
        def textSizeLimitExceededException(value: TextSizeLimitExceededException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[DetectTargetedSentimentError] = union(
      DetectTargetedSentimentError.InternalServerExceptionCase.alt,
      DetectTargetedSentimentError.UnsupportedLanguageExceptionCase.alt,
      DetectTargetedSentimentError.TextSizeLimitExceededExceptionCase.alt,
      DetectTargetedSentimentError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[DetectTargetedSentimentError] = throwable match {
      case e: InternalServerException => Some(DetectTargetedSentimentError.InternalServerExceptionCase(e))
      case e: UnsupportedLanguageException => Some(DetectTargetedSentimentError.UnsupportedLanguageExceptionCase(e))
      case e: TextSizeLimitExceededException => Some(DetectTargetedSentimentError.TextSizeLimitExceededExceptionCase(e))
      case e: InvalidRequestException => Some(DetectTargetedSentimentError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: DetectTargetedSentimentError): Throwable = e match {
      case DetectTargetedSentimentError.InternalServerExceptionCase(e) => e
      case DetectTargetedSentimentError.UnsupportedLanguageExceptionCase(e) => e
      case DetectTargetedSentimentError.TextSizeLimitExceededExceptionCase(e) => e
      case DetectTargetedSentimentError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ImportModel(input: ImportModelRequest) extends ComprehendOperation[ImportModelRequest, ComprehendOperation.ImportModelError, ImportModelResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ImportModelRequest, ComprehendOperation.ImportModelError, ImportModelResponse, Nothing, Nothing] = impl.importModel(input.sourceModelArn, input.modelName, input.versionName, input.modelKmsKeyId, input.dataAccessRoleArn, input.tags)
    def ordinal: Int = 41
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ImportModelRequest, ComprehendOperation.ImportModelError, ImportModelResponse, Nothing, Nothing] = ImportModel
  }
  object ImportModel extends smithy4s.Endpoint[ComprehendOperation,ImportModelRequest, ComprehendOperation.ImportModelError, ImportModelResponse, Nothing, Nothing] {
    val schema: OperationSchema[ImportModelRequest, ComprehendOperation.ImportModelError, ImportModelResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ImportModel"))
      .withInput(ImportModelRequest.schema)
      .withError(ImportModelError.errorSchema)
      .withOutput(ImportModelResponse.schema)
      .withHints(smithy.api.Documentation("<p>Creates a new custom model that replicates a source custom model that you import. The\n      source model can be in your Amazon Web Services account or another one.</p>\n         <p>If the source model is in another Amazon Web Services account, then it must have a resource-based policy\n      that authorizes you to import it.</p>\n         <p>The source model must be in the same Amazon Web Services Region that you\'re using when you import. You\n      can\'t import a model that\'s in a different Region.</p>"))
    def wrap(input: ImportModelRequest): ImportModel = ImportModel(input)
  }
  sealed trait ImportModelError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ImportModelError = this
    def $ordinal: Int

    object project {
      def resourceLimitExceededException: Option[ResourceLimitExceededException] = ImportModelError.ResourceLimitExceededExceptionCase.alt.project.lift(self).map(_.resourceLimitExceededException)
      def internalServerException: Option[InternalServerException] = ImportModelError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = ImportModelError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = ImportModelError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = ImportModelError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = ImportModelError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ImportModelError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ImportModelError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = ImportModelError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: ImportModelError.Visitor[A]): A = this match {
      case value: ImportModelError.ResourceLimitExceededExceptionCase => visitor.resourceLimitExceededException(value.resourceLimitExceededException)
      case value: ImportModelError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ImportModelError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: ImportModelError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: ImportModelError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: ImportModelError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: ImportModelError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ImportModelError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: ImportModelError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object ImportModelError extends ErrorSchema.Companion[ImportModelError] {

    def resourceLimitExceededException(resourceLimitExceededException: ResourceLimitExceededException): ImportModelError = ResourceLimitExceededExceptionCase(resourceLimitExceededException)
    def internalServerException(internalServerException: InternalServerException): ImportModelError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): ImportModelError = TooManyTagsExceptionCase(tooManyTagsException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): ImportModelError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): ImportModelError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): ImportModelError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ImportModelError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ImportModelError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): ImportModelError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ImportModelError")

    val hints: Hints = Hints.empty

    final case class ResourceLimitExceededExceptionCase(resourceLimitExceededException: ResourceLimitExceededException) extends ImportModelError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ImportModelError { final def $ordinal: Int = 1 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends ImportModelError { final def $ordinal: Int = 2 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends ImportModelError { final def $ordinal: Int = 3 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends ImportModelError { final def $ordinal: Int = 4 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends ImportModelError { final def $ordinal: Int = 5 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ImportModelError { final def $ordinal: Int = 6 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ImportModelError { final def $ordinal: Int = 7 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends ImportModelError { final def $ordinal: Int = 8 }

    object ResourceLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ImportModelError.ResourceLimitExceededExceptionCase] = bijection(ResourceLimitExceededException.schema.addHints(hints), ImportModelError.ResourceLimitExceededExceptionCase(_), _.resourceLimitExceededException)
      val alt = schema.oneOf[ImportModelError]("ResourceLimitExceededException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ImportModelError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ImportModelError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ImportModelError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ImportModelError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), ImportModelError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[ImportModelError]("TooManyTagsException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ImportModelError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), ImportModelError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[ImportModelError]("ResourceUnavailableException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ImportModelError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), ImportModelError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[ImportModelError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ImportModelError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), ImportModelError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[ImportModelError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ImportModelError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ImportModelError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ImportModelError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ImportModelError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ImportModelError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ImportModelError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ImportModelError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), ImportModelError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[ImportModelError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def resourceLimitExceededException(value: ResourceLimitExceededException): A
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def resourceLimitExceededException(value: ResourceLimitExceededException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[ImportModelError] = union(
      ImportModelError.ResourceLimitExceededExceptionCase.alt,
      ImportModelError.InternalServerExceptionCase.alt,
      ImportModelError.TooManyTagsExceptionCase.alt,
      ImportModelError.ResourceUnavailableExceptionCase.alt,
      ImportModelError.KmsKeyValidationExceptionCase.alt,
      ImportModelError.ResourceInUseExceptionCase.alt,
      ImportModelError.TooManyRequestsExceptionCase.alt,
      ImportModelError.InvalidRequestExceptionCase.alt,
      ImportModelError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ImportModelError] = throwable match {
      case e: ResourceLimitExceededException => Some(ImportModelError.ResourceLimitExceededExceptionCase(e))
      case e: InternalServerException => Some(ImportModelError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(ImportModelError.TooManyTagsExceptionCase(e))
      case e: ResourceUnavailableException => Some(ImportModelError.ResourceUnavailableExceptionCase(e))
      case e: KmsKeyValidationException => Some(ImportModelError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(ImportModelError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(ImportModelError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ImportModelError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(ImportModelError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ImportModelError): Throwable = e match {
      case ImportModelError.ResourceLimitExceededExceptionCase(e) => e
      case ImportModelError.InternalServerExceptionCase(e) => e
      case ImportModelError.TooManyTagsExceptionCase(e) => e
      case ImportModelError.ResourceUnavailableExceptionCase(e) => e
      case ImportModelError.KmsKeyValidationExceptionCase(e) => e
      case ImportModelError.ResourceInUseExceptionCase(e) => e
      case ImportModelError.TooManyRequestsExceptionCase(e) => e
      case ImportModelError.InvalidRequestExceptionCase(e) => e
      case ImportModelError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class ListDatasets(input: ListDatasetsRequest) extends ComprehendOperation[ListDatasetsRequest, ComprehendOperation.ListDatasetsError, ListDatasetsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListDatasetsRequest, ComprehendOperation.ListDatasetsError, ListDatasetsResponse, Nothing, Nothing] = impl.listDatasets(input.flywheelArn, input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 42
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListDatasetsRequest, ComprehendOperation.ListDatasetsError, ListDatasetsResponse, Nothing, Nothing] = ListDatasets
  }
  object ListDatasets extends smithy4s.Endpoint[ComprehendOperation,ListDatasetsRequest, ComprehendOperation.ListDatasetsError, ListDatasetsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListDatasetsRequest, ComprehendOperation.ListDatasetsError, ListDatasetsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListDatasets"))
      .withInput(ListDatasetsRequest.schema)
      .withError(ListDatasetsError.errorSchema)
      .withOutput(ListDatasetsResponse.schema)
      .withHints(smithy.api.Documentation("<p>List the datasets that you have configured in this Region. For more information about datasets, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html\">\n      Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListDatasetsRequest): ListDatasets = ListDatasets(input)
  }
  sealed trait ListDatasetsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListDatasetsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListDatasetsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListDatasetsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListDatasetsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListDatasetsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = ListDatasetsError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: ListDatasetsError.Visitor[A]): A = this match {
      case value: ListDatasetsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListDatasetsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListDatasetsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListDatasetsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: ListDatasetsError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object ListDatasetsError extends ErrorSchema.Companion[ListDatasetsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListDatasetsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListDatasetsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListDatasetsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListDatasetsError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): ListDatasetsError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListDatasetsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListDatasetsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListDatasetsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListDatasetsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListDatasetsError { final def $ordinal: Int = 3 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends ListDatasetsError { final def $ordinal: Int = 4 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDatasetsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListDatasetsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListDatasetsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDatasetsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListDatasetsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListDatasetsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDatasetsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListDatasetsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListDatasetsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDatasetsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListDatasetsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListDatasetsError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDatasetsError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), ListDatasetsError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[ListDatasetsError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[ListDatasetsError] = union(
      ListDatasetsError.InvalidFilterExceptionCase.alt,
      ListDatasetsError.InternalServerExceptionCase.alt,
      ListDatasetsError.TooManyRequestsExceptionCase.alt,
      ListDatasetsError.InvalidRequestExceptionCase.alt,
      ListDatasetsError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListDatasetsError] = throwable match {
      case e: InvalidFilterException => Some(ListDatasetsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListDatasetsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListDatasetsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListDatasetsError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(ListDatasetsError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListDatasetsError): Throwable = e match {
      case ListDatasetsError.InvalidFilterExceptionCase(e) => e
      case ListDatasetsError.InternalServerExceptionCase(e) => e
      case ListDatasetsError.TooManyRequestsExceptionCase(e) => e
      case ListDatasetsError.InvalidRequestExceptionCase(e) => e
      case ListDatasetsError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class ListDocumentClassificationJobs(input: ListDocumentClassificationJobsRequest) extends ComprehendOperation[ListDocumentClassificationJobsRequest, ComprehendOperation.ListDocumentClassificationJobsError, ListDocumentClassificationJobsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListDocumentClassificationJobsRequest, ComprehendOperation.ListDocumentClassificationJobsError, ListDocumentClassificationJobsResponse, Nothing, Nothing] = impl.listDocumentClassificationJobs(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 43
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListDocumentClassificationJobsRequest, ComprehendOperation.ListDocumentClassificationJobsError, ListDocumentClassificationJobsResponse, Nothing, Nothing] = ListDocumentClassificationJobs
  }
  object ListDocumentClassificationJobs extends smithy4s.Endpoint[ComprehendOperation,ListDocumentClassificationJobsRequest, ComprehendOperation.ListDocumentClassificationJobsError, ListDocumentClassificationJobsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListDocumentClassificationJobsRequest, ComprehendOperation.ListDocumentClassificationJobsError, ListDocumentClassificationJobsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListDocumentClassificationJobs"))
      .withInput(ListDocumentClassificationJobsRequest.schema)
      .withError(ListDocumentClassificationJobsError.errorSchema)
      .withOutput(ListDocumentClassificationJobsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of the documentation classification jobs that you have submitted.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListDocumentClassificationJobsRequest): ListDocumentClassificationJobs = ListDocumentClassificationJobs(input)
  }
  sealed trait ListDocumentClassificationJobsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListDocumentClassificationJobsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListDocumentClassificationJobsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListDocumentClassificationJobsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListDocumentClassificationJobsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListDocumentClassificationJobsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListDocumentClassificationJobsError.Visitor[A]): A = this match {
      case value: ListDocumentClassificationJobsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListDocumentClassificationJobsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListDocumentClassificationJobsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListDocumentClassificationJobsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListDocumentClassificationJobsError extends ErrorSchema.Companion[ListDocumentClassificationJobsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListDocumentClassificationJobsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListDocumentClassificationJobsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListDocumentClassificationJobsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListDocumentClassificationJobsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListDocumentClassificationJobsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListDocumentClassificationJobsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListDocumentClassificationJobsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListDocumentClassificationJobsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListDocumentClassificationJobsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassificationJobsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListDocumentClassificationJobsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListDocumentClassificationJobsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassificationJobsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListDocumentClassificationJobsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListDocumentClassificationJobsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassificationJobsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListDocumentClassificationJobsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListDocumentClassificationJobsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassificationJobsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListDocumentClassificationJobsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListDocumentClassificationJobsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListDocumentClassificationJobsError] = union(
      ListDocumentClassificationJobsError.InvalidFilterExceptionCase.alt,
      ListDocumentClassificationJobsError.InternalServerExceptionCase.alt,
      ListDocumentClassificationJobsError.TooManyRequestsExceptionCase.alt,
      ListDocumentClassificationJobsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListDocumentClassificationJobsError] = throwable match {
      case e: InvalidFilterException => Some(ListDocumentClassificationJobsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListDocumentClassificationJobsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListDocumentClassificationJobsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListDocumentClassificationJobsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListDocumentClassificationJobsError): Throwable = e match {
      case ListDocumentClassificationJobsError.InvalidFilterExceptionCase(e) => e
      case ListDocumentClassificationJobsError.InternalServerExceptionCase(e) => e
      case ListDocumentClassificationJobsError.TooManyRequestsExceptionCase(e) => e
      case ListDocumentClassificationJobsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListDocumentClassifiers(input: ListDocumentClassifiersRequest) extends ComprehendOperation[ListDocumentClassifiersRequest, ComprehendOperation.ListDocumentClassifiersError, ListDocumentClassifiersResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListDocumentClassifiersRequest, ComprehendOperation.ListDocumentClassifiersError, ListDocumentClassifiersResponse, Nothing, Nothing] = impl.listDocumentClassifiers(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 44
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListDocumentClassifiersRequest, ComprehendOperation.ListDocumentClassifiersError, ListDocumentClassifiersResponse, Nothing, Nothing] = ListDocumentClassifiers
  }
  object ListDocumentClassifiers extends smithy4s.Endpoint[ComprehendOperation,ListDocumentClassifiersRequest, ComprehendOperation.ListDocumentClassifiersError, ListDocumentClassifiersResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListDocumentClassifiersRequest, ComprehendOperation.ListDocumentClassifiersError, ListDocumentClassifiersResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListDocumentClassifiers"))
      .withInput(ListDocumentClassifiersRequest.schema)
      .withError(ListDocumentClassifiersError.errorSchema)
      .withOutput(ListDocumentClassifiersResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of the document classifiers that you have created.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListDocumentClassifiersRequest): ListDocumentClassifiers = ListDocumentClassifiers(input)
  }
  sealed trait ListDocumentClassifiersError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListDocumentClassifiersError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListDocumentClassifiersError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListDocumentClassifiersError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListDocumentClassifiersError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListDocumentClassifiersError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListDocumentClassifiersError.Visitor[A]): A = this match {
      case value: ListDocumentClassifiersError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListDocumentClassifiersError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListDocumentClassifiersError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListDocumentClassifiersError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListDocumentClassifiersError extends ErrorSchema.Companion[ListDocumentClassifiersError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListDocumentClassifiersError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListDocumentClassifiersError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListDocumentClassifiersError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListDocumentClassifiersError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListDocumentClassifiersError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListDocumentClassifiersError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListDocumentClassifiersError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListDocumentClassifiersError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListDocumentClassifiersError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassifiersError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListDocumentClassifiersError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListDocumentClassifiersError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassifiersError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListDocumentClassifiersError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListDocumentClassifiersError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassifiersError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListDocumentClassifiersError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListDocumentClassifiersError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassifiersError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListDocumentClassifiersError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListDocumentClassifiersError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListDocumentClassifiersError] = union(
      ListDocumentClassifiersError.InvalidFilterExceptionCase.alt,
      ListDocumentClassifiersError.InternalServerExceptionCase.alt,
      ListDocumentClassifiersError.TooManyRequestsExceptionCase.alt,
      ListDocumentClassifiersError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListDocumentClassifiersError] = throwable match {
      case e: InvalidFilterException => Some(ListDocumentClassifiersError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListDocumentClassifiersError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListDocumentClassifiersError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListDocumentClassifiersError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListDocumentClassifiersError): Throwable = e match {
      case ListDocumentClassifiersError.InvalidFilterExceptionCase(e) => e
      case ListDocumentClassifiersError.InternalServerExceptionCase(e) => e
      case ListDocumentClassifiersError.TooManyRequestsExceptionCase(e) => e
      case ListDocumentClassifiersError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListDocumentClassifierSummaries(input: ListDocumentClassifierSummariesRequest) extends ComprehendOperation[ListDocumentClassifierSummariesRequest, ComprehendOperation.ListDocumentClassifierSummariesError, ListDocumentClassifierSummariesResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListDocumentClassifierSummariesRequest, ComprehendOperation.ListDocumentClassifierSummariesError, ListDocumentClassifierSummariesResponse, Nothing, Nothing] = impl.listDocumentClassifierSummaries(input.nextToken, input.maxResults)
    def ordinal: Int = 45
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListDocumentClassifierSummariesRequest, ComprehendOperation.ListDocumentClassifierSummariesError, ListDocumentClassifierSummariesResponse, Nothing, Nothing] = ListDocumentClassifierSummaries
  }
  object ListDocumentClassifierSummaries extends smithy4s.Endpoint[ComprehendOperation,ListDocumentClassifierSummariesRequest, ComprehendOperation.ListDocumentClassifierSummariesError, ListDocumentClassifierSummariesResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListDocumentClassifierSummariesRequest, ComprehendOperation.ListDocumentClassifierSummariesError, ListDocumentClassifierSummariesResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListDocumentClassifierSummaries"))
      .withInput(ListDocumentClassifierSummariesRequest.schema)
      .withError(ListDocumentClassifierSummariesError.errorSchema)
      .withOutput(ListDocumentClassifierSummariesResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of summaries of the document classifiers that you have created</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListDocumentClassifierSummariesRequest): ListDocumentClassifierSummaries = ListDocumentClassifierSummaries(input)
  }
  sealed trait ListDocumentClassifierSummariesError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListDocumentClassifierSummariesError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = ListDocumentClassifierSummariesError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListDocumentClassifierSummariesError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListDocumentClassifierSummariesError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListDocumentClassifierSummariesError.Visitor[A]): A = this match {
      case value: ListDocumentClassifierSummariesError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListDocumentClassifierSummariesError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListDocumentClassifierSummariesError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListDocumentClassifierSummariesError extends ErrorSchema.Companion[ListDocumentClassifierSummariesError] {

    def internalServerException(internalServerException: InternalServerException): ListDocumentClassifierSummariesError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListDocumentClassifierSummariesError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListDocumentClassifierSummariesError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListDocumentClassifierSummariesError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListDocumentClassifierSummariesError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListDocumentClassifierSummariesError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListDocumentClassifierSummariesError { final def $ordinal: Int = 2 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassifierSummariesError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListDocumentClassifierSummariesError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListDocumentClassifierSummariesError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassifierSummariesError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListDocumentClassifierSummariesError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListDocumentClassifierSummariesError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDocumentClassifierSummariesError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListDocumentClassifierSummariesError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListDocumentClassifierSummariesError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListDocumentClassifierSummariesError] = union(
      ListDocumentClassifierSummariesError.InternalServerExceptionCase.alt,
      ListDocumentClassifierSummariesError.TooManyRequestsExceptionCase.alt,
      ListDocumentClassifierSummariesError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListDocumentClassifierSummariesError] = throwable match {
      case e: InternalServerException => Some(ListDocumentClassifierSummariesError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListDocumentClassifierSummariesError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListDocumentClassifierSummariesError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListDocumentClassifierSummariesError): Throwable = e match {
      case ListDocumentClassifierSummariesError.InternalServerExceptionCase(e) => e
      case ListDocumentClassifierSummariesError.TooManyRequestsExceptionCase(e) => e
      case ListDocumentClassifierSummariesError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListDominantLanguageDetectionJobs(input: ListDominantLanguageDetectionJobsRequest) extends ComprehendOperation[ListDominantLanguageDetectionJobsRequest, ComprehendOperation.ListDominantLanguageDetectionJobsError, ListDominantLanguageDetectionJobsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListDominantLanguageDetectionJobsRequest, ComprehendOperation.ListDominantLanguageDetectionJobsError, ListDominantLanguageDetectionJobsResponse, Nothing, Nothing] = impl.listDominantLanguageDetectionJobs(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 46
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListDominantLanguageDetectionJobsRequest, ComprehendOperation.ListDominantLanguageDetectionJobsError, ListDominantLanguageDetectionJobsResponse, Nothing, Nothing] = ListDominantLanguageDetectionJobs
  }
  object ListDominantLanguageDetectionJobs extends smithy4s.Endpoint[ComprehendOperation,ListDominantLanguageDetectionJobsRequest, ComprehendOperation.ListDominantLanguageDetectionJobsError, ListDominantLanguageDetectionJobsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListDominantLanguageDetectionJobsRequest, ComprehendOperation.ListDominantLanguageDetectionJobsError, ListDominantLanguageDetectionJobsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListDominantLanguageDetectionJobs"))
      .withInput(ListDominantLanguageDetectionJobsRequest.schema)
      .withError(ListDominantLanguageDetectionJobsError.errorSchema)
      .withOutput(ListDominantLanguageDetectionJobsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of the dominant language detection jobs that you have submitted.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListDominantLanguageDetectionJobsRequest): ListDominantLanguageDetectionJobs = ListDominantLanguageDetectionJobs(input)
  }
  sealed trait ListDominantLanguageDetectionJobsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListDominantLanguageDetectionJobsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListDominantLanguageDetectionJobsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListDominantLanguageDetectionJobsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListDominantLanguageDetectionJobsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListDominantLanguageDetectionJobsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListDominantLanguageDetectionJobsError.Visitor[A]): A = this match {
      case value: ListDominantLanguageDetectionJobsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListDominantLanguageDetectionJobsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListDominantLanguageDetectionJobsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListDominantLanguageDetectionJobsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListDominantLanguageDetectionJobsError extends ErrorSchema.Companion[ListDominantLanguageDetectionJobsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListDominantLanguageDetectionJobsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListDominantLanguageDetectionJobsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListDominantLanguageDetectionJobsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListDominantLanguageDetectionJobsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListDominantLanguageDetectionJobsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListDominantLanguageDetectionJobsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListDominantLanguageDetectionJobsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListDominantLanguageDetectionJobsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListDominantLanguageDetectionJobsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDominantLanguageDetectionJobsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListDominantLanguageDetectionJobsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListDominantLanguageDetectionJobsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDominantLanguageDetectionJobsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListDominantLanguageDetectionJobsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListDominantLanguageDetectionJobsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDominantLanguageDetectionJobsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListDominantLanguageDetectionJobsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListDominantLanguageDetectionJobsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListDominantLanguageDetectionJobsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListDominantLanguageDetectionJobsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListDominantLanguageDetectionJobsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListDominantLanguageDetectionJobsError] = union(
      ListDominantLanguageDetectionJobsError.InvalidFilterExceptionCase.alt,
      ListDominantLanguageDetectionJobsError.InternalServerExceptionCase.alt,
      ListDominantLanguageDetectionJobsError.TooManyRequestsExceptionCase.alt,
      ListDominantLanguageDetectionJobsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListDominantLanguageDetectionJobsError] = throwable match {
      case e: InvalidFilterException => Some(ListDominantLanguageDetectionJobsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListDominantLanguageDetectionJobsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListDominantLanguageDetectionJobsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListDominantLanguageDetectionJobsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListDominantLanguageDetectionJobsError): Throwable = e match {
      case ListDominantLanguageDetectionJobsError.InvalidFilterExceptionCase(e) => e
      case ListDominantLanguageDetectionJobsError.InternalServerExceptionCase(e) => e
      case ListDominantLanguageDetectionJobsError.TooManyRequestsExceptionCase(e) => e
      case ListDominantLanguageDetectionJobsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListEndpoints(input: ListEndpointsRequest) extends ComprehendOperation[ListEndpointsRequest, ComprehendOperation.ListEndpointsError, ListEndpointsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListEndpointsRequest, ComprehendOperation.ListEndpointsError, ListEndpointsResponse, Nothing, Nothing] = impl.listEndpoints(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 47
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListEndpointsRequest, ComprehendOperation.ListEndpointsError, ListEndpointsResponse, Nothing, Nothing] = ListEndpoints
  }
  object ListEndpoints extends smithy4s.Endpoint[ComprehendOperation,ListEndpointsRequest, ComprehendOperation.ListEndpointsError, ListEndpointsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListEndpointsRequest, ComprehendOperation.ListEndpointsError, ListEndpointsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListEndpoints"))
      .withInput(ListEndpointsRequest.schema)
      .withError(ListEndpointsError.errorSchema)
      .withOutput(ListEndpointsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of all existing endpoints that you\'ve created.\n      For information about endpoints, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html\">Managing endpoints</a>.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = Some(smithy.api.NonEmptyString("EndpointPropertiesList")), pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListEndpointsRequest): ListEndpoints = ListEndpoints(input)
  }
  sealed trait ListEndpointsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListEndpointsError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = ListEndpointsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListEndpointsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListEndpointsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListEndpointsError.Visitor[A]): A = this match {
      case value: ListEndpointsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListEndpointsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListEndpointsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListEndpointsError extends ErrorSchema.Companion[ListEndpointsError] {

    def internalServerException(internalServerException: InternalServerException): ListEndpointsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListEndpointsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListEndpointsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListEndpointsError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListEndpointsError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListEndpointsError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListEndpointsError { final def $ordinal: Int = 2 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEndpointsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListEndpointsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListEndpointsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEndpointsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListEndpointsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListEndpointsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEndpointsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListEndpointsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListEndpointsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListEndpointsError] = union(
      ListEndpointsError.InternalServerExceptionCase.alt,
      ListEndpointsError.TooManyRequestsExceptionCase.alt,
      ListEndpointsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListEndpointsError] = throwable match {
      case e: InternalServerException => Some(ListEndpointsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListEndpointsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListEndpointsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListEndpointsError): Throwable = e match {
      case ListEndpointsError.InternalServerExceptionCase(e) => e
      case ListEndpointsError.TooManyRequestsExceptionCase(e) => e
      case ListEndpointsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListEntitiesDetectionJobs(input: ListEntitiesDetectionJobsRequest) extends ComprehendOperation[ListEntitiesDetectionJobsRequest, ComprehendOperation.ListEntitiesDetectionJobsError, ListEntitiesDetectionJobsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListEntitiesDetectionJobsRequest, ComprehendOperation.ListEntitiesDetectionJobsError, ListEntitiesDetectionJobsResponse, Nothing, Nothing] = impl.listEntitiesDetectionJobs(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 48
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListEntitiesDetectionJobsRequest, ComprehendOperation.ListEntitiesDetectionJobsError, ListEntitiesDetectionJobsResponse, Nothing, Nothing] = ListEntitiesDetectionJobs
  }
  object ListEntitiesDetectionJobs extends smithy4s.Endpoint[ComprehendOperation,ListEntitiesDetectionJobsRequest, ComprehendOperation.ListEntitiesDetectionJobsError, ListEntitiesDetectionJobsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListEntitiesDetectionJobsRequest, ComprehendOperation.ListEntitiesDetectionJobsError, ListEntitiesDetectionJobsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListEntitiesDetectionJobs"))
      .withInput(ListEntitiesDetectionJobsRequest.schema)
      .withError(ListEntitiesDetectionJobsError.errorSchema)
      .withOutput(ListEntitiesDetectionJobsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of the entity detection jobs that you have submitted.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListEntitiesDetectionJobsRequest): ListEntitiesDetectionJobs = ListEntitiesDetectionJobs(input)
  }
  sealed trait ListEntitiesDetectionJobsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListEntitiesDetectionJobsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListEntitiesDetectionJobsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListEntitiesDetectionJobsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListEntitiesDetectionJobsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListEntitiesDetectionJobsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListEntitiesDetectionJobsError.Visitor[A]): A = this match {
      case value: ListEntitiesDetectionJobsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListEntitiesDetectionJobsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListEntitiesDetectionJobsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListEntitiesDetectionJobsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListEntitiesDetectionJobsError extends ErrorSchema.Companion[ListEntitiesDetectionJobsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListEntitiesDetectionJobsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListEntitiesDetectionJobsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListEntitiesDetectionJobsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListEntitiesDetectionJobsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListEntitiesDetectionJobsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListEntitiesDetectionJobsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListEntitiesDetectionJobsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListEntitiesDetectionJobsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListEntitiesDetectionJobsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntitiesDetectionJobsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListEntitiesDetectionJobsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListEntitiesDetectionJobsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntitiesDetectionJobsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListEntitiesDetectionJobsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListEntitiesDetectionJobsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntitiesDetectionJobsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListEntitiesDetectionJobsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListEntitiesDetectionJobsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntitiesDetectionJobsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListEntitiesDetectionJobsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListEntitiesDetectionJobsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListEntitiesDetectionJobsError] = union(
      ListEntitiesDetectionJobsError.InvalidFilterExceptionCase.alt,
      ListEntitiesDetectionJobsError.InternalServerExceptionCase.alt,
      ListEntitiesDetectionJobsError.TooManyRequestsExceptionCase.alt,
      ListEntitiesDetectionJobsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListEntitiesDetectionJobsError] = throwable match {
      case e: InvalidFilterException => Some(ListEntitiesDetectionJobsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListEntitiesDetectionJobsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListEntitiesDetectionJobsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListEntitiesDetectionJobsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListEntitiesDetectionJobsError): Throwable = e match {
      case ListEntitiesDetectionJobsError.InvalidFilterExceptionCase(e) => e
      case ListEntitiesDetectionJobsError.InternalServerExceptionCase(e) => e
      case ListEntitiesDetectionJobsError.TooManyRequestsExceptionCase(e) => e
      case ListEntitiesDetectionJobsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListEntityRecognizers(input: ListEntityRecognizersRequest) extends ComprehendOperation[ListEntityRecognizersRequest, ComprehendOperation.ListEntityRecognizersError, ListEntityRecognizersResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListEntityRecognizersRequest, ComprehendOperation.ListEntityRecognizersError, ListEntityRecognizersResponse, Nothing, Nothing] = impl.listEntityRecognizers(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 49
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListEntityRecognizersRequest, ComprehendOperation.ListEntityRecognizersError, ListEntityRecognizersResponse, Nothing, Nothing] = ListEntityRecognizers
  }
  object ListEntityRecognizers extends smithy4s.Endpoint[ComprehendOperation,ListEntityRecognizersRequest, ComprehendOperation.ListEntityRecognizersError, ListEntityRecognizersResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListEntityRecognizersRequest, ComprehendOperation.ListEntityRecognizersError, ListEntityRecognizersResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListEntityRecognizers"))
      .withInput(ListEntityRecognizersRequest.schema)
      .withError(ListEntityRecognizersError.errorSchema)
      .withOutput(ListEntityRecognizersResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of the properties of all entity recognizers that you created, including\n      recognizers currently in training. Allows you to filter the list of recognizers based on\n      criteria such as status and submission time. This call returns up to 500 entity recognizers in\n      the list, with a default number of 100 recognizers in the list.</p>\n         <p>The results of this list are not in any particular order. Please get the list and sort\n      locally if needed.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListEntityRecognizersRequest): ListEntityRecognizers = ListEntityRecognizers(input)
  }
  sealed trait ListEntityRecognizersError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListEntityRecognizersError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListEntityRecognizersError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListEntityRecognizersError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListEntityRecognizersError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListEntityRecognizersError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListEntityRecognizersError.Visitor[A]): A = this match {
      case value: ListEntityRecognizersError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListEntityRecognizersError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListEntityRecognizersError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListEntityRecognizersError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListEntityRecognizersError extends ErrorSchema.Companion[ListEntityRecognizersError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListEntityRecognizersError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListEntityRecognizersError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListEntityRecognizersError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListEntityRecognizersError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListEntityRecognizersError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListEntityRecognizersError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListEntityRecognizersError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListEntityRecognizersError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListEntityRecognizersError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntityRecognizersError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListEntityRecognizersError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListEntityRecognizersError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntityRecognizersError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListEntityRecognizersError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListEntityRecognizersError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntityRecognizersError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListEntityRecognizersError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListEntityRecognizersError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntityRecognizersError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListEntityRecognizersError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListEntityRecognizersError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListEntityRecognizersError] = union(
      ListEntityRecognizersError.InvalidFilterExceptionCase.alt,
      ListEntityRecognizersError.InternalServerExceptionCase.alt,
      ListEntityRecognizersError.TooManyRequestsExceptionCase.alt,
      ListEntityRecognizersError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListEntityRecognizersError] = throwable match {
      case e: InvalidFilterException => Some(ListEntityRecognizersError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListEntityRecognizersError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListEntityRecognizersError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListEntityRecognizersError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListEntityRecognizersError): Throwable = e match {
      case ListEntityRecognizersError.InvalidFilterExceptionCase(e) => e
      case ListEntityRecognizersError.InternalServerExceptionCase(e) => e
      case ListEntityRecognizersError.TooManyRequestsExceptionCase(e) => e
      case ListEntityRecognizersError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListEntityRecognizerSummaries(input: ListEntityRecognizerSummariesRequest) extends ComprehendOperation[ListEntityRecognizerSummariesRequest, ComprehendOperation.ListEntityRecognizerSummariesError, ListEntityRecognizerSummariesResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListEntityRecognizerSummariesRequest, ComprehendOperation.ListEntityRecognizerSummariesError, ListEntityRecognizerSummariesResponse, Nothing, Nothing] = impl.listEntityRecognizerSummaries(input.nextToken, input.maxResults)
    def ordinal: Int = 50
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListEntityRecognizerSummariesRequest, ComprehendOperation.ListEntityRecognizerSummariesError, ListEntityRecognizerSummariesResponse, Nothing, Nothing] = ListEntityRecognizerSummaries
  }
  object ListEntityRecognizerSummaries extends smithy4s.Endpoint[ComprehendOperation,ListEntityRecognizerSummariesRequest, ComprehendOperation.ListEntityRecognizerSummariesError, ListEntityRecognizerSummariesResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListEntityRecognizerSummariesRequest, ComprehendOperation.ListEntityRecognizerSummariesError, ListEntityRecognizerSummariesResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListEntityRecognizerSummaries"))
      .withInput(ListEntityRecognizerSummariesRequest.schema)
      .withError(ListEntityRecognizerSummariesError.errorSchema)
      .withOutput(ListEntityRecognizerSummariesResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of summaries for the entity recognizers that you have created.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListEntityRecognizerSummariesRequest): ListEntityRecognizerSummaries = ListEntityRecognizerSummaries(input)
  }
  sealed trait ListEntityRecognizerSummariesError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListEntityRecognizerSummariesError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = ListEntityRecognizerSummariesError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListEntityRecognizerSummariesError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListEntityRecognizerSummariesError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListEntityRecognizerSummariesError.Visitor[A]): A = this match {
      case value: ListEntityRecognizerSummariesError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListEntityRecognizerSummariesError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListEntityRecognizerSummariesError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListEntityRecognizerSummariesError extends ErrorSchema.Companion[ListEntityRecognizerSummariesError] {

    def internalServerException(internalServerException: InternalServerException): ListEntityRecognizerSummariesError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListEntityRecognizerSummariesError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListEntityRecognizerSummariesError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListEntityRecognizerSummariesError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListEntityRecognizerSummariesError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListEntityRecognizerSummariesError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListEntityRecognizerSummariesError { final def $ordinal: Int = 2 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntityRecognizerSummariesError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListEntityRecognizerSummariesError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListEntityRecognizerSummariesError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntityRecognizerSummariesError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListEntityRecognizerSummariesError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListEntityRecognizerSummariesError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEntityRecognizerSummariesError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListEntityRecognizerSummariesError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListEntityRecognizerSummariesError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListEntityRecognizerSummariesError] = union(
      ListEntityRecognizerSummariesError.InternalServerExceptionCase.alt,
      ListEntityRecognizerSummariesError.TooManyRequestsExceptionCase.alt,
      ListEntityRecognizerSummariesError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListEntityRecognizerSummariesError] = throwable match {
      case e: InternalServerException => Some(ListEntityRecognizerSummariesError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListEntityRecognizerSummariesError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListEntityRecognizerSummariesError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListEntityRecognizerSummariesError): Throwable = e match {
      case ListEntityRecognizerSummariesError.InternalServerExceptionCase(e) => e
      case ListEntityRecognizerSummariesError.TooManyRequestsExceptionCase(e) => e
      case ListEntityRecognizerSummariesError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListEventsDetectionJobs(input: ListEventsDetectionJobsRequest) extends ComprehendOperation[ListEventsDetectionJobsRequest, ComprehendOperation.ListEventsDetectionJobsError, ListEventsDetectionJobsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListEventsDetectionJobsRequest, ComprehendOperation.ListEventsDetectionJobsError, ListEventsDetectionJobsResponse, Nothing, Nothing] = impl.listEventsDetectionJobs(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 51
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListEventsDetectionJobsRequest, ComprehendOperation.ListEventsDetectionJobsError, ListEventsDetectionJobsResponse, Nothing, Nothing] = ListEventsDetectionJobs
  }
  object ListEventsDetectionJobs extends smithy4s.Endpoint[ComprehendOperation,ListEventsDetectionJobsRequest, ComprehendOperation.ListEventsDetectionJobsError, ListEventsDetectionJobsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListEventsDetectionJobsRequest, ComprehendOperation.ListEventsDetectionJobsError, ListEventsDetectionJobsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListEventsDetectionJobs"))
      .withInput(ListEventsDetectionJobsRequest.schema)
      .withError(ListEventsDetectionJobsError.errorSchema)
      .withOutput(ListEventsDetectionJobsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of the events detection jobs that you have submitted.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListEventsDetectionJobsRequest): ListEventsDetectionJobs = ListEventsDetectionJobs(input)
  }
  sealed trait ListEventsDetectionJobsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListEventsDetectionJobsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListEventsDetectionJobsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListEventsDetectionJobsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListEventsDetectionJobsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListEventsDetectionJobsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListEventsDetectionJobsError.Visitor[A]): A = this match {
      case value: ListEventsDetectionJobsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListEventsDetectionJobsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListEventsDetectionJobsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListEventsDetectionJobsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListEventsDetectionJobsError extends ErrorSchema.Companion[ListEventsDetectionJobsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListEventsDetectionJobsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListEventsDetectionJobsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListEventsDetectionJobsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListEventsDetectionJobsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListEventsDetectionJobsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListEventsDetectionJobsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListEventsDetectionJobsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListEventsDetectionJobsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListEventsDetectionJobsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEventsDetectionJobsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListEventsDetectionJobsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListEventsDetectionJobsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEventsDetectionJobsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListEventsDetectionJobsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListEventsDetectionJobsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEventsDetectionJobsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListEventsDetectionJobsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListEventsDetectionJobsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListEventsDetectionJobsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListEventsDetectionJobsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListEventsDetectionJobsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListEventsDetectionJobsError] = union(
      ListEventsDetectionJobsError.InvalidFilterExceptionCase.alt,
      ListEventsDetectionJobsError.InternalServerExceptionCase.alt,
      ListEventsDetectionJobsError.TooManyRequestsExceptionCase.alt,
      ListEventsDetectionJobsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListEventsDetectionJobsError] = throwable match {
      case e: InvalidFilterException => Some(ListEventsDetectionJobsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListEventsDetectionJobsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListEventsDetectionJobsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListEventsDetectionJobsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListEventsDetectionJobsError): Throwable = e match {
      case ListEventsDetectionJobsError.InvalidFilterExceptionCase(e) => e
      case ListEventsDetectionJobsError.InternalServerExceptionCase(e) => e
      case ListEventsDetectionJobsError.TooManyRequestsExceptionCase(e) => e
      case ListEventsDetectionJobsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListFlywheelIterationHistory(input: ListFlywheelIterationHistoryRequest) extends ComprehendOperation[ListFlywheelIterationHistoryRequest, ComprehendOperation.ListFlywheelIterationHistoryError, ListFlywheelIterationHistoryResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListFlywheelIterationHistoryRequest, ComprehendOperation.ListFlywheelIterationHistoryError, ListFlywheelIterationHistoryResponse, Nothing, Nothing] = impl.listFlywheelIterationHistory(input.flywheelArn, input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 52
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListFlywheelIterationHistoryRequest, ComprehendOperation.ListFlywheelIterationHistoryError, ListFlywheelIterationHistoryResponse, Nothing, Nothing] = ListFlywheelIterationHistory
  }
  object ListFlywheelIterationHistory extends smithy4s.Endpoint[ComprehendOperation,ListFlywheelIterationHistoryRequest, ComprehendOperation.ListFlywheelIterationHistoryError, ListFlywheelIterationHistoryResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListFlywheelIterationHistoryRequest, ComprehendOperation.ListFlywheelIterationHistoryError, ListFlywheelIterationHistoryResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListFlywheelIterationHistory"))
      .withInput(ListFlywheelIterationHistoryRequest.schema)
      .withError(ListFlywheelIterationHistoryError.errorSchema)
      .withOutput(ListFlywheelIterationHistoryResponse.schema)
      .withHints(smithy.api.Documentation("<p>Information about the history of a flywheel iteration.\n      For more information about flywheels, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html\">\n      Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListFlywheelIterationHistoryRequest): ListFlywheelIterationHistory = ListFlywheelIterationHistory(input)
  }
  sealed trait ListFlywheelIterationHistoryError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListFlywheelIterationHistoryError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListFlywheelIterationHistoryError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListFlywheelIterationHistoryError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListFlywheelIterationHistoryError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListFlywheelIterationHistoryError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = ListFlywheelIterationHistoryError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: ListFlywheelIterationHistoryError.Visitor[A]): A = this match {
      case value: ListFlywheelIterationHistoryError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListFlywheelIterationHistoryError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListFlywheelIterationHistoryError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListFlywheelIterationHistoryError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: ListFlywheelIterationHistoryError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object ListFlywheelIterationHistoryError extends ErrorSchema.Companion[ListFlywheelIterationHistoryError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListFlywheelIterationHistoryError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListFlywheelIterationHistoryError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListFlywheelIterationHistoryError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListFlywheelIterationHistoryError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): ListFlywheelIterationHistoryError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListFlywheelIterationHistoryError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListFlywheelIterationHistoryError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListFlywheelIterationHistoryError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListFlywheelIterationHistoryError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListFlywheelIterationHistoryError { final def $ordinal: Int = 3 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends ListFlywheelIterationHistoryError { final def $ordinal: Int = 4 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListFlywheelIterationHistoryError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListFlywheelIterationHistoryError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListFlywheelIterationHistoryError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListFlywheelIterationHistoryError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListFlywheelIterationHistoryError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListFlywheelIterationHistoryError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListFlywheelIterationHistoryError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListFlywheelIterationHistoryError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListFlywheelIterationHistoryError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListFlywheelIterationHistoryError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListFlywheelIterationHistoryError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListFlywheelIterationHistoryError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListFlywheelIterationHistoryError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), ListFlywheelIterationHistoryError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[ListFlywheelIterationHistoryError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[ListFlywheelIterationHistoryError] = union(
      ListFlywheelIterationHistoryError.InvalidFilterExceptionCase.alt,
      ListFlywheelIterationHistoryError.InternalServerExceptionCase.alt,
      ListFlywheelIterationHistoryError.TooManyRequestsExceptionCase.alt,
      ListFlywheelIterationHistoryError.InvalidRequestExceptionCase.alt,
      ListFlywheelIterationHistoryError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListFlywheelIterationHistoryError] = throwable match {
      case e: InvalidFilterException => Some(ListFlywheelIterationHistoryError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListFlywheelIterationHistoryError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListFlywheelIterationHistoryError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListFlywheelIterationHistoryError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(ListFlywheelIterationHistoryError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListFlywheelIterationHistoryError): Throwable = e match {
      case ListFlywheelIterationHistoryError.InvalidFilterExceptionCase(e) => e
      case ListFlywheelIterationHistoryError.InternalServerExceptionCase(e) => e
      case ListFlywheelIterationHistoryError.TooManyRequestsExceptionCase(e) => e
      case ListFlywheelIterationHistoryError.InvalidRequestExceptionCase(e) => e
      case ListFlywheelIterationHistoryError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class ListFlywheels(input: ListFlywheelsRequest) extends ComprehendOperation[ListFlywheelsRequest, ComprehendOperation.ListFlywheelsError, ListFlywheelsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListFlywheelsRequest, ComprehendOperation.ListFlywheelsError, ListFlywheelsResponse, Nothing, Nothing] = impl.listFlywheels(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 53
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListFlywheelsRequest, ComprehendOperation.ListFlywheelsError, ListFlywheelsResponse, Nothing, Nothing] = ListFlywheels
  }
  object ListFlywheels extends smithy4s.Endpoint[ComprehendOperation,ListFlywheelsRequest, ComprehendOperation.ListFlywheelsError, ListFlywheelsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListFlywheelsRequest, ComprehendOperation.ListFlywheelsError, ListFlywheelsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListFlywheels"))
      .withInput(ListFlywheelsRequest.schema)
      .withError(ListFlywheelsError.errorSchema)
      .withOutput(ListFlywheelsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of the flywheels that you have created.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListFlywheelsRequest): ListFlywheels = ListFlywheels(input)
  }
  sealed trait ListFlywheelsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListFlywheelsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListFlywheelsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListFlywheelsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListFlywheelsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListFlywheelsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListFlywheelsError.Visitor[A]): A = this match {
      case value: ListFlywheelsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListFlywheelsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListFlywheelsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListFlywheelsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListFlywheelsError extends ErrorSchema.Companion[ListFlywheelsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListFlywheelsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListFlywheelsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListFlywheelsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListFlywheelsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListFlywheelsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListFlywheelsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListFlywheelsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListFlywheelsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListFlywheelsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListFlywheelsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListFlywheelsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListFlywheelsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListFlywheelsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListFlywheelsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListFlywheelsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListFlywheelsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListFlywheelsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListFlywheelsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListFlywheelsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListFlywheelsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListFlywheelsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListFlywheelsError] = union(
      ListFlywheelsError.InvalidFilterExceptionCase.alt,
      ListFlywheelsError.InternalServerExceptionCase.alt,
      ListFlywheelsError.TooManyRequestsExceptionCase.alt,
      ListFlywheelsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListFlywheelsError] = throwable match {
      case e: InvalidFilterException => Some(ListFlywheelsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListFlywheelsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListFlywheelsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListFlywheelsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListFlywheelsError): Throwable = e match {
      case ListFlywheelsError.InvalidFilterExceptionCase(e) => e
      case ListFlywheelsError.InternalServerExceptionCase(e) => e
      case ListFlywheelsError.TooManyRequestsExceptionCase(e) => e
      case ListFlywheelsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListKeyPhrasesDetectionJobs(input: ListKeyPhrasesDetectionJobsRequest) extends ComprehendOperation[ListKeyPhrasesDetectionJobsRequest, ComprehendOperation.ListKeyPhrasesDetectionJobsError, ListKeyPhrasesDetectionJobsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListKeyPhrasesDetectionJobsRequest, ComprehendOperation.ListKeyPhrasesDetectionJobsError, ListKeyPhrasesDetectionJobsResponse, Nothing, Nothing] = impl.listKeyPhrasesDetectionJobs(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 54
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListKeyPhrasesDetectionJobsRequest, ComprehendOperation.ListKeyPhrasesDetectionJobsError, ListKeyPhrasesDetectionJobsResponse, Nothing, Nothing] = ListKeyPhrasesDetectionJobs
  }
  object ListKeyPhrasesDetectionJobs extends smithy4s.Endpoint[ComprehendOperation,ListKeyPhrasesDetectionJobsRequest, ComprehendOperation.ListKeyPhrasesDetectionJobsError, ListKeyPhrasesDetectionJobsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListKeyPhrasesDetectionJobsRequest, ComprehendOperation.ListKeyPhrasesDetectionJobsError, ListKeyPhrasesDetectionJobsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListKeyPhrasesDetectionJobs"))
      .withInput(ListKeyPhrasesDetectionJobsRequest.schema)
      .withError(ListKeyPhrasesDetectionJobsError.errorSchema)
      .withOutput(ListKeyPhrasesDetectionJobsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Get a list of key phrase detection jobs that you have submitted.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListKeyPhrasesDetectionJobsRequest): ListKeyPhrasesDetectionJobs = ListKeyPhrasesDetectionJobs(input)
  }
  sealed trait ListKeyPhrasesDetectionJobsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListKeyPhrasesDetectionJobsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListKeyPhrasesDetectionJobsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListKeyPhrasesDetectionJobsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListKeyPhrasesDetectionJobsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListKeyPhrasesDetectionJobsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListKeyPhrasesDetectionJobsError.Visitor[A]): A = this match {
      case value: ListKeyPhrasesDetectionJobsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListKeyPhrasesDetectionJobsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListKeyPhrasesDetectionJobsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListKeyPhrasesDetectionJobsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListKeyPhrasesDetectionJobsError extends ErrorSchema.Companion[ListKeyPhrasesDetectionJobsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListKeyPhrasesDetectionJobsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListKeyPhrasesDetectionJobsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListKeyPhrasesDetectionJobsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListKeyPhrasesDetectionJobsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListKeyPhrasesDetectionJobsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListKeyPhrasesDetectionJobsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListKeyPhrasesDetectionJobsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListKeyPhrasesDetectionJobsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListKeyPhrasesDetectionJobsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListKeyPhrasesDetectionJobsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListKeyPhrasesDetectionJobsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListKeyPhrasesDetectionJobsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListKeyPhrasesDetectionJobsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListKeyPhrasesDetectionJobsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListKeyPhrasesDetectionJobsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListKeyPhrasesDetectionJobsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListKeyPhrasesDetectionJobsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListKeyPhrasesDetectionJobsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListKeyPhrasesDetectionJobsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListKeyPhrasesDetectionJobsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListKeyPhrasesDetectionJobsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListKeyPhrasesDetectionJobsError] = union(
      ListKeyPhrasesDetectionJobsError.InvalidFilterExceptionCase.alt,
      ListKeyPhrasesDetectionJobsError.InternalServerExceptionCase.alt,
      ListKeyPhrasesDetectionJobsError.TooManyRequestsExceptionCase.alt,
      ListKeyPhrasesDetectionJobsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListKeyPhrasesDetectionJobsError] = throwable match {
      case e: InvalidFilterException => Some(ListKeyPhrasesDetectionJobsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListKeyPhrasesDetectionJobsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListKeyPhrasesDetectionJobsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListKeyPhrasesDetectionJobsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListKeyPhrasesDetectionJobsError): Throwable = e match {
      case ListKeyPhrasesDetectionJobsError.InvalidFilterExceptionCase(e) => e
      case ListKeyPhrasesDetectionJobsError.InternalServerExceptionCase(e) => e
      case ListKeyPhrasesDetectionJobsError.TooManyRequestsExceptionCase(e) => e
      case ListKeyPhrasesDetectionJobsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListPiiEntitiesDetectionJobs(input: ListPiiEntitiesDetectionJobsRequest) extends ComprehendOperation[ListPiiEntitiesDetectionJobsRequest, ComprehendOperation.ListPiiEntitiesDetectionJobsError, ListPiiEntitiesDetectionJobsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListPiiEntitiesDetectionJobsRequest, ComprehendOperation.ListPiiEntitiesDetectionJobsError, ListPiiEntitiesDetectionJobsResponse, Nothing, Nothing] = impl.listPiiEntitiesDetectionJobs(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 55
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListPiiEntitiesDetectionJobsRequest, ComprehendOperation.ListPiiEntitiesDetectionJobsError, ListPiiEntitiesDetectionJobsResponse, Nothing, Nothing] = ListPiiEntitiesDetectionJobs
  }
  object ListPiiEntitiesDetectionJobs extends smithy4s.Endpoint[ComprehendOperation,ListPiiEntitiesDetectionJobsRequest, ComprehendOperation.ListPiiEntitiesDetectionJobsError, ListPiiEntitiesDetectionJobsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListPiiEntitiesDetectionJobsRequest, ComprehendOperation.ListPiiEntitiesDetectionJobsError, ListPiiEntitiesDetectionJobsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListPiiEntitiesDetectionJobs"))
      .withInput(ListPiiEntitiesDetectionJobsRequest.schema)
      .withError(ListPiiEntitiesDetectionJobsError.errorSchema)
      .withOutput(ListPiiEntitiesDetectionJobsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of the PII entity detection jobs that you have submitted.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = Some(smithy.api.NonEmptyString("PiiEntitiesDetectionJobPropertiesList")), pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListPiiEntitiesDetectionJobsRequest): ListPiiEntitiesDetectionJobs = ListPiiEntitiesDetectionJobs(input)
  }
  sealed trait ListPiiEntitiesDetectionJobsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListPiiEntitiesDetectionJobsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListPiiEntitiesDetectionJobsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListPiiEntitiesDetectionJobsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListPiiEntitiesDetectionJobsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListPiiEntitiesDetectionJobsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListPiiEntitiesDetectionJobsError.Visitor[A]): A = this match {
      case value: ListPiiEntitiesDetectionJobsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListPiiEntitiesDetectionJobsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListPiiEntitiesDetectionJobsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListPiiEntitiesDetectionJobsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListPiiEntitiesDetectionJobsError extends ErrorSchema.Companion[ListPiiEntitiesDetectionJobsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListPiiEntitiesDetectionJobsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListPiiEntitiesDetectionJobsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListPiiEntitiesDetectionJobsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListPiiEntitiesDetectionJobsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListPiiEntitiesDetectionJobsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListPiiEntitiesDetectionJobsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListPiiEntitiesDetectionJobsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListPiiEntitiesDetectionJobsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListPiiEntitiesDetectionJobsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListPiiEntitiesDetectionJobsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListPiiEntitiesDetectionJobsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListPiiEntitiesDetectionJobsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListPiiEntitiesDetectionJobsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListPiiEntitiesDetectionJobsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListPiiEntitiesDetectionJobsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListPiiEntitiesDetectionJobsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListPiiEntitiesDetectionJobsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListPiiEntitiesDetectionJobsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListPiiEntitiesDetectionJobsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListPiiEntitiesDetectionJobsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListPiiEntitiesDetectionJobsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListPiiEntitiesDetectionJobsError] = union(
      ListPiiEntitiesDetectionJobsError.InvalidFilterExceptionCase.alt,
      ListPiiEntitiesDetectionJobsError.InternalServerExceptionCase.alt,
      ListPiiEntitiesDetectionJobsError.TooManyRequestsExceptionCase.alt,
      ListPiiEntitiesDetectionJobsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListPiiEntitiesDetectionJobsError] = throwable match {
      case e: InvalidFilterException => Some(ListPiiEntitiesDetectionJobsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListPiiEntitiesDetectionJobsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListPiiEntitiesDetectionJobsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListPiiEntitiesDetectionJobsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListPiiEntitiesDetectionJobsError): Throwable = e match {
      case ListPiiEntitiesDetectionJobsError.InvalidFilterExceptionCase(e) => e
      case ListPiiEntitiesDetectionJobsError.InternalServerExceptionCase(e) => e
      case ListPiiEntitiesDetectionJobsError.TooManyRequestsExceptionCase(e) => e
      case ListPiiEntitiesDetectionJobsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListSentimentDetectionJobs(input: ListSentimentDetectionJobsRequest) extends ComprehendOperation[ListSentimentDetectionJobsRequest, ComprehendOperation.ListSentimentDetectionJobsError, ListSentimentDetectionJobsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListSentimentDetectionJobsRequest, ComprehendOperation.ListSentimentDetectionJobsError, ListSentimentDetectionJobsResponse, Nothing, Nothing] = impl.listSentimentDetectionJobs(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 56
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListSentimentDetectionJobsRequest, ComprehendOperation.ListSentimentDetectionJobsError, ListSentimentDetectionJobsResponse, Nothing, Nothing] = ListSentimentDetectionJobs
  }
  object ListSentimentDetectionJobs extends smithy4s.Endpoint[ComprehendOperation,ListSentimentDetectionJobsRequest, ComprehendOperation.ListSentimentDetectionJobsError, ListSentimentDetectionJobsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListSentimentDetectionJobsRequest, ComprehendOperation.ListSentimentDetectionJobsError, ListSentimentDetectionJobsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListSentimentDetectionJobs"))
      .withInput(ListSentimentDetectionJobsRequest.schema)
      .withError(ListSentimentDetectionJobsError.errorSchema)
      .withOutput(ListSentimentDetectionJobsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of sentiment detection jobs that you have submitted.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListSentimentDetectionJobsRequest): ListSentimentDetectionJobs = ListSentimentDetectionJobs(input)
  }
  sealed trait ListSentimentDetectionJobsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListSentimentDetectionJobsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListSentimentDetectionJobsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListSentimentDetectionJobsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListSentimentDetectionJobsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListSentimentDetectionJobsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListSentimentDetectionJobsError.Visitor[A]): A = this match {
      case value: ListSentimentDetectionJobsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListSentimentDetectionJobsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListSentimentDetectionJobsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListSentimentDetectionJobsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListSentimentDetectionJobsError extends ErrorSchema.Companion[ListSentimentDetectionJobsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListSentimentDetectionJobsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListSentimentDetectionJobsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListSentimentDetectionJobsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListSentimentDetectionJobsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListSentimentDetectionJobsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListSentimentDetectionJobsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListSentimentDetectionJobsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListSentimentDetectionJobsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListSentimentDetectionJobsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListSentimentDetectionJobsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListSentimentDetectionJobsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListSentimentDetectionJobsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListSentimentDetectionJobsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListSentimentDetectionJobsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListSentimentDetectionJobsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListSentimentDetectionJobsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListSentimentDetectionJobsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListSentimentDetectionJobsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListSentimentDetectionJobsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListSentimentDetectionJobsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListSentimentDetectionJobsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListSentimentDetectionJobsError] = union(
      ListSentimentDetectionJobsError.InvalidFilterExceptionCase.alt,
      ListSentimentDetectionJobsError.InternalServerExceptionCase.alt,
      ListSentimentDetectionJobsError.TooManyRequestsExceptionCase.alt,
      ListSentimentDetectionJobsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListSentimentDetectionJobsError] = throwable match {
      case e: InvalidFilterException => Some(ListSentimentDetectionJobsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListSentimentDetectionJobsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListSentimentDetectionJobsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListSentimentDetectionJobsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListSentimentDetectionJobsError): Throwable = e match {
      case ListSentimentDetectionJobsError.InvalidFilterExceptionCase(e) => e
      case ListSentimentDetectionJobsError.InternalServerExceptionCase(e) => e
      case ListSentimentDetectionJobsError.TooManyRequestsExceptionCase(e) => e
      case ListSentimentDetectionJobsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListTagsForResource(input: ListTagsForResourceRequest) extends ComprehendOperation[ListTagsForResourceRequest, ComprehendOperation.ListTagsForResourceError, ListTagsForResourceResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListTagsForResourceRequest, ComprehendOperation.ListTagsForResourceError, ListTagsForResourceResponse, Nothing, Nothing] = impl.listTagsForResource(input.resourceArn)
    def ordinal: Int = 57
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListTagsForResourceRequest, ComprehendOperation.ListTagsForResourceError, ListTagsForResourceResponse, Nothing, Nothing] = ListTagsForResource
  }
  object ListTagsForResource extends smithy4s.Endpoint[ComprehendOperation,ListTagsForResourceRequest, ComprehendOperation.ListTagsForResourceError, ListTagsForResourceResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListTagsForResourceRequest, ComprehendOperation.ListTagsForResourceError, ListTagsForResourceResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListTagsForResource"))
      .withInput(ListTagsForResourceRequest.schema)
      .withError(ListTagsForResourceError.errorSchema)
      .withOutput(ListTagsForResourceResponse.schema)
      .withHints(smithy.api.Documentation("<p>Lists all tags associated with a given Amazon Comprehend resource. </p>"))
    def wrap(input: ListTagsForResourceRequest): ListTagsForResource = ListTagsForResource(input)
  }
  sealed trait ListTagsForResourceError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListTagsForResourceError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = ListTagsForResourceError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = ListTagsForResourceError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = ListTagsForResourceError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: ListTagsForResourceError.Visitor[A]): A = this match {
      case value: ListTagsForResourceError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListTagsForResourceError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: ListTagsForResourceError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object ListTagsForResourceError extends ErrorSchema.Companion[ListTagsForResourceError] {

    def internalServerException(internalServerException: InternalServerException): ListTagsForResourceError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListTagsForResourceError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): ListTagsForResourceError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListTagsForResourceError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListTagsForResourceError { final def $ordinal: Int = 0 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListTagsForResourceError { final def $ordinal: Int = 1 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends ListTagsForResourceError { final def $ordinal: Int = 2 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTagsForResourceError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListTagsForResourceError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListTagsForResourceError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTagsForResourceError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListTagsForResourceError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListTagsForResourceError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTagsForResourceError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), ListTagsForResourceError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[ListTagsForResourceError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[ListTagsForResourceError] = union(
      ListTagsForResourceError.InternalServerExceptionCase.alt,
      ListTagsForResourceError.InvalidRequestExceptionCase.alt,
      ListTagsForResourceError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListTagsForResourceError] = throwable match {
      case e: InternalServerException => Some(ListTagsForResourceError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(ListTagsForResourceError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(ListTagsForResourceError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListTagsForResourceError): Throwable = e match {
      case ListTagsForResourceError.InternalServerExceptionCase(e) => e
      case ListTagsForResourceError.InvalidRequestExceptionCase(e) => e
      case ListTagsForResourceError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class ListTargetedSentimentDetectionJobs(input: ListTargetedSentimentDetectionJobsRequest) extends ComprehendOperation[ListTargetedSentimentDetectionJobsRequest, ComprehendOperation.ListTargetedSentimentDetectionJobsError, ListTargetedSentimentDetectionJobsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListTargetedSentimentDetectionJobsRequest, ComprehendOperation.ListTargetedSentimentDetectionJobsError, ListTargetedSentimentDetectionJobsResponse, Nothing, Nothing] = impl.listTargetedSentimentDetectionJobs(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 58
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListTargetedSentimentDetectionJobsRequest, ComprehendOperation.ListTargetedSentimentDetectionJobsError, ListTargetedSentimentDetectionJobsResponse, Nothing, Nothing] = ListTargetedSentimentDetectionJobs
  }
  object ListTargetedSentimentDetectionJobs extends smithy4s.Endpoint[ComprehendOperation,ListTargetedSentimentDetectionJobsRequest, ComprehendOperation.ListTargetedSentimentDetectionJobsError, ListTargetedSentimentDetectionJobsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListTargetedSentimentDetectionJobsRequest, ComprehendOperation.ListTargetedSentimentDetectionJobsError, ListTargetedSentimentDetectionJobsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListTargetedSentimentDetectionJobs"))
      .withInput(ListTargetedSentimentDetectionJobsRequest.schema)
      .withError(ListTargetedSentimentDetectionJobsError.errorSchema)
      .withOutput(ListTargetedSentimentDetectionJobsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of targeted sentiment detection jobs that you have submitted.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListTargetedSentimentDetectionJobsRequest): ListTargetedSentimentDetectionJobs = ListTargetedSentimentDetectionJobs(input)
  }
  sealed trait ListTargetedSentimentDetectionJobsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListTargetedSentimentDetectionJobsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListTargetedSentimentDetectionJobsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListTargetedSentimentDetectionJobsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListTargetedSentimentDetectionJobsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListTargetedSentimentDetectionJobsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListTargetedSentimentDetectionJobsError.Visitor[A]): A = this match {
      case value: ListTargetedSentimentDetectionJobsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListTargetedSentimentDetectionJobsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListTargetedSentimentDetectionJobsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListTargetedSentimentDetectionJobsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListTargetedSentimentDetectionJobsError extends ErrorSchema.Companion[ListTargetedSentimentDetectionJobsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListTargetedSentimentDetectionJobsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListTargetedSentimentDetectionJobsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListTargetedSentimentDetectionJobsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListTargetedSentimentDetectionJobsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListTargetedSentimentDetectionJobsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListTargetedSentimentDetectionJobsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListTargetedSentimentDetectionJobsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListTargetedSentimentDetectionJobsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListTargetedSentimentDetectionJobsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTargetedSentimentDetectionJobsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListTargetedSentimentDetectionJobsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListTargetedSentimentDetectionJobsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTargetedSentimentDetectionJobsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListTargetedSentimentDetectionJobsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListTargetedSentimentDetectionJobsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTargetedSentimentDetectionJobsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListTargetedSentimentDetectionJobsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListTargetedSentimentDetectionJobsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTargetedSentimentDetectionJobsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListTargetedSentimentDetectionJobsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListTargetedSentimentDetectionJobsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListTargetedSentimentDetectionJobsError] = union(
      ListTargetedSentimentDetectionJobsError.InvalidFilterExceptionCase.alt,
      ListTargetedSentimentDetectionJobsError.InternalServerExceptionCase.alt,
      ListTargetedSentimentDetectionJobsError.TooManyRequestsExceptionCase.alt,
      ListTargetedSentimentDetectionJobsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListTargetedSentimentDetectionJobsError] = throwable match {
      case e: InvalidFilterException => Some(ListTargetedSentimentDetectionJobsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListTargetedSentimentDetectionJobsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListTargetedSentimentDetectionJobsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListTargetedSentimentDetectionJobsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListTargetedSentimentDetectionJobsError): Throwable = e match {
      case ListTargetedSentimentDetectionJobsError.InvalidFilterExceptionCase(e) => e
      case ListTargetedSentimentDetectionJobsError.InternalServerExceptionCase(e) => e
      case ListTargetedSentimentDetectionJobsError.TooManyRequestsExceptionCase(e) => e
      case ListTargetedSentimentDetectionJobsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class ListTopicsDetectionJobs(input: ListTopicsDetectionJobsRequest) extends ComprehendOperation[ListTopicsDetectionJobsRequest, ComprehendOperation.ListTopicsDetectionJobsError, ListTopicsDetectionJobsResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[ListTopicsDetectionJobsRequest, ComprehendOperation.ListTopicsDetectionJobsError, ListTopicsDetectionJobsResponse, Nothing, Nothing] = impl.listTopicsDetectionJobs(input.filter, input.nextToken, input.maxResults)
    def ordinal: Int = 59
    def endpoint: smithy4s.Endpoint[ComprehendOperation,ListTopicsDetectionJobsRequest, ComprehendOperation.ListTopicsDetectionJobsError, ListTopicsDetectionJobsResponse, Nothing, Nothing] = ListTopicsDetectionJobs
  }
  object ListTopicsDetectionJobs extends smithy4s.Endpoint[ComprehendOperation,ListTopicsDetectionJobsRequest, ComprehendOperation.ListTopicsDetectionJobsError, ListTopicsDetectionJobsResponse, Nothing, Nothing] {
    val schema: OperationSchema[ListTopicsDetectionJobsRequest, ComprehendOperation.ListTopicsDetectionJobsError, ListTopicsDetectionJobsResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "ListTopicsDetectionJobs"))
      .withInput(ListTopicsDetectionJobsRequest.schema)
      .withError(ListTopicsDetectionJobsError.errorSchema)
      .withOutput(ListTopicsDetectionJobsResponse.schema)
      .withHints(smithy.api.Documentation("<p>Gets a list of the topic detection jobs that you have submitted.</p>"), smithy.api.Paginated(inputToken = Some(smithy.api.NonEmptyString("NextToken")), outputToken = Some(smithy.api.NonEmptyString("NextToken")), items = None, pageSize = Some(smithy.api.NonEmptyString("MaxResults"))))
    def wrap(input: ListTopicsDetectionJobsRequest): ListTopicsDetectionJobs = ListTopicsDetectionJobs(input)
  }
  sealed trait ListTopicsDetectionJobsError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: ListTopicsDetectionJobsError = this
    def $ordinal: Int

    object project {
      def invalidFilterException: Option[InvalidFilterException] = ListTopicsDetectionJobsError.InvalidFilterExceptionCase.alt.project.lift(self).map(_.invalidFilterException)
      def internalServerException: Option[InternalServerException] = ListTopicsDetectionJobsError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = ListTopicsDetectionJobsError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = ListTopicsDetectionJobsError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: ListTopicsDetectionJobsError.Visitor[A]): A = this match {
      case value: ListTopicsDetectionJobsError.InvalidFilterExceptionCase => visitor.invalidFilterException(value.invalidFilterException)
      case value: ListTopicsDetectionJobsError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: ListTopicsDetectionJobsError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: ListTopicsDetectionJobsError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object ListTopicsDetectionJobsError extends ErrorSchema.Companion[ListTopicsDetectionJobsError] {

    def invalidFilterException(invalidFilterException: InvalidFilterException): ListTopicsDetectionJobsError = InvalidFilterExceptionCase(invalidFilterException)
    def internalServerException(internalServerException: InternalServerException): ListTopicsDetectionJobsError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): ListTopicsDetectionJobsError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): ListTopicsDetectionJobsError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "ListTopicsDetectionJobsError")

    val hints: Hints = Hints.empty

    final case class InvalidFilterExceptionCase(invalidFilterException: InvalidFilterException) extends ListTopicsDetectionJobsError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends ListTopicsDetectionJobsError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends ListTopicsDetectionJobsError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends ListTopicsDetectionJobsError { final def $ordinal: Int = 3 }

    object InvalidFilterExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTopicsDetectionJobsError.InvalidFilterExceptionCase] = bijection(InvalidFilterException.schema.addHints(hints), ListTopicsDetectionJobsError.InvalidFilterExceptionCase(_), _.invalidFilterException)
      val alt = schema.oneOf[ListTopicsDetectionJobsError]("InvalidFilterException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTopicsDetectionJobsError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), ListTopicsDetectionJobsError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[ListTopicsDetectionJobsError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTopicsDetectionJobsError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), ListTopicsDetectionJobsError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[ListTopicsDetectionJobsError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[ListTopicsDetectionJobsError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), ListTopicsDetectionJobsError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[ListTopicsDetectionJobsError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def invalidFilterException(value: InvalidFilterException): A
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def invalidFilterException(value: InvalidFilterException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[ListTopicsDetectionJobsError] = union(
      ListTopicsDetectionJobsError.InvalidFilterExceptionCase.alt,
      ListTopicsDetectionJobsError.InternalServerExceptionCase.alt,
      ListTopicsDetectionJobsError.TooManyRequestsExceptionCase.alt,
      ListTopicsDetectionJobsError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[ListTopicsDetectionJobsError] = throwable match {
      case e: InvalidFilterException => Some(ListTopicsDetectionJobsError.InvalidFilterExceptionCase(e))
      case e: InternalServerException => Some(ListTopicsDetectionJobsError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(ListTopicsDetectionJobsError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(ListTopicsDetectionJobsError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: ListTopicsDetectionJobsError): Throwable = e match {
      case ListTopicsDetectionJobsError.InvalidFilterExceptionCase(e) => e
      case ListTopicsDetectionJobsError.InternalServerExceptionCase(e) => e
      case ListTopicsDetectionJobsError.TooManyRequestsExceptionCase(e) => e
      case ListTopicsDetectionJobsError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class PutResourcePolicy(input: PutResourcePolicyRequest) extends ComprehendOperation[PutResourcePolicyRequest, ComprehendOperation.PutResourcePolicyError, PutResourcePolicyResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[PutResourcePolicyRequest, ComprehendOperation.PutResourcePolicyError, PutResourcePolicyResponse, Nothing, Nothing] = impl.putResourcePolicy(input.resourceArn, input.resourcePolicy, input.policyRevisionId)
    def ordinal: Int = 60
    def endpoint: smithy4s.Endpoint[ComprehendOperation,PutResourcePolicyRequest, ComprehendOperation.PutResourcePolicyError, PutResourcePolicyResponse, Nothing, Nothing] = PutResourcePolicy
  }
  object PutResourcePolicy extends smithy4s.Endpoint[ComprehendOperation,PutResourcePolicyRequest, ComprehendOperation.PutResourcePolicyError, PutResourcePolicyResponse, Nothing, Nothing] {
    val schema: OperationSchema[PutResourcePolicyRequest, ComprehendOperation.PutResourcePolicyError, PutResourcePolicyResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "PutResourcePolicy"))
      .withInput(PutResourcePolicyRequest.schema)
      .withError(PutResourcePolicyError.errorSchema)
      .withOutput(PutResourcePolicyResponse.schema)
      .withHints(smithy.api.Documentation("<p>Attaches a resource-based policy to a custom model. You can use this policy to authorize\n      an entity in another Amazon Web Services account to import the custom model, which replicates it in Amazon\n      Comprehend in their account.</p>"))
    def wrap(input: PutResourcePolicyRequest): PutResourcePolicy = PutResourcePolicy(input)
  }
  sealed trait PutResourcePolicyError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: PutResourcePolicyError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = PutResourcePolicyError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = PutResourcePolicyError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = PutResourcePolicyError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: PutResourcePolicyError.Visitor[A]): A = this match {
      case value: PutResourcePolicyError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: PutResourcePolicyError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: PutResourcePolicyError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object PutResourcePolicyError extends ErrorSchema.Companion[PutResourcePolicyError] {

    def internalServerException(internalServerException: InternalServerException): PutResourcePolicyError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): PutResourcePolicyError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): PutResourcePolicyError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "PutResourcePolicyError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends PutResourcePolicyError { final def $ordinal: Int = 0 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends PutResourcePolicyError { final def $ordinal: Int = 1 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends PutResourcePolicyError { final def $ordinal: Int = 2 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[PutResourcePolicyError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), PutResourcePolicyError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[PutResourcePolicyError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[PutResourcePolicyError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), PutResourcePolicyError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[PutResourcePolicyError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[PutResourcePolicyError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), PutResourcePolicyError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[PutResourcePolicyError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[PutResourcePolicyError] = union(
      PutResourcePolicyError.InternalServerExceptionCase.alt,
      PutResourcePolicyError.InvalidRequestExceptionCase.alt,
      PutResourcePolicyError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[PutResourcePolicyError] = throwable match {
      case e: InternalServerException => Some(PutResourcePolicyError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(PutResourcePolicyError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(PutResourcePolicyError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: PutResourcePolicyError): Throwable = e match {
      case PutResourcePolicyError.InternalServerExceptionCase(e) => e
      case PutResourcePolicyError.InvalidRequestExceptionCase(e) => e
      case PutResourcePolicyError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class StartDocumentClassificationJob(input: StartDocumentClassificationJobRequest) extends ComprehendOperation[StartDocumentClassificationJobRequest, ComprehendOperation.StartDocumentClassificationJobError, StartDocumentClassificationJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartDocumentClassificationJobRequest, ComprehendOperation.StartDocumentClassificationJobError, StartDocumentClassificationJobResponse, Nothing, Nothing] = impl.startDocumentClassificationJob(input.inputDataConfig, input.outputDataConfig, input.dataAccessRoleArn, input.jobName, input.documentClassifierArn, input.clientRequestToken, input.volumeKmsKeyId, input.vpcConfig, input.tags, input.flywheelArn)
    def ordinal: Int = 61
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartDocumentClassificationJobRequest, ComprehendOperation.StartDocumentClassificationJobError, StartDocumentClassificationJobResponse, Nothing, Nothing] = StartDocumentClassificationJob
  }
  object StartDocumentClassificationJob extends smithy4s.Endpoint[ComprehendOperation,StartDocumentClassificationJobRequest, ComprehendOperation.StartDocumentClassificationJobError, StartDocumentClassificationJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartDocumentClassificationJobRequest, ComprehendOperation.StartDocumentClassificationJobError, StartDocumentClassificationJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartDocumentClassificationJob"))
      .withInput(StartDocumentClassificationJobRequest.schema)
      .withError(StartDocumentClassificationJobError.errorSchema)
      .withOutput(StartDocumentClassificationJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Starts an asynchronous document classification job. Use the\n      <code>DescribeDocumentClassificationJob</code>\n          operation to track the progress of the job.</p>"))
    def wrap(input: StartDocumentClassificationJobRequest): StartDocumentClassificationJob = StartDocumentClassificationJob(input)
  }
  sealed trait StartDocumentClassificationJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartDocumentClassificationJobError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartDocumentClassificationJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = StartDocumentClassificationJobError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = StartDocumentClassificationJobError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = StartDocumentClassificationJobError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = StartDocumentClassificationJobError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartDocumentClassificationJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartDocumentClassificationJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = StartDocumentClassificationJobError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: StartDocumentClassificationJobError.Visitor[A]): A = this match {
      case value: StartDocumentClassificationJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartDocumentClassificationJobError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: StartDocumentClassificationJobError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: StartDocumentClassificationJobError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: StartDocumentClassificationJobError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartDocumentClassificationJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartDocumentClassificationJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: StartDocumentClassificationJobError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object StartDocumentClassificationJobError extends ErrorSchema.Companion[StartDocumentClassificationJobError] {

    def internalServerException(internalServerException: InternalServerException): StartDocumentClassificationJobError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): StartDocumentClassificationJobError = TooManyTagsExceptionCase(tooManyTagsException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): StartDocumentClassificationJobError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): StartDocumentClassificationJobError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartDocumentClassificationJobError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartDocumentClassificationJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartDocumentClassificationJobError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): StartDocumentClassificationJobError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartDocumentClassificationJobError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartDocumentClassificationJobError { final def $ordinal: Int = 0 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends StartDocumentClassificationJobError { final def $ordinal: Int = 1 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends StartDocumentClassificationJobError { final def $ordinal: Int = 2 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends StartDocumentClassificationJobError { final def $ordinal: Int = 3 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartDocumentClassificationJobError { final def $ordinal: Int = 4 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartDocumentClassificationJobError { final def $ordinal: Int = 5 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartDocumentClassificationJobError { final def $ordinal: Int = 6 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends StartDocumentClassificationJobError { final def $ordinal: Int = 7 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDocumentClassificationJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartDocumentClassificationJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartDocumentClassificationJobError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDocumentClassificationJobError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), StartDocumentClassificationJobError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[StartDocumentClassificationJobError]("TooManyTagsException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDocumentClassificationJobError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), StartDocumentClassificationJobError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[StartDocumentClassificationJobError]("ResourceUnavailableException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDocumentClassificationJobError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), StartDocumentClassificationJobError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[StartDocumentClassificationJobError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDocumentClassificationJobError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartDocumentClassificationJobError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartDocumentClassificationJobError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDocumentClassificationJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartDocumentClassificationJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartDocumentClassificationJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDocumentClassificationJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartDocumentClassificationJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartDocumentClassificationJobError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDocumentClassificationJobError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), StartDocumentClassificationJobError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[StartDocumentClassificationJobError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[StartDocumentClassificationJobError] = union(
      StartDocumentClassificationJobError.InternalServerExceptionCase.alt,
      StartDocumentClassificationJobError.TooManyTagsExceptionCase.alt,
      StartDocumentClassificationJobError.ResourceUnavailableExceptionCase.alt,
      StartDocumentClassificationJobError.KmsKeyValidationExceptionCase.alt,
      StartDocumentClassificationJobError.ResourceInUseExceptionCase.alt,
      StartDocumentClassificationJobError.TooManyRequestsExceptionCase.alt,
      StartDocumentClassificationJobError.InvalidRequestExceptionCase.alt,
      StartDocumentClassificationJobError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartDocumentClassificationJobError] = throwable match {
      case e: InternalServerException => Some(StartDocumentClassificationJobError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(StartDocumentClassificationJobError.TooManyTagsExceptionCase(e))
      case e: ResourceUnavailableException => Some(StartDocumentClassificationJobError.ResourceUnavailableExceptionCase(e))
      case e: KmsKeyValidationException => Some(StartDocumentClassificationJobError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(StartDocumentClassificationJobError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartDocumentClassificationJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartDocumentClassificationJobError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(StartDocumentClassificationJobError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartDocumentClassificationJobError): Throwable = e match {
      case StartDocumentClassificationJobError.InternalServerExceptionCase(e) => e
      case StartDocumentClassificationJobError.TooManyTagsExceptionCase(e) => e
      case StartDocumentClassificationJobError.ResourceUnavailableExceptionCase(e) => e
      case StartDocumentClassificationJobError.KmsKeyValidationExceptionCase(e) => e
      case StartDocumentClassificationJobError.ResourceInUseExceptionCase(e) => e
      case StartDocumentClassificationJobError.TooManyRequestsExceptionCase(e) => e
      case StartDocumentClassificationJobError.InvalidRequestExceptionCase(e) => e
      case StartDocumentClassificationJobError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class StartDominantLanguageDetectionJob(input: StartDominantLanguageDetectionJobRequest) extends ComprehendOperation[StartDominantLanguageDetectionJobRequest, ComprehendOperation.StartDominantLanguageDetectionJobError, StartDominantLanguageDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartDominantLanguageDetectionJobRequest, ComprehendOperation.StartDominantLanguageDetectionJobError, StartDominantLanguageDetectionJobResponse, Nothing, Nothing] = impl.startDominantLanguageDetectionJob(input.inputDataConfig, input.outputDataConfig, input.dataAccessRoleArn, input.jobName, input.clientRequestToken, input.volumeKmsKeyId, input.vpcConfig, input.tags)
    def ordinal: Int = 62
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartDominantLanguageDetectionJobRequest, ComprehendOperation.StartDominantLanguageDetectionJobError, StartDominantLanguageDetectionJobResponse, Nothing, Nothing] = StartDominantLanguageDetectionJob
  }
  object StartDominantLanguageDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StartDominantLanguageDetectionJobRequest, ComprehendOperation.StartDominantLanguageDetectionJobError, StartDominantLanguageDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartDominantLanguageDetectionJobRequest, ComprehendOperation.StartDominantLanguageDetectionJobError, StartDominantLanguageDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartDominantLanguageDetectionJob"))
      .withInput(StartDominantLanguageDetectionJobRequest.schema)
      .withError(StartDominantLanguageDetectionJobError.errorSchema)
      .withOutput(StartDominantLanguageDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Starts an asynchronous dominant language detection job for a collection of documents. Use\n      the  operation to track the status\n      of a job.</p>"))
    def wrap(input: StartDominantLanguageDetectionJobRequest): StartDominantLanguageDetectionJob = StartDominantLanguageDetectionJob(input)
  }
  sealed trait StartDominantLanguageDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartDominantLanguageDetectionJobError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartDominantLanguageDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = StartDominantLanguageDetectionJobError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = StartDominantLanguageDetectionJobError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = StartDominantLanguageDetectionJobError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartDominantLanguageDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartDominantLanguageDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StartDominantLanguageDetectionJobError.Visitor[A]): A = this match {
      case value: StartDominantLanguageDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartDominantLanguageDetectionJobError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: StartDominantLanguageDetectionJobError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: StartDominantLanguageDetectionJobError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartDominantLanguageDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartDominantLanguageDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StartDominantLanguageDetectionJobError extends ErrorSchema.Companion[StartDominantLanguageDetectionJobError] {

    def internalServerException(internalServerException: InternalServerException): StartDominantLanguageDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): StartDominantLanguageDetectionJobError = TooManyTagsExceptionCase(tooManyTagsException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): StartDominantLanguageDetectionJobError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartDominantLanguageDetectionJobError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartDominantLanguageDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartDominantLanguageDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartDominantLanguageDetectionJobError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartDominantLanguageDetectionJobError { final def $ordinal: Int = 0 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends StartDominantLanguageDetectionJobError { final def $ordinal: Int = 1 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends StartDominantLanguageDetectionJobError { final def $ordinal: Int = 2 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartDominantLanguageDetectionJobError { final def $ordinal: Int = 3 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartDominantLanguageDetectionJobError { final def $ordinal: Int = 4 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartDominantLanguageDetectionJobError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDominantLanguageDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartDominantLanguageDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartDominantLanguageDetectionJobError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDominantLanguageDetectionJobError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), StartDominantLanguageDetectionJobError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[StartDominantLanguageDetectionJobError]("TooManyTagsException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDominantLanguageDetectionJobError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), StartDominantLanguageDetectionJobError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[StartDominantLanguageDetectionJobError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDominantLanguageDetectionJobError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartDominantLanguageDetectionJobError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartDominantLanguageDetectionJobError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDominantLanguageDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartDominantLanguageDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartDominantLanguageDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartDominantLanguageDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartDominantLanguageDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartDominantLanguageDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StartDominantLanguageDetectionJobError] = union(
      StartDominantLanguageDetectionJobError.InternalServerExceptionCase.alt,
      StartDominantLanguageDetectionJobError.TooManyTagsExceptionCase.alt,
      StartDominantLanguageDetectionJobError.KmsKeyValidationExceptionCase.alt,
      StartDominantLanguageDetectionJobError.ResourceInUseExceptionCase.alt,
      StartDominantLanguageDetectionJobError.TooManyRequestsExceptionCase.alt,
      StartDominantLanguageDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartDominantLanguageDetectionJobError] = throwable match {
      case e: InternalServerException => Some(StartDominantLanguageDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(StartDominantLanguageDetectionJobError.TooManyTagsExceptionCase(e))
      case e: KmsKeyValidationException => Some(StartDominantLanguageDetectionJobError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(StartDominantLanguageDetectionJobError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartDominantLanguageDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartDominantLanguageDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartDominantLanguageDetectionJobError): Throwable = e match {
      case StartDominantLanguageDetectionJobError.InternalServerExceptionCase(e) => e
      case StartDominantLanguageDetectionJobError.TooManyTagsExceptionCase(e) => e
      case StartDominantLanguageDetectionJobError.KmsKeyValidationExceptionCase(e) => e
      case StartDominantLanguageDetectionJobError.ResourceInUseExceptionCase(e) => e
      case StartDominantLanguageDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case StartDominantLanguageDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StartEntitiesDetectionJob(input: StartEntitiesDetectionJobRequest) extends ComprehendOperation[StartEntitiesDetectionJobRequest, ComprehendOperation.StartEntitiesDetectionJobError, StartEntitiesDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartEntitiesDetectionJobRequest, ComprehendOperation.StartEntitiesDetectionJobError, StartEntitiesDetectionJobResponse, Nothing, Nothing] = impl.startEntitiesDetectionJob(input.inputDataConfig, input.outputDataConfig, input.dataAccessRoleArn, input.languageCode, input.jobName, input.entityRecognizerArn, input.clientRequestToken, input.volumeKmsKeyId, input.vpcConfig, input.tags, input.flywheelArn)
    def ordinal: Int = 63
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartEntitiesDetectionJobRequest, ComprehendOperation.StartEntitiesDetectionJobError, StartEntitiesDetectionJobResponse, Nothing, Nothing] = StartEntitiesDetectionJob
  }
  object StartEntitiesDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StartEntitiesDetectionJobRequest, ComprehendOperation.StartEntitiesDetectionJobError, StartEntitiesDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartEntitiesDetectionJobRequest, ComprehendOperation.StartEntitiesDetectionJobError, StartEntitiesDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartEntitiesDetectionJob"))
      .withInput(StartEntitiesDetectionJobRequest.schema)
      .withError(StartEntitiesDetectionJobError.errorSchema)
      .withOutput(StartEntitiesDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Starts an asynchronous entity detection job for a collection of documents. Use the  operation to track the status of a job.</p>\n         <p>This API can be used for either standard entity detection or custom entity recognition. In\n      order to be used for custom entity recognition, the optional <code>EntityRecognizerArn</code>\n      must be used in order to provide access to the recognizer being used to detect the custom\n      entity.</p>"))
    def wrap(input: StartEntitiesDetectionJobRequest): StartEntitiesDetectionJob = StartEntitiesDetectionJob(input)
  }
  sealed trait StartEntitiesDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartEntitiesDetectionJobError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartEntitiesDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = StartEntitiesDetectionJobError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = StartEntitiesDetectionJobError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = StartEntitiesDetectionJobError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = StartEntitiesDetectionJobError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartEntitiesDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartEntitiesDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = StartEntitiesDetectionJobError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: StartEntitiesDetectionJobError.Visitor[A]): A = this match {
      case value: StartEntitiesDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartEntitiesDetectionJobError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: StartEntitiesDetectionJobError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: StartEntitiesDetectionJobError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: StartEntitiesDetectionJobError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartEntitiesDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartEntitiesDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: StartEntitiesDetectionJobError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object StartEntitiesDetectionJobError extends ErrorSchema.Companion[StartEntitiesDetectionJobError] {

    def internalServerException(internalServerException: InternalServerException): StartEntitiesDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): StartEntitiesDetectionJobError = TooManyTagsExceptionCase(tooManyTagsException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): StartEntitiesDetectionJobError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): StartEntitiesDetectionJobError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartEntitiesDetectionJobError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartEntitiesDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartEntitiesDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): StartEntitiesDetectionJobError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartEntitiesDetectionJobError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartEntitiesDetectionJobError { final def $ordinal: Int = 0 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends StartEntitiesDetectionJobError { final def $ordinal: Int = 1 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends StartEntitiesDetectionJobError { final def $ordinal: Int = 2 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends StartEntitiesDetectionJobError { final def $ordinal: Int = 3 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartEntitiesDetectionJobError { final def $ordinal: Int = 4 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartEntitiesDetectionJobError { final def $ordinal: Int = 5 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartEntitiesDetectionJobError { final def $ordinal: Int = 6 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends StartEntitiesDetectionJobError { final def $ordinal: Int = 7 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEntitiesDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartEntitiesDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartEntitiesDetectionJobError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEntitiesDetectionJobError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), StartEntitiesDetectionJobError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[StartEntitiesDetectionJobError]("TooManyTagsException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEntitiesDetectionJobError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), StartEntitiesDetectionJobError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[StartEntitiesDetectionJobError]("ResourceUnavailableException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEntitiesDetectionJobError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), StartEntitiesDetectionJobError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[StartEntitiesDetectionJobError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEntitiesDetectionJobError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartEntitiesDetectionJobError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartEntitiesDetectionJobError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEntitiesDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartEntitiesDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartEntitiesDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEntitiesDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartEntitiesDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartEntitiesDetectionJobError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEntitiesDetectionJobError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), StartEntitiesDetectionJobError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[StartEntitiesDetectionJobError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[StartEntitiesDetectionJobError] = union(
      StartEntitiesDetectionJobError.InternalServerExceptionCase.alt,
      StartEntitiesDetectionJobError.TooManyTagsExceptionCase.alt,
      StartEntitiesDetectionJobError.ResourceUnavailableExceptionCase.alt,
      StartEntitiesDetectionJobError.KmsKeyValidationExceptionCase.alt,
      StartEntitiesDetectionJobError.ResourceInUseExceptionCase.alt,
      StartEntitiesDetectionJobError.TooManyRequestsExceptionCase.alt,
      StartEntitiesDetectionJobError.InvalidRequestExceptionCase.alt,
      StartEntitiesDetectionJobError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartEntitiesDetectionJobError] = throwable match {
      case e: InternalServerException => Some(StartEntitiesDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(StartEntitiesDetectionJobError.TooManyTagsExceptionCase(e))
      case e: ResourceUnavailableException => Some(StartEntitiesDetectionJobError.ResourceUnavailableExceptionCase(e))
      case e: KmsKeyValidationException => Some(StartEntitiesDetectionJobError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(StartEntitiesDetectionJobError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartEntitiesDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartEntitiesDetectionJobError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(StartEntitiesDetectionJobError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartEntitiesDetectionJobError): Throwable = e match {
      case StartEntitiesDetectionJobError.InternalServerExceptionCase(e) => e
      case StartEntitiesDetectionJobError.TooManyTagsExceptionCase(e) => e
      case StartEntitiesDetectionJobError.ResourceUnavailableExceptionCase(e) => e
      case StartEntitiesDetectionJobError.KmsKeyValidationExceptionCase(e) => e
      case StartEntitiesDetectionJobError.ResourceInUseExceptionCase(e) => e
      case StartEntitiesDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case StartEntitiesDetectionJobError.InvalidRequestExceptionCase(e) => e
      case StartEntitiesDetectionJobError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class StartEventsDetectionJob(input: StartEventsDetectionJobRequest) extends ComprehendOperation[StartEventsDetectionJobRequest, ComprehendOperation.StartEventsDetectionJobError, StartEventsDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartEventsDetectionJobRequest, ComprehendOperation.StartEventsDetectionJobError, StartEventsDetectionJobResponse, Nothing, Nothing] = impl.startEventsDetectionJob(input.inputDataConfig, input.outputDataConfig, input.dataAccessRoleArn, input.languageCode, input.targetEventTypes, input.jobName, input.clientRequestToken, input.tags)
    def ordinal: Int = 64
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartEventsDetectionJobRequest, ComprehendOperation.StartEventsDetectionJobError, StartEventsDetectionJobResponse, Nothing, Nothing] = StartEventsDetectionJob
  }
  object StartEventsDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StartEventsDetectionJobRequest, ComprehendOperation.StartEventsDetectionJobError, StartEventsDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartEventsDetectionJobRequest, ComprehendOperation.StartEventsDetectionJobError, StartEventsDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartEventsDetectionJob"))
      .withInput(StartEventsDetectionJobRequest.schema)
      .withError(StartEventsDetectionJobError.errorSchema)
      .withOutput(StartEventsDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Starts an asynchronous event detection job for a collection of documents.</p>"))
    def wrap(input: StartEventsDetectionJobRequest): StartEventsDetectionJob = StartEventsDetectionJob(input)
  }
  sealed trait StartEventsDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartEventsDetectionJobError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartEventsDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = StartEventsDetectionJobError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = StartEventsDetectionJobError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = StartEventsDetectionJobError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartEventsDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartEventsDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StartEventsDetectionJobError.Visitor[A]): A = this match {
      case value: StartEventsDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartEventsDetectionJobError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: StartEventsDetectionJobError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: StartEventsDetectionJobError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartEventsDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartEventsDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StartEventsDetectionJobError extends ErrorSchema.Companion[StartEventsDetectionJobError] {

    def internalServerException(internalServerException: InternalServerException): StartEventsDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): StartEventsDetectionJobError = TooManyTagsExceptionCase(tooManyTagsException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): StartEventsDetectionJobError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartEventsDetectionJobError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartEventsDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartEventsDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartEventsDetectionJobError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartEventsDetectionJobError { final def $ordinal: Int = 0 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends StartEventsDetectionJobError { final def $ordinal: Int = 1 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends StartEventsDetectionJobError { final def $ordinal: Int = 2 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartEventsDetectionJobError { final def $ordinal: Int = 3 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartEventsDetectionJobError { final def $ordinal: Int = 4 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartEventsDetectionJobError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEventsDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartEventsDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartEventsDetectionJobError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEventsDetectionJobError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), StartEventsDetectionJobError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[StartEventsDetectionJobError]("TooManyTagsException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEventsDetectionJobError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), StartEventsDetectionJobError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[StartEventsDetectionJobError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEventsDetectionJobError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartEventsDetectionJobError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartEventsDetectionJobError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEventsDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartEventsDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartEventsDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartEventsDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartEventsDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartEventsDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StartEventsDetectionJobError] = union(
      StartEventsDetectionJobError.InternalServerExceptionCase.alt,
      StartEventsDetectionJobError.TooManyTagsExceptionCase.alt,
      StartEventsDetectionJobError.KmsKeyValidationExceptionCase.alt,
      StartEventsDetectionJobError.ResourceInUseExceptionCase.alt,
      StartEventsDetectionJobError.TooManyRequestsExceptionCase.alt,
      StartEventsDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartEventsDetectionJobError] = throwable match {
      case e: InternalServerException => Some(StartEventsDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(StartEventsDetectionJobError.TooManyTagsExceptionCase(e))
      case e: KmsKeyValidationException => Some(StartEventsDetectionJobError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(StartEventsDetectionJobError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartEventsDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartEventsDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartEventsDetectionJobError): Throwable = e match {
      case StartEventsDetectionJobError.InternalServerExceptionCase(e) => e
      case StartEventsDetectionJobError.TooManyTagsExceptionCase(e) => e
      case StartEventsDetectionJobError.KmsKeyValidationExceptionCase(e) => e
      case StartEventsDetectionJobError.ResourceInUseExceptionCase(e) => e
      case StartEventsDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case StartEventsDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StartFlywheelIteration(input: StartFlywheelIterationRequest) extends ComprehendOperation[StartFlywheelIterationRequest, ComprehendOperation.StartFlywheelIterationError, StartFlywheelIterationResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartFlywheelIterationRequest, ComprehendOperation.StartFlywheelIterationError, StartFlywheelIterationResponse, Nothing, Nothing] = impl.startFlywheelIteration(input.flywheelArn, input.clientRequestToken)
    def ordinal: Int = 65
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartFlywheelIterationRequest, ComprehendOperation.StartFlywheelIterationError, StartFlywheelIterationResponse, Nothing, Nothing] = StartFlywheelIteration
  }
  object StartFlywheelIteration extends smithy4s.Endpoint[ComprehendOperation,StartFlywheelIterationRequest, ComprehendOperation.StartFlywheelIterationError, StartFlywheelIterationResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartFlywheelIterationRequest, ComprehendOperation.StartFlywheelIterationError, StartFlywheelIterationResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartFlywheelIteration"))
      .withInput(StartFlywheelIterationRequest.schema)
      .withError(StartFlywheelIterationError.errorSchema)
      .withOutput(StartFlywheelIterationResponse.schema)
      .withHints(smithy.api.Documentation("<p>Start the flywheel iteration.This operation uses any new datasets to train a new model version.\n      For more information about flywheels, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/flywheels-about.html\">\n      Flywheel overview</a> in the <i>Amazon Comprehend Developer Guide</i>.</p>"))
    def wrap(input: StartFlywheelIterationRequest): StartFlywheelIteration = StartFlywheelIteration(input)
  }
  sealed trait StartFlywheelIterationError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartFlywheelIterationError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartFlywheelIterationError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def resourceInUseException: Option[ResourceInUseException] = StartFlywheelIterationError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartFlywheelIterationError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartFlywheelIterationError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = StartFlywheelIterationError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: StartFlywheelIterationError.Visitor[A]): A = this match {
      case value: StartFlywheelIterationError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartFlywheelIterationError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartFlywheelIterationError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartFlywheelIterationError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: StartFlywheelIterationError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object StartFlywheelIterationError extends ErrorSchema.Companion[StartFlywheelIterationError] {

    def internalServerException(internalServerException: InternalServerException): StartFlywheelIterationError = InternalServerExceptionCase(internalServerException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartFlywheelIterationError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartFlywheelIterationError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartFlywheelIterationError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): StartFlywheelIterationError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartFlywheelIterationError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartFlywheelIterationError { final def $ordinal: Int = 0 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartFlywheelIterationError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartFlywheelIterationError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartFlywheelIterationError { final def $ordinal: Int = 3 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends StartFlywheelIterationError { final def $ordinal: Int = 4 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartFlywheelIterationError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartFlywheelIterationError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartFlywheelIterationError]("InternalServerException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartFlywheelIterationError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartFlywheelIterationError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartFlywheelIterationError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartFlywheelIterationError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartFlywheelIterationError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartFlywheelIterationError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartFlywheelIterationError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartFlywheelIterationError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartFlywheelIterationError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartFlywheelIterationError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), StartFlywheelIterationError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[StartFlywheelIterationError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[StartFlywheelIterationError] = union(
      StartFlywheelIterationError.InternalServerExceptionCase.alt,
      StartFlywheelIterationError.ResourceInUseExceptionCase.alt,
      StartFlywheelIterationError.TooManyRequestsExceptionCase.alt,
      StartFlywheelIterationError.InvalidRequestExceptionCase.alt,
      StartFlywheelIterationError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartFlywheelIterationError] = throwable match {
      case e: InternalServerException => Some(StartFlywheelIterationError.InternalServerExceptionCase(e))
      case e: ResourceInUseException => Some(StartFlywheelIterationError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartFlywheelIterationError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartFlywheelIterationError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(StartFlywheelIterationError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartFlywheelIterationError): Throwable = e match {
      case StartFlywheelIterationError.InternalServerExceptionCase(e) => e
      case StartFlywheelIterationError.ResourceInUseExceptionCase(e) => e
      case StartFlywheelIterationError.TooManyRequestsExceptionCase(e) => e
      case StartFlywheelIterationError.InvalidRequestExceptionCase(e) => e
      case StartFlywheelIterationError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class StartKeyPhrasesDetectionJob(input: StartKeyPhrasesDetectionJobRequest) extends ComprehendOperation[StartKeyPhrasesDetectionJobRequest, ComprehendOperation.StartKeyPhrasesDetectionJobError, StartKeyPhrasesDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartKeyPhrasesDetectionJobRequest, ComprehendOperation.StartKeyPhrasesDetectionJobError, StartKeyPhrasesDetectionJobResponse, Nothing, Nothing] = impl.startKeyPhrasesDetectionJob(input.inputDataConfig, input.outputDataConfig, input.dataAccessRoleArn, input.languageCode, input.jobName, input.clientRequestToken, input.volumeKmsKeyId, input.vpcConfig, input.tags)
    def ordinal: Int = 66
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartKeyPhrasesDetectionJobRequest, ComprehendOperation.StartKeyPhrasesDetectionJobError, StartKeyPhrasesDetectionJobResponse, Nothing, Nothing] = StartKeyPhrasesDetectionJob
  }
  object StartKeyPhrasesDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StartKeyPhrasesDetectionJobRequest, ComprehendOperation.StartKeyPhrasesDetectionJobError, StartKeyPhrasesDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartKeyPhrasesDetectionJobRequest, ComprehendOperation.StartKeyPhrasesDetectionJobError, StartKeyPhrasesDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartKeyPhrasesDetectionJob"))
      .withInput(StartKeyPhrasesDetectionJobRequest.schema)
      .withError(StartKeyPhrasesDetectionJobError.errorSchema)
      .withOutput(StartKeyPhrasesDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Starts an asynchronous key phrase detection job for a collection of documents. Use the\n         operation to track the status of a\n      job.</p>"))
    def wrap(input: StartKeyPhrasesDetectionJobRequest): StartKeyPhrasesDetectionJob = StartKeyPhrasesDetectionJob(input)
  }
  sealed trait StartKeyPhrasesDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartKeyPhrasesDetectionJobError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartKeyPhrasesDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = StartKeyPhrasesDetectionJobError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = StartKeyPhrasesDetectionJobError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = StartKeyPhrasesDetectionJobError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartKeyPhrasesDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StartKeyPhrasesDetectionJobError.Visitor[A]): A = this match {
      case value: StartKeyPhrasesDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartKeyPhrasesDetectionJobError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: StartKeyPhrasesDetectionJobError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: StartKeyPhrasesDetectionJobError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartKeyPhrasesDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StartKeyPhrasesDetectionJobError extends ErrorSchema.Companion[StartKeyPhrasesDetectionJobError] {

    def internalServerException(internalServerException: InternalServerException): StartKeyPhrasesDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): StartKeyPhrasesDetectionJobError = TooManyTagsExceptionCase(tooManyTagsException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): StartKeyPhrasesDetectionJobError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartKeyPhrasesDetectionJobError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartKeyPhrasesDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartKeyPhrasesDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartKeyPhrasesDetectionJobError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartKeyPhrasesDetectionJobError { final def $ordinal: Int = 0 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends StartKeyPhrasesDetectionJobError { final def $ordinal: Int = 1 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends StartKeyPhrasesDetectionJobError { final def $ordinal: Int = 2 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartKeyPhrasesDetectionJobError { final def $ordinal: Int = 3 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartKeyPhrasesDetectionJobError { final def $ordinal: Int = 4 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartKeyPhrasesDetectionJobError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartKeyPhrasesDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartKeyPhrasesDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartKeyPhrasesDetectionJobError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartKeyPhrasesDetectionJobError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), StartKeyPhrasesDetectionJobError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[StartKeyPhrasesDetectionJobError]("TooManyTagsException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartKeyPhrasesDetectionJobError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), StartKeyPhrasesDetectionJobError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[StartKeyPhrasesDetectionJobError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartKeyPhrasesDetectionJobError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartKeyPhrasesDetectionJobError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartKeyPhrasesDetectionJobError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartKeyPhrasesDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartKeyPhrasesDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartKeyPhrasesDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartKeyPhrasesDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StartKeyPhrasesDetectionJobError] = union(
      StartKeyPhrasesDetectionJobError.InternalServerExceptionCase.alt,
      StartKeyPhrasesDetectionJobError.TooManyTagsExceptionCase.alt,
      StartKeyPhrasesDetectionJobError.KmsKeyValidationExceptionCase.alt,
      StartKeyPhrasesDetectionJobError.ResourceInUseExceptionCase.alt,
      StartKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase.alt,
      StartKeyPhrasesDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartKeyPhrasesDetectionJobError] = throwable match {
      case e: InternalServerException => Some(StartKeyPhrasesDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(StartKeyPhrasesDetectionJobError.TooManyTagsExceptionCase(e))
      case e: KmsKeyValidationException => Some(StartKeyPhrasesDetectionJobError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(StartKeyPhrasesDetectionJobError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartKeyPhrasesDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartKeyPhrasesDetectionJobError): Throwable = e match {
      case StartKeyPhrasesDetectionJobError.InternalServerExceptionCase(e) => e
      case StartKeyPhrasesDetectionJobError.TooManyTagsExceptionCase(e) => e
      case StartKeyPhrasesDetectionJobError.KmsKeyValidationExceptionCase(e) => e
      case StartKeyPhrasesDetectionJobError.ResourceInUseExceptionCase(e) => e
      case StartKeyPhrasesDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case StartKeyPhrasesDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StartPiiEntitiesDetectionJob(input: StartPiiEntitiesDetectionJobRequest) extends ComprehendOperation[StartPiiEntitiesDetectionJobRequest, ComprehendOperation.StartPiiEntitiesDetectionJobError, StartPiiEntitiesDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartPiiEntitiesDetectionJobRequest, ComprehendOperation.StartPiiEntitiesDetectionJobError, StartPiiEntitiesDetectionJobResponse, Nothing, Nothing] = impl.startPiiEntitiesDetectionJob(input.inputDataConfig, input.outputDataConfig, input.mode, input.dataAccessRoleArn, input.languageCode, input.redactionConfig, input.jobName, input.clientRequestToken, input.tags)
    def ordinal: Int = 67
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartPiiEntitiesDetectionJobRequest, ComprehendOperation.StartPiiEntitiesDetectionJobError, StartPiiEntitiesDetectionJobResponse, Nothing, Nothing] = StartPiiEntitiesDetectionJob
  }
  object StartPiiEntitiesDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StartPiiEntitiesDetectionJobRequest, ComprehendOperation.StartPiiEntitiesDetectionJobError, StartPiiEntitiesDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartPiiEntitiesDetectionJobRequest, ComprehendOperation.StartPiiEntitiesDetectionJobError, StartPiiEntitiesDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartPiiEntitiesDetectionJob"))
      .withInput(StartPiiEntitiesDetectionJobRequest.schema)
      .withError(StartPiiEntitiesDetectionJobError.errorSchema)
      .withOutput(StartPiiEntitiesDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Starts an asynchronous PII entity detection job for a collection of documents.</p>"))
    def wrap(input: StartPiiEntitiesDetectionJobRequest): StartPiiEntitiesDetectionJob = StartPiiEntitiesDetectionJob(input)
  }
  sealed trait StartPiiEntitiesDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartPiiEntitiesDetectionJobError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartPiiEntitiesDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = StartPiiEntitiesDetectionJobError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = StartPiiEntitiesDetectionJobError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = StartPiiEntitiesDetectionJobError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartPiiEntitiesDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartPiiEntitiesDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StartPiiEntitiesDetectionJobError.Visitor[A]): A = this match {
      case value: StartPiiEntitiesDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartPiiEntitiesDetectionJobError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: StartPiiEntitiesDetectionJobError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: StartPiiEntitiesDetectionJobError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartPiiEntitiesDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartPiiEntitiesDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StartPiiEntitiesDetectionJobError extends ErrorSchema.Companion[StartPiiEntitiesDetectionJobError] {

    def internalServerException(internalServerException: InternalServerException): StartPiiEntitiesDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): StartPiiEntitiesDetectionJobError = TooManyTagsExceptionCase(tooManyTagsException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): StartPiiEntitiesDetectionJobError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartPiiEntitiesDetectionJobError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartPiiEntitiesDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartPiiEntitiesDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartPiiEntitiesDetectionJobError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartPiiEntitiesDetectionJobError { final def $ordinal: Int = 0 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends StartPiiEntitiesDetectionJobError { final def $ordinal: Int = 1 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends StartPiiEntitiesDetectionJobError { final def $ordinal: Int = 2 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartPiiEntitiesDetectionJobError { final def $ordinal: Int = 3 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartPiiEntitiesDetectionJobError { final def $ordinal: Int = 4 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartPiiEntitiesDetectionJobError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartPiiEntitiesDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartPiiEntitiesDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartPiiEntitiesDetectionJobError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartPiiEntitiesDetectionJobError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), StartPiiEntitiesDetectionJobError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[StartPiiEntitiesDetectionJobError]("TooManyTagsException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartPiiEntitiesDetectionJobError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), StartPiiEntitiesDetectionJobError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[StartPiiEntitiesDetectionJobError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartPiiEntitiesDetectionJobError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartPiiEntitiesDetectionJobError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartPiiEntitiesDetectionJobError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartPiiEntitiesDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartPiiEntitiesDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartPiiEntitiesDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartPiiEntitiesDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartPiiEntitiesDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartPiiEntitiesDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StartPiiEntitiesDetectionJobError] = union(
      StartPiiEntitiesDetectionJobError.InternalServerExceptionCase.alt,
      StartPiiEntitiesDetectionJobError.TooManyTagsExceptionCase.alt,
      StartPiiEntitiesDetectionJobError.KmsKeyValidationExceptionCase.alt,
      StartPiiEntitiesDetectionJobError.ResourceInUseExceptionCase.alt,
      StartPiiEntitiesDetectionJobError.TooManyRequestsExceptionCase.alt,
      StartPiiEntitiesDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartPiiEntitiesDetectionJobError] = throwable match {
      case e: InternalServerException => Some(StartPiiEntitiesDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(StartPiiEntitiesDetectionJobError.TooManyTagsExceptionCase(e))
      case e: KmsKeyValidationException => Some(StartPiiEntitiesDetectionJobError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(StartPiiEntitiesDetectionJobError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartPiiEntitiesDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartPiiEntitiesDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartPiiEntitiesDetectionJobError): Throwable = e match {
      case StartPiiEntitiesDetectionJobError.InternalServerExceptionCase(e) => e
      case StartPiiEntitiesDetectionJobError.TooManyTagsExceptionCase(e) => e
      case StartPiiEntitiesDetectionJobError.KmsKeyValidationExceptionCase(e) => e
      case StartPiiEntitiesDetectionJobError.ResourceInUseExceptionCase(e) => e
      case StartPiiEntitiesDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case StartPiiEntitiesDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StartSentimentDetectionJob(input: StartSentimentDetectionJobRequest) extends ComprehendOperation[StartSentimentDetectionJobRequest, ComprehendOperation.StartSentimentDetectionJobError, StartSentimentDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartSentimentDetectionJobRequest, ComprehendOperation.StartSentimentDetectionJobError, StartSentimentDetectionJobResponse, Nothing, Nothing] = impl.startSentimentDetectionJob(input.inputDataConfig, input.outputDataConfig, input.dataAccessRoleArn, input.languageCode, input.jobName, input.clientRequestToken, input.volumeKmsKeyId, input.vpcConfig, input.tags)
    def ordinal: Int = 68
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartSentimentDetectionJobRequest, ComprehendOperation.StartSentimentDetectionJobError, StartSentimentDetectionJobResponse, Nothing, Nothing] = StartSentimentDetectionJob
  }
  object StartSentimentDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StartSentimentDetectionJobRequest, ComprehendOperation.StartSentimentDetectionJobError, StartSentimentDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartSentimentDetectionJobRequest, ComprehendOperation.StartSentimentDetectionJobError, StartSentimentDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartSentimentDetectionJob"))
      .withInput(StartSentimentDetectionJobRequest.schema)
      .withError(StartSentimentDetectionJobError.errorSchema)
      .withOutput(StartSentimentDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Starts an asynchronous sentiment detection job for a collection of documents. Use the\n         operation to track the status of a\n      job.</p>"))
    def wrap(input: StartSentimentDetectionJobRequest): StartSentimentDetectionJob = StartSentimentDetectionJob(input)
  }
  sealed trait StartSentimentDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartSentimentDetectionJobError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartSentimentDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = StartSentimentDetectionJobError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = StartSentimentDetectionJobError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = StartSentimentDetectionJobError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartSentimentDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartSentimentDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StartSentimentDetectionJobError.Visitor[A]): A = this match {
      case value: StartSentimentDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartSentimentDetectionJobError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: StartSentimentDetectionJobError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: StartSentimentDetectionJobError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartSentimentDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartSentimentDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StartSentimentDetectionJobError extends ErrorSchema.Companion[StartSentimentDetectionJobError] {

    def internalServerException(internalServerException: InternalServerException): StartSentimentDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): StartSentimentDetectionJobError = TooManyTagsExceptionCase(tooManyTagsException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): StartSentimentDetectionJobError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartSentimentDetectionJobError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartSentimentDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartSentimentDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartSentimentDetectionJobError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartSentimentDetectionJobError { final def $ordinal: Int = 0 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends StartSentimentDetectionJobError { final def $ordinal: Int = 1 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends StartSentimentDetectionJobError { final def $ordinal: Int = 2 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartSentimentDetectionJobError { final def $ordinal: Int = 3 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartSentimentDetectionJobError { final def $ordinal: Int = 4 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartSentimentDetectionJobError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartSentimentDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartSentimentDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartSentimentDetectionJobError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartSentimentDetectionJobError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), StartSentimentDetectionJobError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[StartSentimentDetectionJobError]("TooManyTagsException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartSentimentDetectionJobError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), StartSentimentDetectionJobError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[StartSentimentDetectionJobError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartSentimentDetectionJobError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartSentimentDetectionJobError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartSentimentDetectionJobError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartSentimentDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartSentimentDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartSentimentDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartSentimentDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartSentimentDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartSentimentDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StartSentimentDetectionJobError] = union(
      StartSentimentDetectionJobError.InternalServerExceptionCase.alt,
      StartSentimentDetectionJobError.TooManyTagsExceptionCase.alt,
      StartSentimentDetectionJobError.KmsKeyValidationExceptionCase.alt,
      StartSentimentDetectionJobError.ResourceInUseExceptionCase.alt,
      StartSentimentDetectionJobError.TooManyRequestsExceptionCase.alt,
      StartSentimentDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartSentimentDetectionJobError] = throwable match {
      case e: InternalServerException => Some(StartSentimentDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(StartSentimentDetectionJobError.TooManyTagsExceptionCase(e))
      case e: KmsKeyValidationException => Some(StartSentimentDetectionJobError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(StartSentimentDetectionJobError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartSentimentDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartSentimentDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartSentimentDetectionJobError): Throwable = e match {
      case StartSentimentDetectionJobError.InternalServerExceptionCase(e) => e
      case StartSentimentDetectionJobError.TooManyTagsExceptionCase(e) => e
      case StartSentimentDetectionJobError.KmsKeyValidationExceptionCase(e) => e
      case StartSentimentDetectionJobError.ResourceInUseExceptionCase(e) => e
      case StartSentimentDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case StartSentimentDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StartTargetedSentimentDetectionJob(input: StartTargetedSentimentDetectionJobRequest) extends ComprehendOperation[StartTargetedSentimentDetectionJobRequest, ComprehendOperation.StartTargetedSentimentDetectionJobError, StartTargetedSentimentDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartTargetedSentimentDetectionJobRequest, ComprehendOperation.StartTargetedSentimentDetectionJobError, StartTargetedSentimentDetectionJobResponse, Nothing, Nothing] = impl.startTargetedSentimentDetectionJob(input.inputDataConfig, input.outputDataConfig, input.dataAccessRoleArn, input.languageCode, input.jobName, input.clientRequestToken, input.volumeKmsKeyId, input.vpcConfig, input.tags)
    def ordinal: Int = 69
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartTargetedSentimentDetectionJobRequest, ComprehendOperation.StartTargetedSentimentDetectionJobError, StartTargetedSentimentDetectionJobResponse, Nothing, Nothing] = StartTargetedSentimentDetectionJob
  }
  object StartTargetedSentimentDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StartTargetedSentimentDetectionJobRequest, ComprehendOperation.StartTargetedSentimentDetectionJobError, StartTargetedSentimentDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartTargetedSentimentDetectionJobRequest, ComprehendOperation.StartTargetedSentimentDetectionJobError, StartTargetedSentimentDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartTargetedSentimentDetectionJob"))
      .withInput(StartTargetedSentimentDetectionJobRequest.schema)
      .withError(StartTargetedSentimentDetectionJobError.errorSchema)
      .withOutput(StartTargetedSentimentDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Starts an asynchronous targeted sentiment detection job for a collection of documents. Use the\n      <code>DescribeTargetedSentimentDetectionJob</code> operation to track the status of a\n      job.</p>"))
    def wrap(input: StartTargetedSentimentDetectionJobRequest): StartTargetedSentimentDetectionJob = StartTargetedSentimentDetectionJob(input)
  }
  sealed trait StartTargetedSentimentDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartTargetedSentimentDetectionJobError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartTargetedSentimentDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = StartTargetedSentimentDetectionJobError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = StartTargetedSentimentDetectionJobError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = StartTargetedSentimentDetectionJobError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartTargetedSentimentDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StartTargetedSentimentDetectionJobError.Visitor[A]): A = this match {
      case value: StartTargetedSentimentDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartTargetedSentimentDetectionJobError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: StartTargetedSentimentDetectionJobError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: StartTargetedSentimentDetectionJobError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartTargetedSentimentDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StartTargetedSentimentDetectionJobError extends ErrorSchema.Companion[StartTargetedSentimentDetectionJobError] {

    def internalServerException(internalServerException: InternalServerException): StartTargetedSentimentDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): StartTargetedSentimentDetectionJobError = TooManyTagsExceptionCase(tooManyTagsException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): StartTargetedSentimentDetectionJobError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartTargetedSentimentDetectionJobError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartTargetedSentimentDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartTargetedSentimentDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartTargetedSentimentDetectionJobError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartTargetedSentimentDetectionJobError { final def $ordinal: Int = 0 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends StartTargetedSentimentDetectionJobError { final def $ordinal: Int = 1 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends StartTargetedSentimentDetectionJobError { final def $ordinal: Int = 2 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartTargetedSentimentDetectionJobError { final def $ordinal: Int = 3 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartTargetedSentimentDetectionJobError { final def $ordinal: Int = 4 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartTargetedSentimentDetectionJobError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTargetedSentimentDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartTargetedSentimentDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartTargetedSentimentDetectionJobError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTargetedSentimentDetectionJobError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), StartTargetedSentimentDetectionJobError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[StartTargetedSentimentDetectionJobError]("TooManyTagsException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTargetedSentimentDetectionJobError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), StartTargetedSentimentDetectionJobError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[StartTargetedSentimentDetectionJobError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTargetedSentimentDetectionJobError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartTargetedSentimentDetectionJobError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartTargetedSentimentDetectionJobError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartTargetedSentimentDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTargetedSentimentDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartTargetedSentimentDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartTargetedSentimentDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StartTargetedSentimentDetectionJobError] = union(
      StartTargetedSentimentDetectionJobError.InternalServerExceptionCase.alt,
      StartTargetedSentimentDetectionJobError.TooManyTagsExceptionCase.alt,
      StartTargetedSentimentDetectionJobError.KmsKeyValidationExceptionCase.alt,
      StartTargetedSentimentDetectionJobError.ResourceInUseExceptionCase.alt,
      StartTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase.alt,
      StartTargetedSentimentDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartTargetedSentimentDetectionJobError] = throwable match {
      case e: InternalServerException => Some(StartTargetedSentimentDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(StartTargetedSentimentDetectionJobError.TooManyTagsExceptionCase(e))
      case e: KmsKeyValidationException => Some(StartTargetedSentimentDetectionJobError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(StartTargetedSentimentDetectionJobError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartTargetedSentimentDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartTargetedSentimentDetectionJobError): Throwable = e match {
      case StartTargetedSentimentDetectionJobError.InternalServerExceptionCase(e) => e
      case StartTargetedSentimentDetectionJobError.TooManyTagsExceptionCase(e) => e
      case StartTargetedSentimentDetectionJobError.KmsKeyValidationExceptionCase(e) => e
      case StartTargetedSentimentDetectionJobError.ResourceInUseExceptionCase(e) => e
      case StartTargetedSentimentDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case StartTargetedSentimentDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StartTopicsDetectionJob(input: StartTopicsDetectionJobRequest) extends ComprehendOperation[StartTopicsDetectionJobRequest, ComprehendOperation.StartTopicsDetectionJobError, StartTopicsDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StartTopicsDetectionJobRequest, ComprehendOperation.StartTopicsDetectionJobError, StartTopicsDetectionJobResponse, Nothing, Nothing] = impl.startTopicsDetectionJob(input.inputDataConfig, input.outputDataConfig, input.dataAccessRoleArn, input.jobName, input.numberOfTopics, input.clientRequestToken, input.volumeKmsKeyId, input.vpcConfig, input.tags)
    def ordinal: Int = 70
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StartTopicsDetectionJobRequest, ComprehendOperation.StartTopicsDetectionJobError, StartTopicsDetectionJobResponse, Nothing, Nothing] = StartTopicsDetectionJob
  }
  object StartTopicsDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StartTopicsDetectionJobRequest, ComprehendOperation.StartTopicsDetectionJobError, StartTopicsDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StartTopicsDetectionJobRequest, ComprehendOperation.StartTopicsDetectionJobError, StartTopicsDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StartTopicsDetectionJob"))
      .withInput(StartTopicsDetectionJobRequest.schema)
      .withError(StartTopicsDetectionJobError.errorSchema)
      .withOutput(StartTopicsDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Starts an asynchronous topic detection job. Use the\n        <code>DescribeTopicDetectionJob</code> operation to track the status of a job.</p>"))
    def wrap(input: StartTopicsDetectionJobRequest): StartTopicsDetectionJob = StartTopicsDetectionJob(input)
  }
  sealed trait StartTopicsDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StartTopicsDetectionJobError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StartTopicsDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = StartTopicsDetectionJobError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = StartTopicsDetectionJobError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def resourceInUseException: Option[ResourceInUseException] = StartTopicsDetectionJobError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StartTopicsDetectionJobError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StartTopicsDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StartTopicsDetectionJobError.Visitor[A]): A = this match {
      case value: StartTopicsDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StartTopicsDetectionJobError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: StartTopicsDetectionJobError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: StartTopicsDetectionJobError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: StartTopicsDetectionJobError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StartTopicsDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StartTopicsDetectionJobError extends ErrorSchema.Companion[StartTopicsDetectionJobError] {

    def internalServerException(internalServerException: InternalServerException): StartTopicsDetectionJobError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): StartTopicsDetectionJobError = TooManyTagsExceptionCase(tooManyTagsException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): StartTopicsDetectionJobError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): StartTopicsDetectionJobError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StartTopicsDetectionJobError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StartTopicsDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StartTopicsDetectionJobError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StartTopicsDetectionJobError { final def $ordinal: Int = 0 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends StartTopicsDetectionJobError { final def $ordinal: Int = 1 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends StartTopicsDetectionJobError { final def $ordinal: Int = 2 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends StartTopicsDetectionJobError { final def $ordinal: Int = 3 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StartTopicsDetectionJobError { final def $ordinal: Int = 4 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StartTopicsDetectionJobError { final def $ordinal: Int = 5 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTopicsDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StartTopicsDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StartTopicsDetectionJobError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTopicsDetectionJobError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), StartTopicsDetectionJobError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[StartTopicsDetectionJobError]("TooManyTagsException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTopicsDetectionJobError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), StartTopicsDetectionJobError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[StartTopicsDetectionJobError]("KmsKeyValidationException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTopicsDetectionJobError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), StartTopicsDetectionJobError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[StartTopicsDetectionJobError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTopicsDetectionJobError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StartTopicsDetectionJobError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StartTopicsDetectionJobError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StartTopicsDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StartTopicsDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StartTopicsDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StartTopicsDetectionJobError] = union(
      StartTopicsDetectionJobError.InternalServerExceptionCase.alt,
      StartTopicsDetectionJobError.TooManyTagsExceptionCase.alt,
      StartTopicsDetectionJobError.KmsKeyValidationExceptionCase.alt,
      StartTopicsDetectionJobError.ResourceInUseExceptionCase.alt,
      StartTopicsDetectionJobError.TooManyRequestsExceptionCase.alt,
      StartTopicsDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StartTopicsDetectionJobError] = throwable match {
      case e: InternalServerException => Some(StartTopicsDetectionJobError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(StartTopicsDetectionJobError.TooManyTagsExceptionCase(e))
      case e: KmsKeyValidationException => Some(StartTopicsDetectionJobError.KmsKeyValidationExceptionCase(e))
      case e: ResourceInUseException => Some(StartTopicsDetectionJobError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(StartTopicsDetectionJobError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StartTopicsDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StartTopicsDetectionJobError): Throwable = e match {
      case StartTopicsDetectionJobError.InternalServerExceptionCase(e) => e
      case StartTopicsDetectionJobError.TooManyTagsExceptionCase(e) => e
      case StartTopicsDetectionJobError.KmsKeyValidationExceptionCase(e) => e
      case StartTopicsDetectionJobError.ResourceInUseExceptionCase(e) => e
      case StartTopicsDetectionJobError.TooManyRequestsExceptionCase(e) => e
      case StartTopicsDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StopDominantLanguageDetectionJob(input: StopDominantLanguageDetectionJobRequest) extends ComprehendOperation[StopDominantLanguageDetectionJobRequest, ComprehendOperation.StopDominantLanguageDetectionJobError, StopDominantLanguageDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StopDominantLanguageDetectionJobRequest, ComprehendOperation.StopDominantLanguageDetectionJobError, StopDominantLanguageDetectionJobResponse, Nothing, Nothing] = impl.stopDominantLanguageDetectionJob(input.jobId)
    def ordinal: Int = 71
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StopDominantLanguageDetectionJobRequest, ComprehendOperation.StopDominantLanguageDetectionJobError, StopDominantLanguageDetectionJobResponse, Nothing, Nothing] = StopDominantLanguageDetectionJob
  }
  object StopDominantLanguageDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StopDominantLanguageDetectionJobRequest, ComprehendOperation.StopDominantLanguageDetectionJobError, StopDominantLanguageDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StopDominantLanguageDetectionJobRequest, ComprehendOperation.StopDominantLanguageDetectionJobError, StopDominantLanguageDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StopDominantLanguageDetectionJob"))
      .withInput(StopDominantLanguageDetectionJobRequest.schema)
      .withError(StopDominantLanguageDetectionJobError.errorSchema)
      .withOutput(StopDominantLanguageDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Stops a dominant language detection job in progress.</p>\n         <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put\n      into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it\n      is put into the <code>COMPLETED</code> state; otherwise the job is stopped and put into the\n        <code>STOPPED</code> state.</p>\n         <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the\n        <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400\n      Internal Request Exception. </p>\n         <p>When a job is stopped, any documents already processed are written to the output\n      location.</p>"))
    def wrap(input: StopDominantLanguageDetectionJobRequest): StopDominantLanguageDetectionJob = StopDominantLanguageDetectionJob(input)
  }
  sealed trait StopDominantLanguageDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StopDominantLanguageDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = StopDominantLanguageDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = StopDominantLanguageDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = StopDominantLanguageDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StopDominantLanguageDetectionJobError.Visitor[A]): A = this match {
      case value: StopDominantLanguageDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: StopDominantLanguageDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StopDominantLanguageDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StopDominantLanguageDetectionJobError extends ErrorSchema.Companion[StopDominantLanguageDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): StopDominantLanguageDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): StopDominantLanguageDetectionJobError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StopDominantLanguageDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StopDominantLanguageDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends StopDominantLanguageDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StopDominantLanguageDetectionJobError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StopDominantLanguageDetectionJobError { final def $ordinal: Int = 2 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopDominantLanguageDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), StopDominantLanguageDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[StopDominantLanguageDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopDominantLanguageDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StopDominantLanguageDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StopDominantLanguageDetectionJobError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopDominantLanguageDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StopDominantLanguageDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StopDominantLanguageDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StopDominantLanguageDetectionJobError] = union(
      StopDominantLanguageDetectionJobError.JobNotFoundExceptionCase.alt,
      StopDominantLanguageDetectionJobError.InternalServerExceptionCase.alt,
      StopDominantLanguageDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StopDominantLanguageDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(StopDominantLanguageDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(StopDominantLanguageDetectionJobError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(StopDominantLanguageDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StopDominantLanguageDetectionJobError): Throwable = e match {
      case StopDominantLanguageDetectionJobError.JobNotFoundExceptionCase(e) => e
      case StopDominantLanguageDetectionJobError.InternalServerExceptionCase(e) => e
      case StopDominantLanguageDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StopEntitiesDetectionJob(input: StopEntitiesDetectionJobRequest) extends ComprehendOperation[StopEntitiesDetectionJobRequest, ComprehendOperation.StopEntitiesDetectionJobError, StopEntitiesDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StopEntitiesDetectionJobRequest, ComprehendOperation.StopEntitiesDetectionJobError, StopEntitiesDetectionJobResponse, Nothing, Nothing] = impl.stopEntitiesDetectionJob(input.jobId)
    def ordinal: Int = 72
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StopEntitiesDetectionJobRequest, ComprehendOperation.StopEntitiesDetectionJobError, StopEntitiesDetectionJobResponse, Nothing, Nothing] = StopEntitiesDetectionJob
  }
  object StopEntitiesDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StopEntitiesDetectionJobRequest, ComprehendOperation.StopEntitiesDetectionJobError, StopEntitiesDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StopEntitiesDetectionJobRequest, ComprehendOperation.StopEntitiesDetectionJobError, StopEntitiesDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StopEntitiesDetectionJob"))
      .withInput(StopEntitiesDetectionJobRequest.schema)
      .withError(StopEntitiesDetectionJobError.errorSchema)
      .withOutput(StopEntitiesDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Stops an entities detection job in progress.</p>\n         <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put\n      into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it\n      is put into the <code>COMPLETED</code> state; otherwise the job is stopped and put into the\n        <code>STOPPED</code> state.</p>\n         <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the\n        <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400\n      Internal Request Exception. </p>\n         <p>When a job is stopped, any documents already processed are written to the output\n      location.</p>"))
    def wrap(input: StopEntitiesDetectionJobRequest): StopEntitiesDetectionJob = StopEntitiesDetectionJob(input)
  }
  sealed trait StopEntitiesDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StopEntitiesDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = StopEntitiesDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = StopEntitiesDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = StopEntitiesDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StopEntitiesDetectionJobError.Visitor[A]): A = this match {
      case value: StopEntitiesDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: StopEntitiesDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StopEntitiesDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StopEntitiesDetectionJobError extends ErrorSchema.Companion[StopEntitiesDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): StopEntitiesDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): StopEntitiesDetectionJobError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StopEntitiesDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StopEntitiesDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends StopEntitiesDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StopEntitiesDetectionJobError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StopEntitiesDetectionJobError { final def $ordinal: Int = 2 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopEntitiesDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), StopEntitiesDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[StopEntitiesDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopEntitiesDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StopEntitiesDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StopEntitiesDetectionJobError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopEntitiesDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StopEntitiesDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StopEntitiesDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StopEntitiesDetectionJobError] = union(
      StopEntitiesDetectionJobError.JobNotFoundExceptionCase.alt,
      StopEntitiesDetectionJobError.InternalServerExceptionCase.alt,
      StopEntitiesDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StopEntitiesDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(StopEntitiesDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(StopEntitiesDetectionJobError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(StopEntitiesDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StopEntitiesDetectionJobError): Throwable = e match {
      case StopEntitiesDetectionJobError.JobNotFoundExceptionCase(e) => e
      case StopEntitiesDetectionJobError.InternalServerExceptionCase(e) => e
      case StopEntitiesDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StopEventsDetectionJob(input: StopEventsDetectionJobRequest) extends ComprehendOperation[StopEventsDetectionJobRequest, ComprehendOperation.StopEventsDetectionJobError, StopEventsDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StopEventsDetectionJobRequest, ComprehendOperation.StopEventsDetectionJobError, StopEventsDetectionJobResponse, Nothing, Nothing] = impl.stopEventsDetectionJob(input.jobId)
    def ordinal: Int = 73
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StopEventsDetectionJobRequest, ComprehendOperation.StopEventsDetectionJobError, StopEventsDetectionJobResponse, Nothing, Nothing] = StopEventsDetectionJob
  }
  object StopEventsDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StopEventsDetectionJobRequest, ComprehendOperation.StopEventsDetectionJobError, StopEventsDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StopEventsDetectionJobRequest, ComprehendOperation.StopEventsDetectionJobError, StopEventsDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StopEventsDetectionJob"))
      .withInput(StopEventsDetectionJobRequest.schema)
      .withError(StopEventsDetectionJobError.errorSchema)
      .withOutput(StopEventsDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Stops an events detection job in progress.</p>"))
    def wrap(input: StopEventsDetectionJobRequest): StopEventsDetectionJob = StopEventsDetectionJob(input)
  }
  sealed trait StopEventsDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StopEventsDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = StopEventsDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = StopEventsDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = StopEventsDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StopEventsDetectionJobError.Visitor[A]): A = this match {
      case value: StopEventsDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: StopEventsDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StopEventsDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StopEventsDetectionJobError extends ErrorSchema.Companion[StopEventsDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): StopEventsDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): StopEventsDetectionJobError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StopEventsDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StopEventsDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends StopEventsDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StopEventsDetectionJobError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StopEventsDetectionJobError { final def $ordinal: Int = 2 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopEventsDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), StopEventsDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[StopEventsDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopEventsDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StopEventsDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StopEventsDetectionJobError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopEventsDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StopEventsDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StopEventsDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StopEventsDetectionJobError] = union(
      StopEventsDetectionJobError.JobNotFoundExceptionCase.alt,
      StopEventsDetectionJobError.InternalServerExceptionCase.alt,
      StopEventsDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StopEventsDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(StopEventsDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(StopEventsDetectionJobError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(StopEventsDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StopEventsDetectionJobError): Throwable = e match {
      case StopEventsDetectionJobError.JobNotFoundExceptionCase(e) => e
      case StopEventsDetectionJobError.InternalServerExceptionCase(e) => e
      case StopEventsDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StopKeyPhrasesDetectionJob(input: StopKeyPhrasesDetectionJobRequest) extends ComprehendOperation[StopKeyPhrasesDetectionJobRequest, ComprehendOperation.StopKeyPhrasesDetectionJobError, StopKeyPhrasesDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StopKeyPhrasesDetectionJobRequest, ComprehendOperation.StopKeyPhrasesDetectionJobError, StopKeyPhrasesDetectionJobResponse, Nothing, Nothing] = impl.stopKeyPhrasesDetectionJob(input.jobId)
    def ordinal: Int = 74
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StopKeyPhrasesDetectionJobRequest, ComprehendOperation.StopKeyPhrasesDetectionJobError, StopKeyPhrasesDetectionJobResponse, Nothing, Nothing] = StopKeyPhrasesDetectionJob
  }
  object StopKeyPhrasesDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StopKeyPhrasesDetectionJobRequest, ComprehendOperation.StopKeyPhrasesDetectionJobError, StopKeyPhrasesDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StopKeyPhrasesDetectionJobRequest, ComprehendOperation.StopKeyPhrasesDetectionJobError, StopKeyPhrasesDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StopKeyPhrasesDetectionJob"))
      .withInput(StopKeyPhrasesDetectionJobRequest.schema)
      .withError(StopKeyPhrasesDetectionJobError.errorSchema)
      .withOutput(StopKeyPhrasesDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Stops a key phrases detection job in progress.</p>\n         <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put\n      into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it\n      is put into the <code>COMPLETED</code> state; otherwise the job is stopped and put into the\n        <code>STOPPED</code> state.</p>\n         <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the\n        <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400\n      Internal Request Exception. </p>\n         <p>When a job is stopped, any documents already processed are written to the output\n      location.</p>"))
    def wrap(input: StopKeyPhrasesDetectionJobRequest): StopKeyPhrasesDetectionJob = StopKeyPhrasesDetectionJob(input)
  }
  sealed trait StopKeyPhrasesDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StopKeyPhrasesDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = StopKeyPhrasesDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = StopKeyPhrasesDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = StopKeyPhrasesDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StopKeyPhrasesDetectionJobError.Visitor[A]): A = this match {
      case value: StopKeyPhrasesDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: StopKeyPhrasesDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StopKeyPhrasesDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StopKeyPhrasesDetectionJobError extends ErrorSchema.Companion[StopKeyPhrasesDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): StopKeyPhrasesDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): StopKeyPhrasesDetectionJobError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StopKeyPhrasesDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StopKeyPhrasesDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends StopKeyPhrasesDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StopKeyPhrasesDetectionJobError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StopKeyPhrasesDetectionJobError { final def $ordinal: Int = 2 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopKeyPhrasesDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), StopKeyPhrasesDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[StopKeyPhrasesDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopKeyPhrasesDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StopKeyPhrasesDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StopKeyPhrasesDetectionJobError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopKeyPhrasesDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StopKeyPhrasesDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StopKeyPhrasesDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StopKeyPhrasesDetectionJobError] = union(
      StopKeyPhrasesDetectionJobError.JobNotFoundExceptionCase.alt,
      StopKeyPhrasesDetectionJobError.InternalServerExceptionCase.alt,
      StopKeyPhrasesDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StopKeyPhrasesDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(StopKeyPhrasesDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(StopKeyPhrasesDetectionJobError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(StopKeyPhrasesDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StopKeyPhrasesDetectionJobError): Throwable = e match {
      case StopKeyPhrasesDetectionJobError.JobNotFoundExceptionCase(e) => e
      case StopKeyPhrasesDetectionJobError.InternalServerExceptionCase(e) => e
      case StopKeyPhrasesDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StopPiiEntitiesDetectionJob(input: StopPiiEntitiesDetectionJobRequest) extends ComprehendOperation[StopPiiEntitiesDetectionJobRequest, ComprehendOperation.StopPiiEntitiesDetectionJobError, StopPiiEntitiesDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StopPiiEntitiesDetectionJobRequest, ComprehendOperation.StopPiiEntitiesDetectionJobError, StopPiiEntitiesDetectionJobResponse, Nothing, Nothing] = impl.stopPiiEntitiesDetectionJob(input.jobId)
    def ordinal: Int = 75
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StopPiiEntitiesDetectionJobRequest, ComprehendOperation.StopPiiEntitiesDetectionJobError, StopPiiEntitiesDetectionJobResponse, Nothing, Nothing] = StopPiiEntitiesDetectionJob
  }
  object StopPiiEntitiesDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StopPiiEntitiesDetectionJobRequest, ComprehendOperation.StopPiiEntitiesDetectionJobError, StopPiiEntitiesDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StopPiiEntitiesDetectionJobRequest, ComprehendOperation.StopPiiEntitiesDetectionJobError, StopPiiEntitiesDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StopPiiEntitiesDetectionJob"))
      .withInput(StopPiiEntitiesDetectionJobRequest.schema)
      .withError(StopPiiEntitiesDetectionJobError.errorSchema)
      .withOutput(StopPiiEntitiesDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Stops a PII entities detection job in progress.</p>"))
    def wrap(input: StopPiiEntitiesDetectionJobRequest): StopPiiEntitiesDetectionJob = StopPiiEntitiesDetectionJob(input)
  }
  sealed trait StopPiiEntitiesDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StopPiiEntitiesDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = StopPiiEntitiesDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = StopPiiEntitiesDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = StopPiiEntitiesDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StopPiiEntitiesDetectionJobError.Visitor[A]): A = this match {
      case value: StopPiiEntitiesDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: StopPiiEntitiesDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StopPiiEntitiesDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StopPiiEntitiesDetectionJobError extends ErrorSchema.Companion[StopPiiEntitiesDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): StopPiiEntitiesDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): StopPiiEntitiesDetectionJobError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StopPiiEntitiesDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StopPiiEntitiesDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends StopPiiEntitiesDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StopPiiEntitiesDetectionJobError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StopPiiEntitiesDetectionJobError { final def $ordinal: Int = 2 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopPiiEntitiesDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), StopPiiEntitiesDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[StopPiiEntitiesDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopPiiEntitiesDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StopPiiEntitiesDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StopPiiEntitiesDetectionJobError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopPiiEntitiesDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StopPiiEntitiesDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StopPiiEntitiesDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StopPiiEntitiesDetectionJobError] = union(
      StopPiiEntitiesDetectionJobError.JobNotFoundExceptionCase.alt,
      StopPiiEntitiesDetectionJobError.InternalServerExceptionCase.alt,
      StopPiiEntitiesDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StopPiiEntitiesDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(StopPiiEntitiesDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(StopPiiEntitiesDetectionJobError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(StopPiiEntitiesDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StopPiiEntitiesDetectionJobError): Throwable = e match {
      case StopPiiEntitiesDetectionJobError.JobNotFoundExceptionCase(e) => e
      case StopPiiEntitiesDetectionJobError.InternalServerExceptionCase(e) => e
      case StopPiiEntitiesDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StopSentimentDetectionJob(input: StopSentimentDetectionJobRequest) extends ComprehendOperation[StopSentimentDetectionJobRequest, ComprehendOperation.StopSentimentDetectionJobError, StopSentimentDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StopSentimentDetectionJobRequest, ComprehendOperation.StopSentimentDetectionJobError, StopSentimentDetectionJobResponse, Nothing, Nothing] = impl.stopSentimentDetectionJob(input.jobId)
    def ordinal: Int = 76
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StopSentimentDetectionJobRequest, ComprehendOperation.StopSentimentDetectionJobError, StopSentimentDetectionJobResponse, Nothing, Nothing] = StopSentimentDetectionJob
  }
  object StopSentimentDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StopSentimentDetectionJobRequest, ComprehendOperation.StopSentimentDetectionJobError, StopSentimentDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StopSentimentDetectionJobRequest, ComprehendOperation.StopSentimentDetectionJobError, StopSentimentDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StopSentimentDetectionJob"))
      .withInput(StopSentimentDetectionJobRequest.schema)
      .withError(StopSentimentDetectionJobError.errorSchema)
      .withOutput(StopSentimentDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Stops a sentiment detection job in progress.</p>\n         <p>If the job state is <code>IN_PROGRESS</code>, the job is marked for termination and put\n      into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it\n      is put into the <code>COMPLETED</code> state; otherwise the job is be stopped and put into the\n        <code>STOPPED</code> state.</p>\n         <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the\n        <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400\n      Internal Request Exception. </p>\n         <p>When a job is stopped, any documents already processed are written to the output\n      location.</p>"))
    def wrap(input: StopSentimentDetectionJobRequest): StopSentimentDetectionJob = StopSentimentDetectionJob(input)
  }
  sealed trait StopSentimentDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StopSentimentDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = StopSentimentDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = StopSentimentDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = StopSentimentDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StopSentimentDetectionJobError.Visitor[A]): A = this match {
      case value: StopSentimentDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: StopSentimentDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StopSentimentDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StopSentimentDetectionJobError extends ErrorSchema.Companion[StopSentimentDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): StopSentimentDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): StopSentimentDetectionJobError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StopSentimentDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StopSentimentDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends StopSentimentDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StopSentimentDetectionJobError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StopSentimentDetectionJobError { final def $ordinal: Int = 2 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopSentimentDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), StopSentimentDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[StopSentimentDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopSentimentDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StopSentimentDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StopSentimentDetectionJobError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopSentimentDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StopSentimentDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StopSentimentDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StopSentimentDetectionJobError] = union(
      StopSentimentDetectionJobError.JobNotFoundExceptionCase.alt,
      StopSentimentDetectionJobError.InternalServerExceptionCase.alt,
      StopSentimentDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StopSentimentDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(StopSentimentDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(StopSentimentDetectionJobError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(StopSentimentDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StopSentimentDetectionJobError): Throwable = e match {
      case StopSentimentDetectionJobError.JobNotFoundExceptionCase(e) => e
      case StopSentimentDetectionJobError.InternalServerExceptionCase(e) => e
      case StopSentimentDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StopTargetedSentimentDetectionJob(input: StopTargetedSentimentDetectionJobRequest) extends ComprehendOperation[StopTargetedSentimentDetectionJobRequest, ComprehendOperation.StopTargetedSentimentDetectionJobError, StopTargetedSentimentDetectionJobResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StopTargetedSentimentDetectionJobRequest, ComprehendOperation.StopTargetedSentimentDetectionJobError, StopTargetedSentimentDetectionJobResponse, Nothing, Nothing] = impl.stopTargetedSentimentDetectionJob(input.jobId)
    def ordinal: Int = 77
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StopTargetedSentimentDetectionJobRequest, ComprehendOperation.StopTargetedSentimentDetectionJobError, StopTargetedSentimentDetectionJobResponse, Nothing, Nothing] = StopTargetedSentimentDetectionJob
  }
  object StopTargetedSentimentDetectionJob extends smithy4s.Endpoint[ComprehendOperation,StopTargetedSentimentDetectionJobRequest, ComprehendOperation.StopTargetedSentimentDetectionJobError, StopTargetedSentimentDetectionJobResponse, Nothing, Nothing] {
    val schema: OperationSchema[StopTargetedSentimentDetectionJobRequest, ComprehendOperation.StopTargetedSentimentDetectionJobError, StopTargetedSentimentDetectionJobResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StopTargetedSentimentDetectionJob"))
      .withInput(StopTargetedSentimentDetectionJobRequest.schema)
      .withError(StopTargetedSentimentDetectionJobError.errorSchema)
      .withOutput(StopTargetedSentimentDetectionJobResponse.schema)
      .withHints(smithy.api.Documentation("<p>Stops a targeted sentiment detection job in progress.</p>\n         <p>If the job state is <code>IN_PROGRESS</code>, the job is marked for termination and put\n      into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it\n      is put into the <code>COMPLETED</code> state; otherwise the job is be stopped and put into the\n      <code>STOPPED</code> state.</p>\n         <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the\n      <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400\n      Internal Request Exception. </p>\n         <p>When a job is stopped, any documents already processed are written to the output\n      location.</p>"))
    def wrap(input: StopTargetedSentimentDetectionJobRequest): StopTargetedSentimentDetectionJob = StopTargetedSentimentDetectionJob(input)
  }
  sealed trait StopTargetedSentimentDetectionJobError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StopTargetedSentimentDetectionJobError = this
    def $ordinal: Int

    object project {
      def jobNotFoundException: Option[JobNotFoundException] = StopTargetedSentimentDetectionJobError.JobNotFoundExceptionCase.alt.project.lift(self).map(_.jobNotFoundException)
      def internalServerException: Option[InternalServerException] = StopTargetedSentimentDetectionJobError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = StopTargetedSentimentDetectionJobError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
    }

    def accept[A](visitor: StopTargetedSentimentDetectionJobError.Visitor[A]): A = this match {
      case value: StopTargetedSentimentDetectionJobError.JobNotFoundExceptionCase => visitor.jobNotFoundException(value.jobNotFoundException)
      case value: StopTargetedSentimentDetectionJobError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StopTargetedSentimentDetectionJobError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
    }
  }
  object StopTargetedSentimentDetectionJobError extends ErrorSchema.Companion[StopTargetedSentimentDetectionJobError] {

    def jobNotFoundException(jobNotFoundException: JobNotFoundException): StopTargetedSentimentDetectionJobError = JobNotFoundExceptionCase(jobNotFoundException)
    def internalServerException(internalServerException: InternalServerException): StopTargetedSentimentDetectionJobError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StopTargetedSentimentDetectionJobError = InvalidRequestExceptionCase(invalidRequestException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StopTargetedSentimentDetectionJobError")

    val hints: Hints = Hints.empty

    final case class JobNotFoundExceptionCase(jobNotFoundException: JobNotFoundException) extends StopTargetedSentimentDetectionJobError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StopTargetedSentimentDetectionJobError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StopTargetedSentimentDetectionJobError { final def $ordinal: Int = 2 }

    object JobNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTargetedSentimentDetectionJobError.JobNotFoundExceptionCase] = bijection(JobNotFoundException.schema.addHints(hints), StopTargetedSentimentDetectionJobError.JobNotFoundExceptionCase(_), _.jobNotFoundException)
      val alt = schema.oneOf[StopTargetedSentimentDetectionJobError]("JobNotFoundException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTargetedSentimentDetectionJobError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StopTargetedSentimentDetectionJobError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StopTargetedSentimentDetectionJobError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTargetedSentimentDetectionJobError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StopTargetedSentimentDetectionJobError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StopTargetedSentimentDetectionJobError]("InvalidRequestException")
    }

    trait Visitor[A] {
      def jobNotFoundException(value: JobNotFoundException): A
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def jobNotFoundException(value: JobNotFoundException): A = default
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
      }
    }

    implicit val schema: Schema[StopTargetedSentimentDetectionJobError] = union(
      StopTargetedSentimentDetectionJobError.JobNotFoundExceptionCase.alt,
      StopTargetedSentimentDetectionJobError.InternalServerExceptionCase.alt,
      StopTargetedSentimentDetectionJobError.InvalidRequestExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StopTargetedSentimentDetectionJobError] = throwable match {
      case e: JobNotFoundException => Some(StopTargetedSentimentDetectionJobError.JobNotFoundExceptionCase(e))
      case e: InternalServerException => Some(StopTargetedSentimentDetectionJobError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(StopTargetedSentimentDetectionJobError.InvalidRequestExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StopTargetedSentimentDetectionJobError): Throwable = e match {
      case StopTargetedSentimentDetectionJobError.JobNotFoundExceptionCase(e) => e
      case StopTargetedSentimentDetectionJobError.InternalServerExceptionCase(e) => e
      case StopTargetedSentimentDetectionJobError.InvalidRequestExceptionCase(e) => e
    }
  }
  final case class StopTrainingDocumentClassifier(input: StopTrainingDocumentClassifierRequest) extends ComprehendOperation[StopTrainingDocumentClassifierRequest, ComprehendOperation.StopTrainingDocumentClassifierError, StopTrainingDocumentClassifierResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StopTrainingDocumentClassifierRequest, ComprehendOperation.StopTrainingDocumentClassifierError, StopTrainingDocumentClassifierResponse, Nothing, Nothing] = impl.stopTrainingDocumentClassifier(input.documentClassifierArn)
    def ordinal: Int = 78
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StopTrainingDocumentClassifierRequest, ComprehendOperation.StopTrainingDocumentClassifierError, StopTrainingDocumentClassifierResponse, Nothing, Nothing] = StopTrainingDocumentClassifier
  }
  object StopTrainingDocumentClassifier extends smithy4s.Endpoint[ComprehendOperation,StopTrainingDocumentClassifierRequest, ComprehendOperation.StopTrainingDocumentClassifierError, StopTrainingDocumentClassifierResponse, Nothing, Nothing] {
    val schema: OperationSchema[StopTrainingDocumentClassifierRequest, ComprehendOperation.StopTrainingDocumentClassifierError, StopTrainingDocumentClassifierResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StopTrainingDocumentClassifier"))
      .withInput(StopTrainingDocumentClassifierRequest.schema)
      .withError(StopTrainingDocumentClassifierError.errorSchema)
      .withOutput(StopTrainingDocumentClassifierResponse.schema)
      .withHints(smithy.api.Documentation("<p>Stops a document classifier training job while in progress.</p>\n         <p>If the training job state is <code>TRAINING</code>, the job is marked for termination and\n      put into the <code>STOP_REQUESTED</code> state. If the training job completes before it can be\n      stopped, it is put into the <code>TRAINED</code>; otherwise the training job is stopped and\n      put into the <code>STOPPED</code> state and the service sends back an HTTP 200 response with\n      an empty HTTP body. </p>"))
    def wrap(input: StopTrainingDocumentClassifierRequest): StopTrainingDocumentClassifier = StopTrainingDocumentClassifier(input)
  }
  sealed trait StopTrainingDocumentClassifierError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StopTrainingDocumentClassifierError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StopTrainingDocumentClassifierError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StopTrainingDocumentClassifierError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StopTrainingDocumentClassifierError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = StopTrainingDocumentClassifierError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: StopTrainingDocumentClassifierError.Visitor[A]): A = this match {
      case value: StopTrainingDocumentClassifierError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StopTrainingDocumentClassifierError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StopTrainingDocumentClassifierError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: StopTrainingDocumentClassifierError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object StopTrainingDocumentClassifierError extends ErrorSchema.Companion[StopTrainingDocumentClassifierError] {

    def internalServerException(internalServerException: InternalServerException): StopTrainingDocumentClassifierError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StopTrainingDocumentClassifierError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StopTrainingDocumentClassifierError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): StopTrainingDocumentClassifierError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StopTrainingDocumentClassifierError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StopTrainingDocumentClassifierError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StopTrainingDocumentClassifierError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StopTrainingDocumentClassifierError { final def $ordinal: Int = 2 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends StopTrainingDocumentClassifierError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTrainingDocumentClassifierError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StopTrainingDocumentClassifierError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StopTrainingDocumentClassifierError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTrainingDocumentClassifierError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StopTrainingDocumentClassifierError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StopTrainingDocumentClassifierError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTrainingDocumentClassifierError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StopTrainingDocumentClassifierError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StopTrainingDocumentClassifierError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTrainingDocumentClassifierError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), StopTrainingDocumentClassifierError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[StopTrainingDocumentClassifierError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[StopTrainingDocumentClassifierError] = union(
      StopTrainingDocumentClassifierError.InternalServerExceptionCase.alt,
      StopTrainingDocumentClassifierError.TooManyRequestsExceptionCase.alt,
      StopTrainingDocumentClassifierError.InvalidRequestExceptionCase.alt,
      StopTrainingDocumentClassifierError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StopTrainingDocumentClassifierError] = throwable match {
      case e: InternalServerException => Some(StopTrainingDocumentClassifierError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(StopTrainingDocumentClassifierError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StopTrainingDocumentClassifierError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(StopTrainingDocumentClassifierError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StopTrainingDocumentClassifierError): Throwable = e match {
      case StopTrainingDocumentClassifierError.InternalServerExceptionCase(e) => e
      case StopTrainingDocumentClassifierError.TooManyRequestsExceptionCase(e) => e
      case StopTrainingDocumentClassifierError.InvalidRequestExceptionCase(e) => e
      case StopTrainingDocumentClassifierError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class StopTrainingEntityRecognizer(input: StopTrainingEntityRecognizerRequest) extends ComprehendOperation[StopTrainingEntityRecognizerRequest, ComprehendOperation.StopTrainingEntityRecognizerError, StopTrainingEntityRecognizerResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[StopTrainingEntityRecognizerRequest, ComprehendOperation.StopTrainingEntityRecognizerError, StopTrainingEntityRecognizerResponse, Nothing, Nothing] = impl.stopTrainingEntityRecognizer(input.entityRecognizerArn)
    def ordinal: Int = 79
    def endpoint: smithy4s.Endpoint[ComprehendOperation,StopTrainingEntityRecognizerRequest, ComprehendOperation.StopTrainingEntityRecognizerError, StopTrainingEntityRecognizerResponse, Nothing, Nothing] = StopTrainingEntityRecognizer
  }
  object StopTrainingEntityRecognizer extends smithy4s.Endpoint[ComprehendOperation,StopTrainingEntityRecognizerRequest, ComprehendOperation.StopTrainingEntityRecognizerError, StopTrainingEntityRecognizerResponse, Nothing, Nothing] {
    val schema: OperationSchema[StopTrainingEntityRecognizerRequest, ComprehendOperation.StopTrainingEntityRecognizerError, StopTrainingEntityRecognizerResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "StopTrainingEntityRecognizer"))
      .withInput(StopTrainingEntityRecognizerRequest.schema)
      .withError(StopTrainingEntityRecognizerError.errorSchema)
      .withOutput(StopTrainingEntityRecognizerResponse.schema)
      .withHints(smithy.api.Documentation("<p>Stops an entity recognizer training job while in progress.</p>\n         <p>If the training job state is <code>TRAINING</code>, the job is marked for termination and\n      put into the <code>STOP_REQUESTED</code> state. If the training job completes before it can be\n      stopped, it is put into the <code>TRAINED</code>; otherwise the training job is stopped and\n      putted into the <code>STOPPED</code> state and the service sends back an HTTP 200 response\n      with an empty HTTP body.</p>"))
    def wrap(input: StopTrainingEntityRecognizerRequest): StopTrainingEntityRecognizer = StopTrainingEntityRecognizer(input)
  }
  sealed trait StopTrainingEntityRecognizerError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: StopTrainingEntityRecognizerError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = StopTrainingEntityRecognizerError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyRequestsException: Option[TooManyRequestsException] = StopTrainingEntityRecognizerError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = StopTrainingEntityRecognizerError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = StopTrainingEntityRecognizerError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: StopTrainingEntityRecognizerError.Visitor[A]): A = this match {
      case value: StopTrainingEntityRecognizerError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: StopTrainingEntityRecognizerError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: StopTrainingEntityRecognizerError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: StopTrainingEntityRecognizerError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object StopTrainingEntityRecognizerError extends ErrorSchema.Companion[StopTrainingEntityRecognizerError] {

    def internalServerException(internalServerException: InternalServerException): StopTrainingEntityRecognizerError = InternalServerExceptionCase(internalServerException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): StopTrainingEntityRecognizerError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): StopTrainingEntityRecognizerError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): StopTrainingEntityRecognizerError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "StopTrainingEntityRecognizerError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends StopTrainingEntityRecognizerError { final def $ordinal: Int = 0 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends StopTrainingEntityRecognizerError { final def $ordinal: Int = 1 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends StopTrainingEntityRecognizerError { final def $ordinal: Int = 2 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends StopTrainingEntityRecognizerError { final def $ordinal: Int = 3 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTrainingEntityRecognizerError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), StopTrainingEntityRecognizerError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[StopTrainingEntityRecognizerError]("InternalServerException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTrainingEntityRecognizerError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), StopTrainingEntityRecognizerError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[StopTrainingEntityRecognizerError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTrainingEntityRecognizerError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), StopTrainingEntityRecognizerError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[StopTrainingEntityRecognizerError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[StopTrainingEntityRecognizerError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), StopTrainingEntityRecognizerError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[StopTrainingEntityRecognizerError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[StopTrainingEntityRecognizerError] = union(
      StopTrainingEntityRecognizerError.InternalServerExceptionCase.alt,
      StopTrainingEntityRecognizerError.TooManyRequestsExceptionCase.alt,
      StopTrainingEntityRecognizerError.InvalidRequestExceptionCase.alt,
      StopTrainingEntityRecognizerError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[StopTrainingEntityRecognizerError] = throwable match {
      case e: InternalServerException => Some(StopTrainingEntityRecognizerError.InternalServerExceptionCase(e))
      case e: TooManyRequestsException => Some(StopTrainingEntityRecognizerError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(StopTrainingEntityRecognizerError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(StopTrainingEntityRecognizerError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: StopTrainingEntityRecognizerError): Throwable = e match {
      case StopTrainingEntityRecognizerError.InternalServerExceptionCase(e) => e
      case StopTrainingEntityRecognizerError.TooManyRequestsExceptionCase(e) => e
      case StopTrainingEntityRecognizerError.InvalidRequestExceptionCase(e) => e
      case StopTrainingEntityRecognizerError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class TagResource(input: TagResourceRequest) extends ComprehendOperation[TagResourceRequest, ComprehendOperation.TagResourceError, TagResourceResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[TagResourceRequest, ComprehendOperation.TagResourceError, TagResourceResponse, Nothing, Nothing] = impl.tagResource(input.resourceArn, input.tags)
    def ordinal: Int = 80
    def endpoint: smithy4s.Endpoint[ComprehendOperation,TagResourceRequest, ComprehendOperation.TagResourceError, TagResourceResponse, Nothing, Nothing] = TagResource
  }
  object TagResource extends smithy4s.Endpoint[ComprehendOperation,TagResourceRequest, ComprehendOperation.TagResourceError, TagResourceResponse, Nothing, Nothing] {
    val schema: OperationSchema[TagResourceRequest, ComprehendOperation.TagResourceError, TagResourceResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "TagResource"))
      .withInput(TagResourceRequest.schema)
      .withError(TagResourceError.errorSchema)
      .withOutput(TagResourceResponse.schema)
      .withHints(smithy.api.Documentation("<p>Associates a specific tag with an Amazon Comprehend resource. A tag is a key-value pair\n      that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with\n      \"Sales\" as the key might be added to a resource to indicate its use by the sales department.\n    </p>"))
    def wrap(input: TagResourceRequest): TagResource = TagResource(input)
  }
  sealed trait TagResourceError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: TagResourceError = this
    def $ordinal: Int

    object project {
      def concurrentModificationException: Option[ConcurrentModificationException] = TagResourceError.ConcurrentModificationExceptionCase.alt.project.lift(self).map(_.concurrentModificationException)
      def internalServerException: Option[InternalServerException] = TagResourceError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def tooManyTagsException: Option[TooManyTagsException] = TagResourceError.TooManyTagsExceptionCase.alt.project.lift(self).map(_.tooManyTagsException)
      def invalidRequestException: Option[InvalidRequestException] = TagResourceError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = TagResourceError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: TagResourceError.Visitor[A]): A = this match {
      case value: TagResourceError.ConcurrentModificationExceptionCase => visitor.concurrentModificationException(value.concurrentModificationException)
      case value: TagResourceError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: TagResourceError.TooManyTagsExceptionCase => visitor.tooManyTagsException(value.tooManyTagsException)
      case value: TagResourceError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: TagResourceError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object TagResourceError extends ErrorSchema.Companion[TagResourceError] {

    def concurrentModificationException(concurrentModificationException: ConcurrentModificationException): TagResourceError = ConcurrentModificationExceptionCase(concurrentModificationException)
    def internalServerException(internalServerException: InternalServerException): TagResourceError = InternalServerExceptionCase(internalServerException)
    def tooManyTagsException(tooManyTagsException: TooManyTagsException): TagResourceError = TooManyTagsExceptionCase(tooManyTagsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): TagResourceError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): TagResourceError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "TagResourceError")

    val hints: Hints = Hints.empty

    final case class ConcurrentModificationExceptionCase(concurrentModificationException: ConcurrentModificationException) extends TagResourceError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends TagResourceError { final def $ordinal: Int = 1 }
    final case class TooManyTagsExceptionCase(tooManyTagsException: TooManyTagsException) extends TagResourceError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends TagResourceError { final def $ordinal: Int = 3 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends TagResourceError { final def $ordinal: Int = 4 }

    object ConcurrentModificationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[TagResourceError.ConcurrentModificationExceptionCase] = bijection(ConcurrentModificationException.schema.addHints(hints), TagResourceError.ConcurrentModificationExceptionCase(_), _.concurrentModificationException)
      val alt = schema.oneOf[TagResourceError]("ConcurrentModificationException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[TagResourceError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), TagResourceError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[TagResourceError]("InternalServerException")
    }
    object TooManyTagsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[TagResourceError.TooManyTagsExceptionCase] = bijection(TooManyTagsException.schema.addHints(hints), TagResourceError.TooManyTagsExceptionCase(_), _.tooManyTagsException)
      val alt = schema.oneOf[TagResourceError]("TooManyTagsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[TagResourceError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), TagResourceError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[TagResourceError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[TagResourceError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), TagResourceError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[TagResourceError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def concurrentModificationException(value: ConcurrentModificationException): A
      def internalServerException(value: InternalServerException): A
      def tooManyTagsException(value: TooManyTagsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def concurrentModificationException(value: ConcurrentModificationException): A = default
        def internalServerException(value: InternalServerException): A = default
        def tooManyTagsException(value: TooManyTagsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[TagResourceError] = union(
      TagResourceError.ConcurrentModificationExceptionCase.alt,
      TagResourceError.InternalServerExceptionCase.alt,
      TagResourceError.TooManyTagsExceptionCase.alt,
      TagResourceError.InvalidRequestExceptionCase.alt,
      TagResourceError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[TagResourceError] = throwable match {
      case e: ConcurrentModificationException => Some(TagResourceError.ConcurrentModificationExceptionCase(e))
      case e: InternalServerException => Some(TagResourceError.InternalServerExceptionCase(e))
      case e: TooManyTagsException => Some(TagResourceError.TooManyTagsExceptionCase(e))
      case e: InvalidRequestException => Some(TagResourceError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(TagResourceError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: TagResourceError): Throwable = e match {
      case TagResourceError.ConcurrentModificationExceptionCase(e) => e
      case TagResourceError.InternalServerExceptionCase(e) => e
      case TagResourceError.TooManyTagsExceptionCase(e) => e
      case TagResourceError.InvalidRequestExceptionCase(e) => e
      case TagResourceError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class UntagResource(input: UntagResourceRequest) extends ComprehendOperation[UntagResourceRequest, ComprehendOperation.UntagResourceError, UntagResourceResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[UntagResourceRequest, ComprehendOperation.UntagResourceError, UntagResourceResponse, Nothing, Nothing] = impl.untagResource(input.resourceArn, input.tagKeys)
    def ordinal: Int = 81
    def endpoint: smithy4s.Endpoint[ComprehendOperation,UntagResourceRequest, ComprehendOperation.UntagResourceError, UntagResourceResponse, Nothing, Nothing] = UntagResource
  }
  object UntagResource extends smithy4s.Endpoint[ComprehendOperation,UntagResourceRequest, ComprehendOperation.UntagResourceError, UntagResourceResponse, Nothing, Nothing] {
    val schema: OperationSchema[UntagResourceRequest, ComprehendOperation.UntagResourceError, UntagResourceResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "UntagResource"))
      .withInput(UntagResourceRequest.schema)
      .withError(UntagResourceError.errorSchema)
      .withOutput(UntagResourceResponse.schema)
      .withHints(smithy.api.Documentation("<p>Removes a specific tag associated with an Amazon Comprehend resource. </p>"))
    def wrap(input: UntagResourceRequest): UntagResource = UntagResource(input)
  }
  sealed trait UntagResourceError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: UntagResourceError = this
    def $ordinal: Int

    object project {
      def tooManyTagKeysException: Option[TooManyTagKeysException] = UntagResourceError.TooManyTagKeysExceptionCase.alt.project.lift(self).map(_.tooManyTagKeysException)
      def concurrentModificationException: Option[ConcurrentModificationException] = UntagResourceError.ConcurrentModificationExceptionCase.alt.project.lift(self).map(_.concurrentModificationException)
      def internalServerException: Option[InternalServerException] = UntagResourceError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def invalidRequestException: Option[InvalidRequestException] = UntagResourceError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = UntagResourceError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: UntagResourceError.Visitor[A]): A = this match {
      case value: UntagResourceError.TooManyTagKeysExceptionCase => visitor.tooManyTagKeysException(value.tooManyTagKeysException)
      case value: UntagResourceError.ConcurrentModificationExceptionCase => visitor.concurrentModificationException(value.concurrentModificationException)
      case value: UntagResourceError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: UntagResourceError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: UntagResourceError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object UntagResourceError extends ErrorSchema.Companion[UntagResourceError] {

    def tooManyTagKeysException(tooManyTagKeysException: TooManyTagKeysException): UntagResourceError = TooManyTagKeysExceptionCase(tooManyTagKeysException)
    def concurrentModificationException(concurrentModificationException: ConcurrentModificationException): UntagResourceError = ConcurrentModificationExceptionCase(concurrentModificationException)
    def internalServerException(internalServerException: InternalServerException): UntagResourceError = InternalServerExceptionCase(internalServerException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): UntagResourceError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): UntagResourceError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "UntagResourceError")

    val hints: Hints = Hints.empty

    final case class TooManyTagKeysExceptionCase(tooManyTagKeysException: TooManyTagKeysException) extends UntagResourceError { final def $ordinal: Int = 0 }
    final case class ConcurrentModificationExceptionCase(concurrentModificationException: ConcurrentModificationException) extends UntagResourceError { final def $ordinal: Int = 1 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends UntagResourceError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends UntagResourceError { final def $ordinal: Int = 3 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends UntagResourceError { final def $ordinal: Int = 4 }

    object TooManyTagKeysExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UntagResourceError.TooManyTagKeysExceptionCase] = bijection(TooManyTagKeysException.schema.addHints(hints), UntagResourceError.TooManyTagKeysExceptionCase(_), _.tooManyTagKeysException)
      val alt = schema.oneOf[UntagResourceError]("TooManyTagKeysException")
    }
    object ConcurrentModificationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UntagResourceError.ConcurrentModificationExceptionCase] = bijection(ConcurrentModificationException.schema.addHints(hints), UntagResourceError.ConcurrentModificationExceptionCase(_), _.concurrentModificationException)
      val alt = schema.oneOf[UntagResourceError]("ConcurrentModificationException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UntagResourceError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), UntagResourceError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[UntagResourceError]("InternalServerException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UntagResourceError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), UntagResourceError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[UntagResourceError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UntagResourceError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), UntagResourceError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[UntagResourceError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def tooManyTagKeysException(value: TooManyTagKeysException): A
      def concurrentModificationException(value: ConcurrentModificationException): A
      def internalServerException(value: InternalServerException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def tooManyTagKeysException(value: TooManyTagKeysException): A = default
        def concurrentModificationException(value: ConcurrentModificationException): A = default
        def internalServerException(value: InternalServerException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[UntagResourceError] = union(
      UntagResourceError.TooManyTagKeysExceptionCase.alt,
      UntagResourceError.ConcurrentModificationExceptionCase.alt,
      UntagResourceError.InternalServerExceptionCase.alt,
      UntagResourceError.InvalidRequestExceptionCase.alt,
      UntagResourceError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[UntagResourceError] = throwable match {
      case e: TooManyTagKeysException => Some(UntagResourceError.TooManyTagKeysExceptionCase(e))
      case e: ConcurrentModificationException => Some(UntagResourceError.ConcurrentModificationExceptionCase(e))
      case e: InternalServerException => Some(UntagResourceError.InternalServerExceptionCase(e))
      case e: InvalidRequestException => Some(UntagResourceError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(UntagResourceError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: UntagResourceError): Throwable = e match {
      case UntagResourceError.TooManyTagKeysExceptionCase(e) => e
      case UntagResourceError.ConcurrentModificationExceptionCase(e) => e
      case UntagResourceError.InternalServerExceptionCase(e) => e
      case UntagResourceError.InvalidRequestExceptionCase(e) => e
      case UntagResourceError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class UpdateEndpoint(input: UpdateEndpointRequest) extends ComprehendOperation[UpdateEndpointRequest, ComprehendOperation.UpdateEndpointError, UpdateEndpointResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[UpdateEndpointRequest, ComprehendOperation.UpdateEndpointError, UpdateEndpointResponse, Nothing, Nothing] = impl.updateEndpoint(input.endpointArn, input.desiredModelArn, input.desiredInferenceUnits, input.desiredDataAccessRoleArn, input.flywheelArn)
    def ordinal: Int = 82
    def endpoint: smithy4s.Endpoint[ComprehendOperation,UpdateEndpointRequest, ComprehendOperation.UpdateEndpointError, UpdateEndpointResponse, Nothing, Nothing] = UpdateEndpoint
  }
  object UpdateEndpoint extends smithy4s.Endpoint[ComprehendOperation,UpdateEndpointRequest, ComprehendOperation.UpdateEndpointError, UpdateEndpointResponse, Nothing, Nothing] {
    val schema: OperationSchema[UpdateEndpointRequest, ComprehendOperation.UpdateEndpointError, UpdateEndpointResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "UpdateEndpoint"))
      .withInput(UpdateEndpointRequest.schema)
      .withError(UpdateEndpointError.errorSchema)
      .withOutput(UpdateEndpointResponse.schema)
      .withHints(smithy.api.Documentation("<p>Updates information about the specified endpoint.\n      For information about endpoints, see <a href=\"https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html\">Managing endpoints</a>.</p>"))
    def wrap(input: UpdateEndpointRequest): UpdateEndpoint = UpdateEndpoint(input)
  }
  sealed trait UpdateEndpointError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: UpdateEndpointError = this
    def $ordinal: Int

    object project {
      def resourceLimitExceededException: Option[ResourceLimitExceededException] = UpdateEndpointError.ResourceLimitExceededExceptionCase.alt.project.lift(self).map(_.resourceLimitExceededException)
      def internalServerException: Option[InternalServerException] = UpdateEndpointError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def resourceUnavailableException: Option[ResourceUnavailableException] = UpdateEndpointError.ResourceUnavailableExceptionCase.alt.project.lift(self).map(_.resourceUnavailableException)
      def resourceInUseException: Option[ResourceInUseException] = UpdateEndpointError.ResourceInUseExceptionCase.alt.project.lift(self).map(_.resourceInUseException)
      def tooManyRequestsException: Option[TooManyRequestsException] = UpdateEndpointError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = UpdateEndpointError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = UpdateEndpointError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: UpdateEndpointError.Visitor[A]): A = this match {
      case value: UpdateEndpointError.ResourceLimitExceededExceptionCase => visitor.resourceLimitExceededException(value.resourceLimitExceededException)
      case value: UpdateEndpointError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: UpdateEndpointError.ResourceUnavailableExceptionCase => visitor.resourceUnavailableException(value.resourceUnavailableException)
      case value: UpdateEndpointError.ResourceInUseExceptionCase => visitor.resourceInUseException(value.resourceInUseException)
      case value: UpdateEndpointError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: UpdateEndpointError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: UpdateEndpointError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object UpdateEndpointError extends ErrorSchema.Companion[UpdateEndpointError] {

    def resourceLimitExceededException(resourceLimitExceededException: ResourceLimitExceededException): UpdateEndpointError = ResourceLimitExceededExceptionCase(resourceLimitExceededException)
    def internalServerException(internalServerException: InternalServerException): UpdateEndpointError = InternalServerExceptionCase(internalServerException)
    def resourceUnavailableException(resourceUnavailableException: ResourceUnavailableException): UpdateEndpointError = ResourceUnavailableExceptionCase(resourceUnavailableException)
    def resourceInUseException(resourceInUseException: ResourceInUseException): UpdateEndpointError = ResourceInUseExceptionCase(resourceInUseException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): UpdateEndpointError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): UpdateEndpointError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): UpdateEndpointError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "UpdateEndpointError")

    val hints: Hints = Hints.empty

    final case class ResourceLimitExceededExceptionCase(resourceLimitExceededException: ResourceLimitExceededException) extends UpdateEndpointError { final def $ordinal: Int = 0 }
    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends UpdateEndpointError { final def $ordinal: Int = 1 }
    final case class ResourceUnavailableExceptionCase(resourceUnavailableException: ResourceUnavailableException) extends UpdateEndpointError { final def $ordinal: Int = 2 }
    final case class ResourceInUseExceptionCase(resourceInUseException: ResourceInUseException) extends UpdateEndpointError { final def $ordinal: Int = 3 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends UpdateEndpointError { final def $ordinal: Int = 4 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends UpdateEndpointError { final def $ordinal: Int = 5 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends UpdateEndpointError { final def $ordinal: Int = 6 }

    object ResourceLimitExceededExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateEndpointError.ResourceLimitExceededExceptionCase] = bijection(ResourceLimitExceededException.schema.addHints(hints), UpdateEndpointError.ResourceLimitExceededExceptionCase(_), _.resourceLimitExceededException)
      val alt = schema.oneOf[UpdateEndpointError]("ResourceLimitExceededException")
    }
    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateEndpointError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), UpdateEndpointError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[UpdateEndpointError]("InternalServerException")
    }
    object ResourceUnavailableExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateEndpointError.ResourceUnavailableExceptionCase] = bijection(ResourceUnavailableException.schema.addHints(hints), UpdateEndpointError.ResourceUnavailableExceptionCase(_), _.resourceUnavailableException)
      val alt = schema.oneOf[UpdateEndpointError]("ResourceUnavailableException")
    }
    object ResourceInUseExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateEndpointError.ResourceInUseExceptionCase] = bijection(ResourceInUseException.schema.addHints(hints), UpdateEndpointError.ResourceInUseExceptionCase(_), _.resourceInUseException)
      val alt = schema.oneOf[UpdateEndpointError]("ResourceInUseException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateEndpointError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), UpdateEndpointError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[UpdateEndpointError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateEndpointError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), UpdateEndpointError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[UpdateEndpointError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateEndpointError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), UpdateEndpointError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[UpdateEndpointError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def resourceLimitExceededException(value: ResourceLimitExceededException): A
      def internalServerException(value: InternalServerException): A
      def resourceUnavailableException(value: ResourceUnavailableException): A
      def resourceInUseException(value: ResourceInUseException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def resourceLimitExceededException(value: ResourceLimitExceededException): A = default
        def internalServerException(value: InternalServerException): A = default
        def resourceUnavailableException(value: ResourceUnavailableException): A = default
        def resourceInUseException(value: ResourceInUseException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[UpdateEndpointError] = union(
      UpdateEndpointError.ResourceLimitExceededExceptionCase.alt,
      UpdateEndpointError.InternalServerExceptionCase.alt,
      UpdateEndpointError.ResourceUnavailableExceptionCase.alt,
      UpdateEndpointError.ResourceInUseExceptionCase.alt,
      UpdateEndpointError.TooManyRequestsExceptionCase.alt,
      UpdateEndpointError.InvalidRequestExceptionCase.alt,
      UpdateEndpointError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[UpdateEndpointError] = throwable match {
      case e: ResourceLimitExceededException => Some(UpdateEndpointError.ResourceLimitExceededExceptionCase(e))
      case e: InternalServerException => Some(UpdateEndpointError.InternalServerExceptionCase(e))
      case e: ResourceUnavailableException => Some(UpdateEndpointError.ResourceUnavailableExceptionCase(e))
      case e: ResourceInUseException => Some(UpdateEndpointError.ResourceInUseExceptionCase(e))
      case e: TooManyRequestsException => Some(UpdateEndpointError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(UpdateEndpointError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(UpdateEndpointError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: UpdateEndpointError): Throwable = e match {
      case UpdateEndpointError.ResourceLimitExceededExceptionCase(e) => e
      case UpdateEndpointError.InternalServerExceptionCase(e) => e
      case UpdateEndpointError.ResourceUnavailableExceptionCase(e) => e
      case UpdateEndpointError.ResourceInUseExceptionCase(e) => e
      case UpdateEndpointError.TooManyRequestsExceptionCase(e) => e
      case UpdateEndpointError.InvalidRequestExceptionCase(e) => e
      case UpdateEndpointError.ResourceNotFoundExceptionCase(e) => e
    }
  }
  final case class UpdateFlywheel(input: UpdateFlywheelRequest) extends ComprehendOperation[UpdateFlywheelRequest, ComprehendOperation.UpdateFlywheelError, UpdateFlywheelResponse, Nothing, Nothing] {
    def run[F[_, _, _, _, _]](impl: ComprehendGen[F]): F[UpdateFlywheelRequest, ComprehendOperation.UpdateFlywheelError, UpdateFlywheelResponse, Nothing, Nothing] = impl.updateFlywheel(input.flywheelArn, input.activeModelArn, input.dataAccessRoleArn, input.dataSecurityConfig)
    def ordinal: Int = 83
    def endpoint: smithy4s.Endpoint[ComprehendOperation,UpdateFlywheelRequest, ComprehendOperation.UpdateFlywheelError, UpdateFlywheelResponse, Nothing, Nothing] = UpdateFlywheel
  }
  object UpdateFlywheel extends smithy4s.Endpoint[ComprehendOperation,UpdateFlywheelRequest, ComprehendOperation.UpdateFlywheelError, UpdateFlywheelResponse, Nothing, Nothing] {
    val schema: OperationSchema[UpdateFlywheelRequest, ComprehendOperation.UpdateFlywheelError, UpdateFlywheelResponse, Nothing, Nothing] = Schema.operation(ShapeId("com.amazonaws.comprehend", "UpdateFlywheel"))
      .withInput(UpdateFlywheelRequest.schema)
      .withError(UpdateFlywheelError.errorSchema)
      .withOutput(UpdateFlywheelResponse.schema)
      .withHints(smithy.api.Documentation("<p>Update the configuration information for an existing flywheel.</p>"))
    def wrap(input: UpdateFlywheelRequest): UpdateFlywheel = UpdateFlywheel(input)
  }
  sealed trait UpdateFlywheelError extends scala.Product with scala.Serializable { self =>
    @inline final def widen: UpdateFlywheelError = this
    def $ordinal: Int

    object project {
      def internalServerException: Option[InternalServerException] = UpdateFlywheelError.InternalServerExceptionCase.alt.project.lift(self).map(_.internalServerException)
      def kmsKeyValidationException: Option[KmsKeyValidationException] = UpdateFlywheelError.KmsKeyValidationExceptionCase.alt.project.lift(self).map(_.kmsKeyValidationException)
      def tooManyRequestsException: Option[TooManyRequestsException] = UpdateFlywheelError.TooManyRequestsExceptionCase.alt.project.lift(self).map(_.tooManyRequestsException)
      def invalidRequestException: Option[InvalidRequestException] = UpdateFlywheelError.InvalidRequestExceptionCase.alt.project.lift(self).map(_.invalidRequestException)
      def resourceNotFoundException: Option[ResourceNotFoundException] = UpdateFlywheelError.ResourceNotFoundExceptionCase.alt.project.lift(self).map(_.resourceNotFoundException)
    }

    def accept[A](visitor: UpdateFlywheelError.Visitor[A]): A = this match {
      case value: UpdateFlywheelError.InternalServerExceptionCase => visitor.internalServerException(value.internalServerException)
      case value: UpdateFlywheelError.KmsKeyValidationExceptionCase => visitor.kmsKeyValidationException(value.kmsKeyValidationException)
      case value: UpdateFlywheelError.TooManyRequestsExceptionCase => visitor.tooManyRequestsException(value.tooManyRequestsException)
      case value: UpdateFlywheelError.InvalidRequestExceptionCase => visitor.invalidRequestException(value.invalidRequestException)
      case value: UpdateFlywheelError.ResourceNotFoundExceptionCase => visitor.resourceNotFoundException(value.resourceNotFoundException)
    }
  }
  object UpdateFlywheelError extends ErrorSchema.Companion[UpdateFlywheelError] {

    def internalServerException(internalServerException: InternalServerException): UpdateFlywheelError = InternalServerExceptionCase(internalServerException)
    def kmsKeyValidationException(kmsKeyValidationException: KmsKeyValidationException): UpdateFlywheelError = KmsKeyValidationExceptionCase(kmsKeyValidationException)
    def tooManyRequestsException(tooManyRequestsException: TooManyRequestsException): UpdateFlywheelError = TooManyRequestsExceptionCase(tooManyRequestsException)
    def invalidRequestException(invalidRequestException: InvalidRequestException): UpdateFlywheelError = InvalidRequestExceptionCase(invalidRequestException)
    def resourceNotFoundException(resourceNotFoundException: ResourceNotFoundException): UpdateFlywheelError = ResourceNotFoundExceptionCase(resourceNotFoundException)

    val id: ShapeId = ShapeId("com.amazonaws.comprehend", "UpdateFlywheelError")

    val hints: Hints = Hints.empty

    final case class InternalServerExceptionCase(internalServerException: InternalServerException) extends UpdateFlywheelError { final def $ordinal: Int = 0 }
    final case class KmsKeyValidationExceptionCase(kmsKeyValidationException: KmsKeyValidationException) extends UpdateFlywheelError { final def $ordinal: Int = 1 }
    final case class TooManyRequestsExceptionCase(tooManyRequestsException: TooManyRequestsException) extends UpdateFlywheelError { final def $ordinal: Int = 2 }
    final case class InvalidRequestExceptionCase(invalidRequestException: InvalidRequestException) extends UpdateFlywheelError { final def $ordinal: Int = 3 }
    final case class ResourceNotFoundExceptionCase(resourceNotFoundException: ResourceNotFoundException) extends UpdateFlywheelError { final def $ordinal: Int = 4 }

    object InternalServerExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateFlywheelError.InternalServerExceptionCase] = bijection(InternalServerException.schema.addHints(hints), UpdateFlywheelError.InternalServerExceptionCase(_), _.internalServerException)
      val alt = schema.oneOf[UpdateFlywheelError]("InternalServerException")
    }
    object KmsKeyValidationExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateFlywheelError.KmsKeyValidationExceptionCase] = bijection(KmsKeyValidationException.schema.addHints(hints), UpdateFlywheelError.KmsKeyValidationExceptionCase(_), _.kmsKeyValidationException)
      val alt = schema.oneOf[UpdateFlywheelError]("KmsKeyValidationException")
    }
    object TooManyRequestsExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateFlywheelError.TooManyRequestsExceptionCase] = bijection(TooManyRequestsException.schema.addHints(hints), UpdateFlywheelError.TooManyRequestsExceptionCase(_), _.tooManyRequestsException)
      val alt = schema.oneOf[UpdateFlywheelError]("TooManyRequestsException")
    }
    object InvalidRequestExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateFlywheelError.InvalidRequestExceptionCase] = bijection(InvalidRequestException.schema.addHints(hints), UpdateFlywheelError.InvalidRequestExceptionCase(_), _.invalidRequestException)
      val alt = schema.oneOf[UpdateFlywheelError]("InvalidRequestException")
    }
    object ResourceNotFoundExceptionCase {
      val hints: Hints = Hints.empty
      val schema: Schema[UpdateFlywheelError.ResourceNotFoundExceptionCase] = bijection(ResourceNotFoundException.schema.addHints(hints), UpdateFlywheelError.ResourceNotFoundExceptionCase(_), _.resourceNotFoundException)
      val alt = schema.oneOf[UpdateFlywheelError]("ResourceNotFoundException")
    }

    trait Visitor[A] {
      def internalServerException(value: InternalServerException): A
      def kmsKeyValidationException(value: KmsKeyValidationException): A
      def tooManyRequestsException(value: TooManyRequestsException): A
      def invalidRequestException(value: InvalidRequestException): A
      def resourceNotFoundException(value: ResourceNotFoundException): A
    }

    object Visitor {
      trait Default[A] extends Visitor[A] {
        def default: A
        def internalServerException(value: InternalServerException): A = default
        def kmsKeyValidationException(value: KmsKeyValidationException): A = default
        def tooManyRequestsException(value: TooManyRequestsException): A = default
        def invalidRequestException(value: InvalidRequestException): A = default
        def resourceNotFoundException(value: ResourceNotFoundException): A = default
      }
    }

    implicit val schema: Schema[UpdateFlywheelError] = union(
      UpdateFlywheelError.InternalServerExceptionCase.alt,
      UpdateFlywheelError.KmsKeyValidationExceptionCase.alt,
      UpdateFlywheelError.TooManyRequestsExceptionCase.alt,
      UpdateFlywheelError.InvalidRequestExceptionCase.alt,
      UpdateFlywheelError.ResourceNotFoundExceptionCase.alt,
    ){
      _.$ordinal
    }
    def liftError(throwable: Throwable): Option[UpdateFlywheelError] = throwable match {
      case e: InternalServerException => Some(UpdateFlywheelError.InternalServerExceptionCase(e))
      case e: KmsKeyValidationException => Some(UpdateFlywheelError.KmsKeyValidationExceptionCase(e))
      case e: TooManyRequestsException => Some(UpdateFlywheelError.TooManyRequestsExceptionCase(e))
      case e: InvalidRequestException => Some(UpdateFlywheelError.InvalidRequestExceptionCase(e))
      case e: ResourceNotFoundException => Some(UpdateFlywheelError.ResourceNotFoundExceptionCase(e))
      case _ => None
    }
    def unliftError(e: UpdateFlywheelError): Throwable = e match {
      case UpdateFlywheelError.InternalServerExceptionCase(e) => e
      case UpdateFlywheelError.KmsKeyValidationExceptionCase(e) => e
      case UpdateFlywheelError.TooManyRequestsExceptionCase(e) => e
      case UpdateFlywheelError.InvalidRequestExceptionCase(e) => e
      case UpdateFlywheelError.ResourceNotFoundExceptionCase(e) => e
    }
  }
}

